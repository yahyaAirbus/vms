/*!
 * 
 * SWSIPVOIP2 version 2.0.101247
 * Copyright (c) 2014-2022 streamwide, sa <http://www.streamwide.com>
 * Homepage: https://streamwide.com
 *
 * SWSIPVOIP2 includes code from jssip:
 *
 * Name: JsSIP
 * Maintainer: José Luis Millán <jmillan@aliax.net>
 * Copyright © 2012-2015 José Luis Millán – Versatica <http://www.versatica.com>
 *
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * *** end JsSIP license ***
 *
 *
 *
 *
 *
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define([], factory);
  else if (typeof exports === 'object')
    exports["SWSIPVOIP2"] = factory();
  else
    root["SWSIPVOIP2"] = factory();
})(this, () => {
  return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
          /* harmony export */
        });
        /******************************************************************************
        Copyright (c) Microsoft Corporation.
        
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise */

        var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
          return extendStatics(d, b);
        };

        function __extends(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        }

        var __assign = function () {
          __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
          }
          return __assign.apply(this, arguments);
        }

        function __rest(s, e) {
          var t = {};
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        }

        function __decorate(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
          else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        }

        function __param(paramIndex, decorator) {
          return function (target, key) { decorator(target, key, paramIndex); }
        }

        function __metadata(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
        }

        function __awaiter(thisArg, _arguments, P, generator) {
          function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        }

        function __generator(thisArg, body) {
          var _ = { label: 0, sent: function () { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
          function verb(n) { return function (v) { return step([n, v]); }; }
          function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
          }
        }

        var __createBinding = Object.create ? (function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function () { return m[k]; } };
          }
          Object.defineProperty(o, k2, desc);
        }) : (function (o, m, k, k2) {
          if (k2 === undefined) k2 = k;
          o[k2] = m[k];
        });

        function __exportStar(m, o) {
          for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
        }

        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m) return m.call(o);
          if (o && typeof o.length === "number") return {
            next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }

        function __read(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m) return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
          }
          catch (error) { e = { error: error }; }
          finally {
            try {
              if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
          }
          return ar;
        }

        /** @deprecated */
        function __spread() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
          return ar;
        }

        /** @deprecated */
        function __spreadArrays() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        }

        function __spreadArray(to, from, pack) {
          if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
          return to.concat(ar || Array.prototype.slice.call(from));
        }

        function __await(v) {
          return this instanceof __await ? (this.v = v, this) : new __await(v);
        }

        function __asyncGenerator(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
          function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
          function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
          function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
          function fulfill(value) { resume("next", value); }
          function reject(value) { resume("throw", value); }
          function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
        }

        function __asyncDelegator(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
          function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
        }

        function __asyncValues(o) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
          function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
          function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
        }

        function __makeTemplateObject(cooked, raw) {
          if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
          return cooked;
        };

        var __setModuleDefault = Object.create ? (function (o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        }) : function (o, v) {
          o["default"] = v;
        };

        function __importStar(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        }

        function __importDefault(mod) {
          return (mod && mod.__esModule) ? mod : { default: mod };
        }

        function __classPrivateFieldGet(receiver, state, kind, f) {
          if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        }

        function __classPrivateFieldSet(receiver, state, value, kind, f) {
          if (kind === "m") throw new TypeError("Private method is not writable");
          if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
        }

        function __classPrivateFieldIn(state, receiver) {
          if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        }


        /***/
      }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.disable = exports.enable = exports.Debugger = void 0;
        var tslib_1 = __webpack_require__(1);
        var C = tslib_1.__importStar(__webpack_require__(3));
        var JsSIP = tslib_1.__importStar(__webpack_require__(4));
        var debug_1 = __webpack_require__(15);
        exports.Debugger = (0, debug_1.debug)(C.name);
        debug_1.debug.log = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          console.log("".concat(new Date().toISOString(), " | ").concat(args[0]), args[1], args[2], args[3]);
        };
        var enable = function (str) {
          if (!str) {
            str = "".concat(C.name, ":*,").concat(JsSIP.name, ":*");
          }
          debug_1.debug.enable(str);
        };
        exports.enable = enable;
        var disable = function () {
          debug_1.debug.disable();
        };
        exports.disable = disable;


        /***/
      }),
/* 3 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.VOIP_APP_PORT = exports.VOIP_APP = exports.AUTO_RECONNECT_MAX_DELAY = exports.USER_AGENT = exports.name = exports.version = void 0;
        var tslib_1 = __webpack_require__(1);
        var JsSIP = tslib_1.__importStar(__webpack_require__(4));
        var version_1 = __webpack_require__(43);
        var webrtc_adapter_1 = tslib_1.__importDefault(__webpack_require__(44));
        /** @public */
        exports.version = version_1.LIBRARY_VERSION;
        /** @public */
        exports.name = 'SWSIPVOIP2';
        /** @public */
        exports.USER_AGENT = "".concat(webrtc_adapter_1.default.browserDetails.browser, " ").concat(webrtc_adapter_1.default.browserDetails.version || '?', " ")
          + "".concat(JsSIP.name, "/").concat(JsSIP.version, " SWSIPVOIP2.js/").concat(version_1.LIBRARY_VERSION);
        /** @internal */
        exports.AUTO_RECONNECT_MAX_DELAY = 25;
        /** @internal */
        exports.VOIP_APP = 'swsmartms-voip';
        /** @internal */
        exports.VOIP_APP_PORT = 5063;


        /***/
      }),
/* 4 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        var pkg = __webpack_require__(5);

        var C = __webpack_require__(6);

        var Exceptions = __webpack_require__(7);

        var Utils = __webpack_require__(8);

        var UA = __webpack_require__(12);

        var URI = __webpack_require__(9);

        var NameAddrHeader = __webpack_require__(11);

        var Grammar = __webpack_require__(10);

        var WebSocketInterface = __webpack_require__(42);

        var debug = __webpack_require__(15)('JsSIP');

        debug('version %s', pkg.version);
        /**
         * Expose the JsSIP module.
         */

        module.exports = {
          C: C,
          Exceptions: Exceptions,
          Utils: Utils,
          UA: UA,
          URI: URI,
          NameAddrHeader: NameAddrHeader,
          WebSocketInterface: WebSocketInterface,
          Grammar: Grammar,
          // Expose the debug module.
          debug: __webpack_require__(15),

          get name() {
            return pkg.title;
          },

          get version() {
            return pkg.version;
          }

        };

        /***/
      }),
/* 5 */
/***/ ((module) => {

        "use strict";
        module.exports = JSON.parse('{"name":"jssip","title":"JsSIP","description":"the Javascript SIP library","version":"3.9.0","homepage":"https://jssip.net","contributors":["José Luis Millán <jmillan@aliax.net> (https://github.com/jmillan)","Iñaki Baz Castillo <ibc@aliax.net> (https://inakibaz.me)"],"types":"lib/JsSIP.d.ts","main":"lib-es5/JsSIP.js","keywords":["sip","websocket","webrtc","node","browser","library"],"license":"MIT","repository":{"type":"git","url":"https://github.com/versatica/JsSIP.git"},"bugs":{"url":"https://github.com/versatica/JsSIP/issues"},"dependencies":{"@types/debug":"^4.1.5","@types/node":"^14.14.34","debug":"^4.3.1","events":"^3.3.0","sdp-transform":"^2.14.1"},"devDependencies":{"@babel/core":"^7.13.10","@babel/preset-env":"^7.13.10","ansi-colors":"^3.2.4","browserify":"^16.5.1","eslint":"^5.16.0","fancy-log":"^1.3.3","gulp":"^4.0.2","gulp-babel":"^8.0.0","gulp-eslint":"^5.0.0","gulp-expect-file":"^1.0.2","gulp-header":"^2.0.9","gulp-nodeunit-runner":"^0.2.2","gulp-plumber":"^1.2.1","gulp-rename":"^1.4.0","gulp-uglify-es":"^1.0.4","pegjs":"^0.7.0","vinyl-buffer":"^1.0.1","vinyl-source-stream":"^2.0.0"},"scripts":{"lint":"gulp lint","test":"gulp test","prepublishOnly":"gulp babel"}}');

        /***/
      }),
/* 6 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        var pkg = __webpack_require__(5);

        module.exports = {
          USER_AGENT: "".concat(pkg.title, " ").concat(pkg.version),
          // SIP scheme.
          SIP: 'sip',
          SIPS: 'sips',
          // End and Failure causes.
          causes: {
            // Generic error causes.
            CONNECTION_ERROR: 'Connection Error',
            REQUEST_TIMEOUT: 'Request Timeout',
            SIP_FAILURE_CODE: 'SIP Failure Code',
            INTERNAL_ERROR: 'Internal Error',
            // SIP error causes.
            BUSY: 'Busy',
            REJECTED: 'Rejected',
            REDIRECTED: 'Redirected',
            UNAVAILABLE: 'Unavailable',
            NOT_FOUND: 'Not Found',
            ADDRESS_INCOMPLETE: 'Address Incomplete',
            INCOMPATIBLE_SDP: 'Incompatible SDP',
            MISSING_SDP: 'Missing SDP',
            AUTHENTICATION_ERROR: 'Authentication Error',
            // Session error causes.
            BYE: 'Terminated',
            WEBRTC_ERROR: 'WebRTC Error',
            CANCELED: 'Canceled',
            NO_ANSWER: 'No Answer',
            EXPIRES: 'Expires',
            NO_ACK: 'No ACK',
            DIALOG_ERROR: 'Dialog Error',
            USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
            BAD_MEDIA_DESCRIPTION: 'Bad Media Description',
            RTP_TIMEOUT: 'RTP Timeout'
          },
          SIP_ERROR_CAUSES: {
            REDIRECTED: [300, 301, 302, 305, 380],
            BUSY: [486, 600],
            REJECTED: [403, 603],
            NOT_FOUND: [404, 604],
            UNAVAILABLE: [480, 410, 408, 430],
            ADDRESS_INCOMPLETE: [484, 424],
            INCOMPATIBLE_SDP: [488, 606],
            AUTHENTICATION_ERROR: [401, 407]
          },
          // SIP Methods.
          ACK: 'ACK',
          BYE: 'BYE',
          CANCEL: 'CANCEL',
          INFO: 'INFO',
          INVITE: 'INVITE',
          MESSAGE: 'MESSAGE',
          NOTIFY: 'NOTIFY',
          OPTIONS: 'OPTIONS',
          REGISTER: 'REGISTER',
          REFER: 'REFER',
          UPDATE: 'UPDATE',
          SUBSCRIBE: 'SUBSCRIBE',
          // DTMF transport methods.
          DTMF_TRANSPORT: {
            INFO: 'INFO',
            RFC2833: 'RFC2833'
          },

          /* SIP Response Reasons
           * DOC: https://www.iana.org/assignments/sip-parameters
           * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
           */
          REASON_PHRASE: {
            100: 'Trying',
            180: 'Ringing',
            181: 'Call Is Being Forwarded',
            182: 'Queued',
            183: 'Session Progress',
            199: 'Early Dialog Terminated',
            // draft-ietf-sipcore-199
            200: 'OK',
            202: 'Accepted',
            // RFC 3265
            204: 'No Notification',
            // RFC 5839
            300: 'Multiple Choices',
            301: 'Moved Permanently',
            302: 'Moved Temporarily',
            305: 'Use Proxy',
            380: 'Alternative Service',
            400: 'Bad Request',
            401: 'Unauthorized',
            402: 'Payment Required',
            403: 'Forbidden',
            404: 'Not Found',
            405: 'Method Not Allowed',
            406: 'Not Acceptable',
            407: 'Proxy Authentication Required',
            408: 'Request Timeout',
            410: 'Gone',
            412: 'Conditional Request Failed',
            // RFC 3903
            413: 'Request Entity Too Large',
            414: 'Request-URI Too Long',
            415: 'Unsupported Media Type',
            416: 'Unsupported URI Scheme',
            417: 'Unknown Resource-Priority',
            // RFC 4412
            420: 'Bad Extension',
            421: 'Extension Required',
            422: 'Session Interval Too Small',
            // RFC 4028
            423: 'Interval Too Brief',
            424: 'Bad Location Information',
            // RFC 6442
            428: 'Use Identity Header',
            // RFC 4474
            429: 'Provide Referrer Identity',
            // RFC 3892
            430: 'Flow Failed',
            // RFC 5626
            433: 'Anonymity Disallowed',
            // RFC 5079
            436: 'Bad Identity-Info',
            // RFC 4474
            437: 'Unsupported Certificate',
            // RFC 4744
            438: 'Invalid Identity Header',
            // RFC 4744
            439: 'First Hop Lacks Outbound Support',
            // RFC 5626
            440: 'Max-Breadth Exceeded',
            // RFC 5393
            469: 'Bad Info Package',
            // draft-ietf-sipcore-info-events
            470: 'Consent Needed',
            // RFC 5360
            478: 'Unresolvable Destination',
            // Custom code copied from Kamailio.
            480: 'Temporarily Unavailable',
            481: 'Call/Transaction Does Not Exist',
            482: 'Loop Detected',
            483: 'Too Many Hops',
            484: 'Address Incomplete',
            485: 'Ambiguous',
            486: 'Busy Here',
            487: 'Request Terminated',
            488: 'Not Acceptable Here',
            489: 'Bad Event',
            // RFC 3265
            491: 'Request Pending',
            493: 'Undecipherable',
            494: 'Security Agreement Required',
            // RFC 3329
            500: 'JsSIP Internal Error',
            501: 'Not Implemented',
            502: 'Bad Gateway',
            503: 'Service Unavailable',
            504: 'Server Time-out',
            505: 'Version Not Supported',
            513: 'Message Too Large',
            580: 'Precondition Failure',
            // RFC 3312
            600: 'Busy Everywhere',
            603: 'Decline',
            604: 'Does Not Exist Anywhere',
            606: 'Not Acceptable'
          },
          ALLOWED_METHODS: 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS,REFER,INFO,NOTIFY',
          ACCEPTED_BODY_TYPES: 'application/sdp, application/dtmf-relay',
          MAX_FORWARDS: 69,
          SESSION_EXPIRES: 90,
          MIN_SESSION_EXPIRES: 60,
          CONNECTION_RECOVERY_MAX_INTERVAL: 30,
          CONNECTION_RECOVERY_MIN_INTERVAL: 2
        };

        /***/
      }),
/* 7 */
/***/ ((module) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

        function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var ConfigurationError = /*#__PURE__*/function (_Error) {
          _inherits(ConfigurationError, _Error);

          var _super = _createSuper(ConfigurationError);

          function ConfigurationError(parameter, value) {
            var _this;

            _classCallCheck(this, ConfigurationError);

            _this = _super.call(this);
            _this.code = 1;
            _this.name = 'CONFIGURATION_ERROR';
            _this.parameter = parameter;
            _this.value = value;
            _this.message = !_this.value ? "Missing parameter: ".concat(_this.parameter) : "Invalid value ".concat(JSON.stringify(_this.value), " for parameter \"").concat(_this.parameter, "\"");
            return _this;
          }

          return ConfigurationError;
        }( /*#__PURE__*/_wrapNativeSuper(Error));

        var InvalidStateError = /*#__PURE__*/function (_Error2) {
          _inherits(InvalidStateError, _Error2);

          var _super2 = _createSuper(InvalidStateError);

          function InvalidStateError(status) {
            var _this2;

            _classCallCheck(this, InvalidStateError);

            _this2 = _super2.call(this);
            _this2.code = 2;
            _this2.name = 'INVALID_STATE_ERROR';
            _this2.status = status;
            _this2.message = "Invalid status: ".concat(status);
            return _this2;
          }

          return InvalidStateError;
        }( /*#__PURE__*/_wrapNativeSuper(Error));

        var NotSupportedError = /*#__PURE__*/function (_Error3) {
          _inherits(NotSupportedError, _Error3);

          var _super3 = _createSuper(NotSupportedError);

          function NotSupportedError(message) {
            var _this3;

            _classCallCheck(this, NotSupportedError);

            _this3 = _super3.call(this);
            _this3.code = 3;
            _this3.name = 'NOT_SUPPORTED_ERROR';
            _this3.message = message;
            return _this3;
          }

          return NotSupportedError;
        }( /*#__PURE__*/_wrapNativeSuper(Error));

        var NotReadyError = /*#__PURE__*/function (_Error4) {
          _inherits(NotReadyError, _Error4);

          var _super4 = _createSuper(NotReadyError);

          function NotReadyError(message) {
            var _this4;

            _classCallCheck(this, NotReadyError);

            _this4 = _super4.call(this);
            _this4.code = 4;
            _this4.name = 'NOT_READY_ERROR';
            _this4.message = message;
            return _this4;
          }

          return NotReadyError;
        }( /*#__PURE__*/_wrapNativeSuper(Error));

        module.exports = {
          ConfigurationError: ConfigurationError,
          InvalidStateError: InvalidStateError,
          NotSupportedError: NotSupportedError,
          NotReadyError: NotReadyError
        };

        /***/
      }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        var JsSIP_C = __webpack_require__(6);

        var URI = __webpack_require__(9);

        var Grammar = __webpack_require__(10);

        exports.str_utf8_length = function (string) {
          return unescape(encodeURIComponent(string)).length;
        }; // Used by 'hasMethods'.


        var isFunction = exports.isFunction = function (fn) {
          if (fn !== undefined) {
            return Object.prototype.toString.call(fn) === '[object Function]' ? true : false;
          } else {
            return false;
          }
        };

        exports.isString = function (str) {
          if (str !== undefined) {
            return Object.prototype.toString.call(str) === '[object String]' ? true : false;
          } else {
            return false;
          }
        };

        exports.isDecimal = function (num) {
          return !isNaN(num) && parseFloat(num) === parseInt(num, 10);
        };

        exports.isEmpty = function (value) {
          return value === null || value === '' || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === 'number' && isNaN(value);
        };

        exports.hasMethods = function (obj) {
          for (var _len = arguments.length, methodNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            methodNames[_key - 1] = arguments[_key];
          }

          for (var _i = 0, _methodNames = methodNames; _i < _methodNames.length; _i++) {
            var methodName = _methodNames[_i];

            if (isFunction(obj[methodName])) {
              return false;
            }
          }

          return true;
        }; // Used by 'newTag'.


        var createRandomToken = exports.createRandomToken = function (size) {
          var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
          var i,
            r,
            token = '';

          for (i = 0; i < size; i++) {
            r = Math.random() * base | 0;
            token += r.toString(base);
          }

          return token;
        };

        exports.newTag = function () {
          return createRandomToken(10);
        }; // https://stackoverflow.com/users/109538/broofa.


        exports.newUUID = function () {
          var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0,
              v = c === 'x' ? r : r & 0x3 | 0x8;
            return v.toString(16);
          });
          return UUID;
        };

        exports.hostType = function (host) {
          if (!host) {
            return;
          } else {
            host = Grammar.parse(host, 'host');

            if (host !== -1) {
              return host.host_type;
            }
          }
        };
        /**
        * Hex-escape a SIP URI user.
        * Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
        *
        * Used by 'normalizeTarget'.
        */


        var escapeUser = exports.escapeUser = function (user) {
          return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
        };
        /**
        * Normalize SIP URI.
        * NOTE: It does not allow a SIP URI without username.
        * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
        * Detects the domain part (if given) and properly hex-escapes the user portion.
        * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
        */


        exports.normalizeTarget = function (target, domain) {
          // If no target is given then raise an error.
          if (!target) {
            return; // If a URI instance is given then return it.
          } else if (target instanceof URI) {
            return target; // If a string is given split it by '@':
            // - Last fragment is the desired domain.
            // - Otherwise append the given domain argument.
          } else if (typeof target === 'string') {
            var target_array = target.split('@');
            var target_user;
            var target_domain;

            switch (target_array.length) {
              case 1:
                if (!domain) {
                  return;
                }

                target_user = target;
                target_domain = domain;
                break;

              case 2:
                target_user = target_array[0];
                target_domain = target_array[1];
                break;

              default:
                target_user = target_array.slice(0, target_array.length - 1).join('@');
                target_domain = target_array[target_array.length - 1];
            } // Remove the URI scheme (if present).


            target_user = target_user.replace(/^(sips?|tel):/i, ''); // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.

            if (/^[-.()]*\+?[0-9\-.()]+$/.test(target_user)) {
              target_user = target_user.replace(/[-.()]/g, '');
            } // Build the complete SIP URI.


            target = "".concat(JsSIP_C.SIP, ":").concat(escapeUser(target_user), "@").concat(target_domain); // Finally parse the resulting URI.

            var uri;

            if (uri = URI.parse(target)) {
              return uri;
            } else {
              return;
            }
          } else {
            return;
          }
        };

        exports.headerize = function (string) {
          var exceptions = {
            'Call-Id': 'Call-ID',
            'Cseq': 'CSeq',
            'Www-Authenticate': 'WWW-Authenticate'
          };
          var name = string.toLowerCase().replace(/_/g, '-').split('-');
          var hname = '';
          var parts = name.length;
          var part;

          for (part = 0; part < parts; part++) {
            if (part !== 0) {
              hname += '-';
            }

            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
          }

          if (exceptions[hname]) {
            hname = exceptions[hname];
          }

          return hname;
        };

        exports.sipErrorCause = function (status_code) {
          for (var cause in JsSIP_C.SIP_ERROR_CAUSES) {
            if (JsSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
              return JsSIP_C.causes[cause];
            }
          }

          return JsSIP_C.causes.SIP_FAILURE_CODE;
        };
        /**
        * Generate a random Test-Net IP (https://tools.ietf.org/html/rfc5735)
        */


        exports.getRandomTestNetIP = function () {
          function getOctet(from, to) {
            return Math.floor(Math.random() * (to - from + 1) + from);
          }

          return "192.0.2.".concat(getOctet(1, 254));
        }; // MD5 (Message-Digest Algorithm) https://www.webtoolkit.info.


        exports.calculateMD5 = function (string) {
          function rotateLeft(lValue, iShiftBits) {
            return lValue << iShiftBits | lValue >>> 32 - iShiftBits;
          }

          function addUnsigned(lX, lY) {
            var lX8 = lX & 0x80000000;
            var lY8 = lY & 0x80000000;
            var lX4 = lX & 0x40000000;
            var lY4 = lY & 0x40000000;
            var lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);

            if (lX4 & lY4) {
              return lResult ^ 0x80000000 ^ lX8 ^ lY8;
            }

            if (lX4 | lY4) {
              if (lResult & 0x40000000) {
                return lResult ^ 0xC0000000 ^ lX8 ^ lY8;
              } else {
                return lResult ^ 0x40000000 ^ lX8 ^ lY8;
              }
            } else {
              return lResult ^ lX8 ^ lY8;
            }
          }

          function doF(x, y, z) {
            return x & y | ~x & z;
          }

          function doG(x, y, z) {
            return x & z | y & ~z;
          }

          function doH(x, y, z) {
            return x ^ y ^ z;
          }

          function doI(x, y, z) {
            return y ^ (x | ~z);
          }

          function doFF(a, b, c, d, x, s, ac) {
            a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));
            return addUnsigned(rotateLeft(a, s), b);
          }

          function doGG(a, b, c, d, x, s, ac) {
            a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));
            return addUnsigned(rotateLeft(a, s), b);
          }

          function doHH(a, b, c, d, x, s, ac) {
            a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));
            return addUnsigned(rotateLeft(a, s), b);
          }

          function doII(a, b, c, d, x, s, ac) {
            a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));
            return addUnsigned(rotateLeft(a, s), b);
          }

          function convertToWordArray(str) {
            var lWordCount;
            var lMessageLength = str.length;
            var lNumberOfWords_temp1 = lMessageLength + 8;
            var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;
            var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
            var lWordArray = new Array(lNumberOfWords - 1);
            var lBytePosition = 0;
            var lByteCount = 0;

            while (lByteCount < lMessageLength) {
              lWordCount = (lByteCount - lByteCount % 4) / 4;
              lBytePosition = lByteCount % 4 * 8;
              lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition;
              lByteCount++;
            }

            lWordCount = (lByteCount - lByteCount % 4) / 4;
            lBytePosition = lByteCount % 4 * 8;
            lWordArray[lWordCount] = lWordArray[lWordCount] | 0x80 << lBytePosition;
            lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
            lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
            return lWordArray;
          }

          function wordToHex(lValue) {
            var wordToHexValue = '',
              wordToHexValue_temp = '',
              lByte,
              lCount;

            for (lCount = 0; lCount <= 3; lCount++) {
              lByte = lValue >>> lCount * 8 & 255;
              wordToHexValue_temp = "0".concat(lByte.toString(16));
              wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
            }

            return wordToHexValue;
          }

          function utf8Encode(str) {
            str = str.replace(/\r\n/g, '\n');
            var utftext = '';

            for (var n = 0; n < str.length; n++) {
              var _c = str.charCodeAt(n);

              if (_c < 128) {
                utftext += String.fromCharCode(_c);
              } else if (_c > 127 && _c < 2048) {
                utftext += String.fromCharCode(_c >> 6 | 192);
                utftext += String.fromCharCode(_c & 63 | 128);
              } else {
                utftext += String.fromCharCode(_c >> 12 | 224);
                utftext += String.fromCharCode(_c >> 6 & 63 | 128);
                utftext += String.fromCharCode(_c & 63 | 128);
              }
            }

            return utftext;
          }

          var x = [];
          var k, AA, BB, CC, DD, a, b, c, d;
          var S11 = 7,
            S12 = 12,
            S13 = 17,
            S14 = 22;
          var S21 = 5,
            S22 = 9,
            S23 = 14,
            S24 = 20;
          var S31 = 4,
            S32 = 11,
            S33 = 16,
            S34 = 23;
          var S41 = 6,
            S42 = 10,
            S43 = 15,
            S44 = 21;
          string = utf8Encode(string);
          x = convertToWordArray(string);
          a = 0x67452301;
          b = 0xEFCDAB89;
          c = 0x98BADCFE;
          d = 0x10325476;

          for (k = 0; k < x.length; k += 16) {
            AA = a;
            BB = b;
            CC = c;
            DD = d;
            a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
            d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
            c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);
            b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
            a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
            d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
            c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);
            b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);
            a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);
            d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
            c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
            b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
            a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);
            d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);
            c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);
            b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);
            a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
            d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);
            c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
            b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
            a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
            d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);
            c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
            b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
            a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
            d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
            c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
            b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
            a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
            d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
            c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
            b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
            a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
            d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);
            c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
            b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
            a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
            d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
            c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
            b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
            a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
            d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
            c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
            b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);
            a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
            d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
            c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
            b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
            a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);
            d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);
            c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
            b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);
            a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);
            d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
            c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
            b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);
            a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
            d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
            c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);
            b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
            a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);
            d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
            c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
            b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);
            a = addUnsigned(a, AA);
            b = addUnsigned(b, BB);
            c = addUnsigned(c, CC);
            d = addUnsigned(d, DD);
          }

          var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
          return temp.toLowerCase();
        };

        exports.closeMediaStream = function (stream) {
          if (!stream) {
            return;
          } // Latest spec states that MediaStream has no stop() method and instead must
          // call stop() on every MediaStreamTrack.


          try {
            var tracks;

            if (stream.getTracks) {
              tracks = stream.getTracks();

              var _iterator = _createForOfIteratorHelper(tracks),
                _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var track = _step.value;
                  track.stop();
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            } else {
              tracks = stream.getAudioTracks();

              var _iterator2 = _createForOfIteratorHelper(tracks),
                _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _track = _step2.value;

                  _track.stop();
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              tracks = stream.getVideoTracks();

              var _iterator3 = _createForOfIteratorHelper(tracks),
                _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var _track2 = _step3.value;

                  _track2.stop();
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          } catch (error) {
            // Deprecated by the spec, but still in use.
            // NOTE: In Temasys IE plugin stream.stop is a callable 'object'.
            if (typeof stream.stop === 'function' || _typeof(stream.stop) === 'object') {
              stream.stop();
            }
          }
        };

        exports.cloneArray = function (array) {
          return array && array.slice() || [];
        };

        exports.cloneObject = function (obj) {
          var fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return obj && Object.assign({}, obj) || fallback;
        };

        /***/
      }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var JsSIP_C = __webpack_require__(6);

        var Utils = __webpack_require__(8);

        var Grammar = __webpack_require__(10);
        /**
         * -param {String} [scheme]
         * -param {String} [user]
         * -param {String} host
         * -param {String} [port]
         * -param {Object} [parameters]
         * -param {Object} [headers]
         *
         */


        module.exports = /*#__PURE__*/function () {
          _createClass(URI, null, [{
            key: "parse",

            /**
              * Parse the given string and returns a JsSIP.URI instance or undefined if
              * it is an invalid URI.
              */
            value: function parse(uri) {
              uri = Grammar.parse(uri, 'SIP_URI');

              if (uri !== -1) {
                return uri;
              } else {
                return undefined;
              }
            }
          }]);

          function URI(scheme, user, host, port) {
            var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
            var headers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

            _classCallCheck(this, URI);

            // Checks.
            if (!host) {
              throw new TypeError('missing or invalid "host" parameter');
            } // Initialize parameters.


            this._parameters = {};
            this._headers = {};
            this._scheme = scheme || JsSIP_C.SIP;
            this._user = user;
            this._host = host;
            this._port = port;

            for (var param in parameters) {
              if (Object.prototype.hasOwnProperty.call(parameters, param)) {
                this.setParam(param, parameters[param]);
              }
            }

            for (var header in headers) {
              if (Object.prototype.hasOwnProperty.call(headers, header)) {
                this.setHeader(header, headers[header]);
              }
            }
          }

          _createClass(URI, [{
            key: "setParam",
            value: function setParam(key, value) {
              if (key) {
                this._parameters[key.toLowerCase()] = typeof value === 'undefined' || value === null ? null : value.toString();
              }
            }
          }, {
            key: "getParam",
            value: function getParam(key) {
              if (key) {
                return this._parameters[key.toLowerCase()];
              }
            }
          }, {
            key: "hasParam",
            value: function hasParam(key) {
              if (key) {
                return this._parameters.hasOwnProperty(key.toLowerCase()) && true || false;
              }
            }
          }, {
            key: "deleteParam",
            value: function deleteParam(parameter) {
              parameter = parameter.toLowerCase();

              if (this._parameters.hasOwnProperty(parameter)) {
                var value = this._parameters[parameter];
                delete this._parameters[parameter];
                return value;
              }
            }
          }, {
            key: "clearParams",
            value: function clearParams() {
              this._parameters = {};
            }
          }, {
            key: "setHeader",
            value: function setHeader(name, value) {
              this._headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];
            }
          }, {
            key: "getHeader",
            value: function getHeader(name) {
              if (name) {
                return this._headers[Utils.headerize(name)];
              }
            }
          }, {
            key: "hasHeader",
            value: function hasHeader(name) {
              if (name) {
                return this._headers.hasOwnProperty(Utils.headerize(name)) && true || false;
              }
            }
          }, {
            key: "deleteHeader",
            value: function deleteHeader(header) {
              header = Utils.headerize(header);

              if (this._headers.hasOwnProperty(header)) {
                var value = this._headers[header];
                delete this._headers[header];
                return value;
              }
            }
          }, {
            key: "clearHeaders",
            value: function clearHeaders() {
              this._headers = {};
            }
          }, {
            key: "clone",
            value: function clone() {
              return new URI(this._scheme, this._user, this._host, this._port, JSON.parse(JSON.stringify(this._parameters)), JSON.parse(JSON.stringify(this._headers)));
            }
          }, {
            key: "toString",
            value: function toString() {
              var headers = [];
              var uri = "".concat(this._scheme, ":");

              if (this._user) {
                uri += "".concat(Utils.escapeUser(this._user), "@");
              }

              uri += this._host;

              if (this._port || this._port === 0) {
                uri += ":".concat(this._port);
              }

              for (var parameter in this._parameters) {
                if (Object.prototype.hasOwnProperty.call(this._parameters, parameter)) {
                  uri += ";".concat(parameter);

                  if (this._parameters[parameter] !== null) {
                    uri += "=".concat(this._parameters[parameter]);
                  }
                }
              }

              for (var header in this._headers) {
                if (Object.prototype.hasOwnProperty.call(this._headers, header)) {
                  var _iterator = _createForOfIteratorHelper(this._headers[header]),
                    _step;

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done;) {
                      var item = _step.value;
                      headers.push("".concat(header, "=").concat(item));
                    }
                  } catch (err) {
                    _iterator.e(err);
                  } finally {
                    _iterator.f();
                  }
                }
              }

              if (headers.length > 0) {
                uri += "?".concat(headers.join('&'));
              }

              return uri;
            }
          }, {
            key: "toAor",
            value: function toAor(show_port) {
              var aor = "".concat(this._scheme, ":");

              if (this._user) {
                aor += "".concat(Utils.escapeUser(this._user), "@");
              }

              aor += this._host;

              if (show_port && (this._port || this._port === 0)) {
                aor += ":".concat(this._port);
              }

              return aor;
            }
          }, {
            key: "scheme",
            get: function get() {
              return this._scheme;
            },
            set: function set(value) {
              this._scheme = value.toLowerCase();
            }
          }, {
            key: "user",
            get: function get() {
              return this._user;
            },
            set: function set(value) {
              this._user = value;
            }
          }, {
            key: "host",
            get: function get() {
              return this._host;
            },
            set: function set(value) {
              this._host = value.toLowerCase();
            }
          }, {
            key: "port",
            get: function get() {
              return this._port;
            },
            set: function set(value) {
              this._port = value === 0 ? value : parseInt(value, 10) || null;
            }
          }]);

          return URI;
        }();

        /***/
      }),
/* 10 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        module.exports = function () {
          /*
           * Generated by PEG.js 0.7.0.
           *
           * http://pegjs.majda.cz/
           */
          function quote(s) {
            /*
             * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
             * string literal except for the closing quote character, backslash,
             * carriage return, line separator, paragraph separator, and line feed.
             * Any character may appear in the form of an escape sequence.
             *
             * For portability, we also escape escape all control and non-ASCII
             * characters. Note that "\0" and "\v" escape sequences are not used
             * because JSHint does not like the first and IE the second.
             */
            return '"' + s.replace(/\\/g, '\\\\') // backslash
              .replace(/"/g, '\\"') // closing quote character
              .replace(/\x08/g, '\\b') // backspace
              .replace(/\t/g, '\\t') // horizontal tab
              .replace(/\n/g, '\\n') // line feed
              .replace(/\f/g, '\\f') // form feed
              .replace(/\r/g, '\\r') // carriage return
              .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape) + '"';
          }

          var result = {
            /*
             * Parses the input with a generated parser. If the parsing is successfull,
             * returns a value explicitly or implicitly specified by the grammar from
             * which the parser was generated (see |PEG.buildParser|). If the parsing is
             * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
             */
            parse: function parse(input, startRule) {
              var parseFunctions = {
                "CRLF": parse_CRLF,
                "DIGIT": parse_DIGIT,
                "ALPHA": parse_ALPHA,
                "HEXDIG": parse_HEXDIG,
                "WSP": parse_WSP,
                "OCTET": parse_OCTET,
                "DQUOTE": parse_DQUOTE,
                "SP": parse_SP,
                "HTAB": parse_HTAB,
                "alphanum": parse_alphanum,
                "reserved": parse_reserved,
                "unreserved": parse_unreserved,
                "mark": parse_mark,
                "escaped": parse_escaped,
                "LWS": parse_LWS,
                "SWS": parse_SWS,
                "HCOLON": parse_HCOLON,
                "TEXT_UTF8_TRIM": parse_TEXT_UTF8_TRIM,
                "TEXT_UTF8char": parse_TEXT_UTF8char,
                "UTF8_NONASCII": parse_UTF8_NONASCII,
                "UTF8_CONT": parse_UTF8_CONT,
                "LHEX": parse_LHEX,
                "token": parse_token,
                "token_nodot": parse_token_nodot,
                "separators": parse_separators,
                "word": parse_word,
                "STAR": parse_STAR,
                "SLASH": parse_SLASH,
                "EQUAL": parse_EQUAL,
                "LPAREN": parse_LPAREN,
                "RPAREN": parse_RPAREN,
                "RAQUOT": parse_RAQUOT,
                "LAQUOT": parse_LAQUOT,
                "COMMA": parse_COMMA,
                "SEMI": parse_SEMI,
                "COLON": parse_COLON,
                "LDQUOT": parse_LDQUOT,
                "RDQUOT": parse_RDQUOT,
                "comment": parse_comment,
                "ctext": parse_ctext,
                "quoted_string": parse_quoted_string,
                "quoted_string_clean": parse_quoted_string_clean,
                "qdtext": parse_qdtext,
                "quoted_pair": parse_quoted_pair,
                "SIP_URI_noparams": parse_SIP_URI_noparams,
                "SIP_URI": parse_SIP_URI,
                "uri_scheme": parse_uri_scheme,
                "uri_scheme_sips": parse_uri_scheme_sips,
                "uri_scheme_sip": parse_uri_scheme_sip,
                "userinfo": parse_userinfo,
                "user": parse_user,
                "user_unreserved": parse_user_unreserved,
                "password": parse_password,
                "hostport": parse_hostport,
                "host": parse_host,
                "hostname": parse_hostname,
                "domainlabel": parse_domainlabel,
                "toplabel": parse_toplabel,
                "IPv6reference": parse_IPv6reference,
                "IPv6address": parse_IPv6address,
                "h16": parse_h16,
                "ls32": parse_ls32,
                "IPv4address": parse_IPv4address,
                "dec_octet": parse_dec_octet,
                "port": parse_port,
                "uri_parameters": parse_uri_parameters,
                "uri_parameter": parse_uri_parameter,
                "transport_param": parse_transport_param,
                "user_param": parse_user_param,
                "method_param": parse_method_param,
                "ttl_param": parse_ttl_param,
                "maddr_param": parse_maddr_param,
                "lr_param": parse_lr_param,
                "other_param": parse_other_param,
                "pname": parse_pname,
                "pvalue": parse_pvalue,
                "paramchar": parse_paramchar,
                "param_unreserved": parse_param_unreserved,
                "headers": parse_headers,
                "header": parse_header,
                "hname": parse_hname,
                "hvalue": parse_hvalue,
                "hnv_unreserved": parse_hnv_unreserved,
                "Request_Response": parse_Request_Response,
                "Request_Line": parse_Request_Line,
                "Request_URI": parse_Request_URI,
                "absoluteURI": parse_absoluteURI,
                "hier_part": parse_hier_part,
                "net_path": parse_net_path,
                "abs_path": parse_abs_path,
                "opaque_part": parse_opaque_part,
                "uric": parse_uric,
                "uric_no_slash": parse_uric_no_slash,
                "path_segments": parse_path_segments,
                "segment": parse_segment,
                "param": parse_param,
                "pchar": parse_pchar,
                "scheme": parse_scheme,
                "authority": parse_authority,
                "srvr": parse_srvr,
                "reg_name": parse_reg_name,
                "query": parse_query,
                "SIP_Version": parse_SIP_Version,
                "INVITEm": parse_INVITEm,
                "ACKm": parse_ACKm,
                "OPTIONSm": parse_OPTIONSm,
                "BYEm": parse_BYEm,
                "CANCELm": parse_CANCELm,
                "REGISTERm": parse_REGISTERm,
                "SUBSCRIBEm": parse_SUBSCRIBEm,
                "NOTIFYm": parse_NOTIFYm,
                "REFERm": parse_REFERm,
                "Method": parse_Method,
                "Status_Line": parse_Status_Line,
                "Status_Code": parse_Status_Code,
                "extension_code": parse_extension_code,
                "Reason_Phrase": parse_Reason_Phrase,
                "Allow_Events": parse_Allow_Events,
                "Call_ID": parse_Call_ID,
                "Contact": parse_Contact,
                "contact_param": parse_contact_param,
                "name_addr": parse_name_addr,
                "display_name": parse_display_name,
                "contact_params": parse_contact_params,
                "c_p_q": parse_c_p_q,
                "c_p_expires": parse_c_p_expires,
                "delta_seconds": parse_delta_seconds,
                "qvalue": parse_qvalue,
                "generic_param": parse_generic_param,
                "gen_value": parse_gen_value,
                "Content_Disposition": parse_Content_Disposition,
                "disp_type": parse_disp_type,
                "disp_param": parse_disp_param,
                "handling_param": parse_handling_param,
                "Content_Encoding": parse_Content_Encoding,
                "Content_Length": parse_Content_Length,
                "Content_Type": parse_Content_Type,
                "media_type": parse_media_type,
                "m_type": parse_m_type,
                "discrete_type": parse_discrete_type,
                "composite_type": parse_composite_type,
                "extension_token": parse_extension_token,
                "x_token": parse_x_token,
                "m_subtype": parse_m_subtype,
                "m_parameter": parse_m_parameter,
                "m_value": parse_m_value,
                "CSeq": parse_CSeq,
                "CSeq_value": parse_CSeq_value,
                "Expires": parse_Expires,
                "Event": parse_Event,
                "event_type": parse_event_type,
                "From": parse_From,
                "from_param": parse_from_param,
                "tag_param": parse_tag_param,
                "Max_Forwards": parse_Max_Forwards,
                "Min_Expires": parse_Min_Expires,
                "Name_Addr_Header": parse_Name_Addr_Header,
                "Proxy_Authenticate": parse_Proxy_Authenticate,
                "challenge": parse_challenge,
                "other_challenge": parse_other_challenge,
                "auth_param": parse_auth_param,
                "digest_cln": parse_digest_cln,
                "realm": parse_realm,
                "realm_value": parse_realm_value,
                "domain": parse_domain,
                "URI": parse_URI,
                "nonce": parse_nonce,
                "nonce_value": parse_nonce_value,
                "opaque": parse_opaque,
                "stale": parse_stale,
                "algorithm": parse_algorithm,
                "qop_options": parse_qop_options,
                "qop_value": parse_qop_value,
                "Proxy_Require": parse_Proxy_Require,
                "Record_Route": parse_Record_Route,
                "rec_route": parse_rec_route,
                "Reason": parse_Reason,
                "reason_param": parse_reason_param,
                "reason_cause": parse_reason_cause,
                "Require": parse_Require,
                "Route": parse_Route,
                "route_param": parse_route_param,
                "Subscription_State": parse_Subscription_State,
                "substate_value": parse_substate_value,
                "subexp_params": parse_subexp_params,
                "event_reason_value": parse_event_reason_value,
                "Subject": parse_Subject,
                "Supported": parse_Supported,
                "To": parse_To,
                "to_param": parse_to_param,
                "Via": parse_Via,
                "via_param": parse_via_param,
                "via_params": parse_via_params,
                "via_ttl": parse_via_ttl,
                "via_maddr": parse_via_maddr,
                "via_received": parse_via_received,
                "via_branch": parse_via_branch,
                "response_port": parse_response_port,
                "rport": parse_rport,
                "sent_protocol": parse_sent_protocol,
                "protocol_name": parse_protocol_name,
                "transport": parse_transport,
                "sent_by": parse_sent_by,
                "via_host": parse_via_host,
                "via_port": parse_via_port,
                "ttl": parse_ttl,
                "WWW_Authenticate": parse_WWW_Authenticate,
                "Session_Expires": parse_Session_Expires,
                "s_e_expires": parse_s_e_expires,
                "s_e_params": parse_s_e_params,
                "s_e_refresher": parse_s_e_refresher,
                "extension_header": parse_extension_header,
                "header_value": parse_header_value,
                "message_body": parse_message_body,
                "uuid_URI": parse_uuid_URI,
                "uuid": parse_uuid,
                "hex4": parse_hex4,
                "hex8": parse_hex8,
                "hex12": parse_hex12,
                "Refer_To": parse_Refer_To,
                "Replaces": parse_Replaces,
                "call_id": parse_call_id,
                "replaces_param": parse_replaces_param,
                "to_tag": parse_to_tag,
                "from_tag": parse_from_tag,
                "early_flag": parse_early_flag
              };

              if (startRule !== undefined) {
                if (parseFunctions[startRule] === undefined) {
                  throw new Error("Invalid rule name: " + quote(startRule) + ".");
                }
              } else {
                startRule = "CRLF";
              }

              var pos = 0;
              var reportFailures = 0;
              var rightmostFailuresPos = 0;
              var rightmostFailuresExpected = [];

              function padLeft(input, padding, length) {
                var result = input;
                var padLength = length - input.length;

                for (var i = 0; i < padLength; i++) {
                  result = padding + result;
                }

                return result;
              }

              function escape(ch) {
                var charCode = ch.charCodeAt(0);
                var escapeChar;
                var length;

                if (charCode <= 0xFF) {
                  escapeChar = 'x';
                  length = 2;
                } else {
                  escapeChar = 'u';
                  length = 4;
                }

                return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
              }

              function matchFailed(failure) {
                if (pos < rightmostFailuresPos) {
                  return;
                }

                if (pos > rightmostFailuresPos) {
                  rightmostFailuresPos = pos;
                  rightmostFailuresExpected = [];
                }

                rightmostFailuresExpected.push(failure);
              }

              function parse_CRLF() {
                var result0;

                if (input.substr(pos, 2) === "\r\n") {
                  result0 = "\r\n";
                  pos += 2;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"\\r\\n\"");
                  }
                }

                return result0;
              }

              function parse_DIGIT() {
                var result0;

                if (/^[0-9]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[0-9]");
                  }
                }

                return result0;
              }

              function parse_ALPHA() {
                var result0;

                if (/^[a-zA-Z]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[a-zA-Z]");
                  }
                }

                return result0;
              }

              function parse_HEXDIG() {
                var result0;

                if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[0-9a-fA-F]");
                  }
                }

                return result0;
              }

              function parse_WSP() {
                var result0;
                result0 = parse_SP();

                if (result0 === null) {
                  result0 = parse_HTAB();
                }

                return result0;
              }

              function parse_OCTET() {
                var result0;

                if (/^[\0-\xFF]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[\\0-\\xFF]");
                  }
                }

                return result0;
              }

              function parse_DQUOTE() {
                var result0;

                if (/^["]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[\"]");
                  }
                }

                return result0;
              }

              function parse_SP() {
                var result0;

                if (input.charCodeAt(pos) === 32) {
                  result0 = " ";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\" \"");
                  }
                }

                return result0;
              }

              function parse_HTAB() {
                var result0;

                if (input.charCodeAt(pos) === 9) {
                  result0 = "\t";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"\\t\"");
                  }
                }

                return result0;
              }

              function parse_alphanum() {
                var result0;

                if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[a-zA-Z0-9]");
                  }
                }

                return result0;
              }

              function parse_reserved() {
                var result0;

                if (input.charCodeAt(pos) === 59) {
                  result0 = ";";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 47) {
                    result0 = "/";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"/\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 63) {
                      result0 = "?";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"?\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result0 = ":";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 64) {
                          result0 = "@";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"@\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 38) {
                            result0 = "&";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"&\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result0 = "=";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }

                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result0 = "+";
                                pos++;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }

                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 36) {
                                  result0 = "$";
                                  pos++;
                                } else {
                                  result0 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"$\"");
                                  }
                                }

                                if (result0 === null) {
                                  if (input.charCodeAt(pos) === 44) {
                                    result0 = ",";
                                    pos++;
                                  } else {
                                    result0 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\",\"");
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_unreserved() {
                var result0;
                result0 = parse_alphanum();

                if (result0 === null) {
                  result0 = parse_mark();
                }

                return result0;
              }

              function parse_mark() {
                var result0;

                if (input.charCodeAt(pos) === 45) {
                  result0 = "-";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 95) {
                    result0 = "_";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"_\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result0 = ".";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 33) {
                        result0 = "!";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"!\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 126) {
                          result0 = "~";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"~\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 42) {
                            result0 = "*";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"*\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              result0 = "'";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"'\"");
                              }
                            }

                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 40) {
                                result0 = "(";
                                pos++;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"(\"");
                                }
                              }

                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 41) {
                                  result0 = ")";
                                  pos++;
                                } else {
                                  result0 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_escaped() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.charCodeAt(pos) === 37) {
                  result0 = "%";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_HEXDIG();

                  if (result1 !== null) {
                    result2 = parse_HEXDIG();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, escaped) {
                    return escaped.join('');
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_LWS() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                pos2 = pos;
                result0 = [];
                result1 = parse_WSP();

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_WSP();
                }

                if (result0 !== null) {
                  result1 = parse_CRLF();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos2;
                  }
                } else {
                  result0 = null;
                  pos = pos2;
                }

                result0 = result0 !== null ? result0 : "";

                if (result0 !== null) {
                  result2 = parse_WSP();

                  if (result2 !== null) {
                    result1 = [];

                    while (result2 !== null) {
                      result1.push(result2);
                      result2 = parse_WSP();
                    }
                  } else {
                    result1 = null;
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return " ";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_SWS() {
                var result0;
                result0 = parse_LWS();
                result0 = result0 !== null ? result0 : "";
                return result0;
              }

              function parse_HCOLON() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = [];
                result1 = parse_SP();

                if (result1 === null) {
                  result1 = parse_HTAB();
                }

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_SP();

                  if (result1 === null) {
                    result1 = parse_HTAB();
                  }
                }

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return ':';
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_TEXT_UTF8_TRIM() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result1 = parse_TEXT_UTF8char();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_TEXT_UTF8char();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = [];
                  result3 = parse_LWS();

                  while (result3 !== null) {
                    result2.push(result3);
                    result3 = parse_LWS();
                  }

                  if (result2 !== null) {
                    result3 = parse_TEXT_UTF8char();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = [];
                    result3 = parse_LWS();

                    while (result3 !== null) {
                      result2.push(result3);
                      result3 = parse_LWS();
                    }

                    if (result2 !== null) {
                      result3 = parse_TEXT_UTF8char();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_TEXT_UTF8char() {
                var result0;

                if (/^[!-~]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[!-~]");
                  }
                }

                if (result0 === null) {
                  result0 = parse_UTF8_NONASCII();
                }

                return result0;
              }

              function parse_UTF8_NONASCII() {
                var result0;

                if (/^[\x80-\uFFFF]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[\\x80-\\uFFFF]");
                  }
                }

                return result0;
              }

              function parse_UTF8_CONT() {
                var result0;

                if (/^[\x80-\xBF]/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[\\x80-\\xBF]");
                  }
                }

                return result0;
              }

              function parse_LHEX() {
                var result0;
                result0 = parse_DIGIT();

                if (result0 === null) {
                  if (/^[a-f]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("[a-f]");
                    }
                  }
                }

                return result0;
              }

              function parse_token() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_alphanum();

                if (result1 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result1 = "-";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }

                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result1 = ".";
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 33) {
                        result1 = "!";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"!\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 37) {
                          result1 = "%";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"%\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 42) {
                            result1 = "*";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"*\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 95) {
                              result1 = "_";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"_\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result1 = "+";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 96) {
                                  result1 = "`";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"`\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 39) {
                                    result1 = "'";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"'\"");
                                    }
                                  }

                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 126) {
                                      result1 = "~";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"~\"");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_alphanum();

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 45) {
                        result1 = "-";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 46) {
                          result1 = ".";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\".\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 33) {
                            result1 = "!";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"!\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 37) {
                              result1 = "%";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"%\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 42) {
                                result1 = "*";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"*\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 95) {
                                  result1 = "_";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"_\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 43) {
                                    result1 = "+";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"+\"");
                                    }
                                  }

                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 96) {
                                      result1 = "`";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"`\"");
                                      }
                                    }

                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 39) {
                                        result1 = "'";
                                        pos++;
                                      } else {
                                        result1 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"'\"");
                                        }
                                      }

                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 126) {
                                          result1 = "~";
                                          pos++;
                                        } else {
                                          result1 = null;

                                          if (reportFailures === 0) {
                                            matchFailed("\"~\"");
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_token_nodot() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_alphanum();

                if (result1 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result1 = "-";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }

                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 33) {
                      result1 = "!";
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"!\"");
                      }
                    }

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 37) {
                        result1 = "%";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"%\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 42) {
                          result1 = "*";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"*\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 95) {
                            result1 = "_";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"_\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 43) {
                              result1 = "+";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"+\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 96) {
                                result1 = "`";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"`\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 39) {
                                  result1 = "'";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"'\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 126) {
                                    result1 = "~";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"~\"");
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_alphanum();

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 45) {
                        result1 = "-";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 33) {
                          result1 = "!";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"!\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 37) {
                            result1 = "%";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"%\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 42) {
                              result1 = "*";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"*\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 95) {
                                result1 = "_";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"_\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 43) {
                                  result1 = "+";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"+\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 96) {
                                    result1 = "`";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"`\"");
                                    }
                                  }

                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 39) {
                                      result1 = "'";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"'\"");
                                      }
                                    }

                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 126) {
                                        result1 = "~";
                                        pos++;
                                      } else {
                                        result1 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"~\"");
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_separators() {
                var result0;

                if (input.charCodeAt(pos) === 40) {
                  result0 = "(";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"(\"");
                  }
                }

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 41) {
                    result0 = ")";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 60) {
                      result0 = "<";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"<\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 62) {
                        result0 = ">";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\">\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 64) {
                          result0 = "@";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"@\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 44) {
                            result0 = ",";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 59) {
                              result0 = ";";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\";\"");
                              }
                            }

                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 58) {
                                result0 = ":";
                                pos++;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }

                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 92) {
                                  result0 = "\\";
                                  pos++;
                                } else {
                                  result0 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"\\\\\"");
                                  }
                                }

                                if (result0 === null) {
                                  result0 = parse_DQUOTE();

                                  if (result0 === null) {
                                    if (input.charCodeAt(pos) === 47) {
                                      result0 = "/";
                                      pos++;
                                    } else {
                                      result0 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"/\"");
                                      }
                                    }

                                    if (result0 === null) {
                                      if (input.charCodeAt(pos) === 91) {
                                        result0 = "[";
                                        pos++;
                                      } else {
                                        result0 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"[\"");
                                        }
                                      }

                                      if (result0 === null) {
                                        if (input.charCodeAt(pos) === 93) {
                                          result0 = "]";
                                          pos++;
                                        } else {
                                          result0 = null;

                                          if (reportFailures === 0) {
                                            matchFailed("\"]\"");
                                          }
                                        }

                                        if (result0 === null) {
                                          if (input.charCodeAt(pos) === 63) {
                                            result0 = "?";
                                            pos++;
                                          } else {
                                            result0 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\"?\"");
                                            }
                                          }

                                          if (result0 === null) {
                                            if (input.charCodeAt(pos) === 61) {
                                              result0 = "=";
                                              pos++;
                                            } else {
                                              result0 = null;

                                              if (reportFailures === 0) {
                                                matchFailed("\"=\"");
                                              }
                                            }

                                            if (result0 === null) {
                                              if (input.charCodeAt(pos) === 123) {
                                                result0 = "{";
                                                pos++;
                                              } else {
                                                result0 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\"{\"");
                                                }
                                              }

                                              if (result0 === null) {
                                                if (input.charCodeAt(pos) === 125) {
                                                  result0 = "}";
                                                  pos++;
                                                } else {
                                                  result0 = null;

                                                  if (reportFailures === 0) {
                                                    matchFailed("\"}\"");
                                                  }
                                                }

                                                if (result0 === null) {
                                                  result0 = parse_SP();

                                                  if (result0 === null) {
                                                    result0 = parse_HTAB();
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_word() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_alphanum();

                if (result1 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result1 = "-";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }

                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result1 = ".";
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 33) {
                        result1 = "!";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"!\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 37) {
                          result1 = "%";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"%\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 42) {
                            result1 = "*";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"*\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 95) {
                              result1 = "_";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"_\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result1 = "+";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 96) {
                                  result1 = "`";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"`\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 39) {
                                    result1 = "'";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"'\"");
                                    }
                                  }

                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 126) {
                                      result1 = "~";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"~\"");
                                      }
                                    }

                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 40) {
                                        result1 = "(";
                                        pos++;
                                      } else {
                                        result1 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"(\"");
                                        }
                                      }

                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 41) {
                                          result1 = ")";
                                          pos++;
                                        } else {
                                          result1 = null;

                                          if (reportFailures === 0) {
                                            matchFailed("\")\"");
                                          }
                                        }

                                        if (result1 === null) {
                                          if (input.charCodeAt(pos) === 60) {
                                            result1 = "<";
                                            pos++;
                                          } else {
                                            result1 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\"<\"");
                                            }
                                          }

                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 62) {
                                              result1 = ">";
                                              pos++;
                                            } else {
                                              result1 = null;

                                              if (reportFailures === 0) {
                                                matchFailed("\">\"");
                                              }
                                            }

                                            if (result1 === null) {
                                              if (input.charCodeAt(pos) === 58) {
                                                result1 = ":";
                                                pos++;
                                              } else {
                                                result1 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 92) {
                                                  result1 = "\\";
                                                  pos++;
                                                } else {
                                                  result1 = null;

                                                  if (reportFailures === 0) {
                                                    matchFailed("\"\\\\\"");
                                                  }
                                                }

                                                if (result1 === null) {
                                                  result1 = parse_DQUOTE();

                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 47) {
                                                      result1 = "/";
                                                      pos++;
                                                    } else {
                                                      result1 = null;

                                                      if (reportFailures === 0) {
                                                        matchFailed("\"/\"");
                                                      }
                                                    }

                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 91) {
                                                        result1 = "[";
                                                        pos++;
                                                      } else {
                                                        result1 = null;

                                                        if (reportFailures === 0) {
                                                          matchFailed("\"[\"");
                                                        }
                                                      }

                                                      if (result1 === null) {
                                                        if (input.charCodeAt(pos) === 93) {
                                                          result1 = "]";
                                                          pos++;
                                                        } else {
                                                          result1 = null;

                                                          if (reportFailures === 0) {
                                                            matchFailed("\"]\"");
                                                          }
                                                        }

                                                        if (result1 === null) {
                                                          if (input.charCodeAt(pos) === 63) {
                                                            result1 = "?";
                                                            pos++;
                                                          } else {
                                                            result1 = null;

                                                            if (reportFailures === 0) {
                                                              matchFailed("\"?\"");
                                                            }
                                                          }

                                                          if (result1 === null) {
                                                            if (input.charCodeAt(pos) === 123) {
                                                              result1 = "{";
                                                              pos++;
                                                            } else {
                                                              result1 = null;

                                                              if (reportFailures === 0) {
                                                                matchFailed("\"{\"");
                                                              }
                                                            }

                                                            if (result1 === null) {
                                                              if (input.charCodeAt(pos) === 125) {
                                                                result1 = "}";
                                                                pos++;
                                                              } else {
                                                                result1 = null;

                                                                if (reportFailures === 0) {
                                                                  matchFailed("\"}\"");
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_alphanum();

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 45) {
                        result1 = "-";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 46) {
                          result1 = ".";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\".\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 33) {
                            result1 = "!";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"!\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 37) {
                              result1 = "%";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"%\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 42) {
                                result1 = "*";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"*\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 95) {
                                  result1 = "_";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"_\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 43) {
                                    result1 = "+";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"+\"");
                                    }
                                  }

                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 96) {
                                      result1 = "`";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"`\"");
                                      }
                                    }

                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 39) {
                                        result1 = "'";
                                        pos++;
                                      } else {
                                        result1 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"'\"");
                                        }
                                      }

                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 126) {
                                          result1 = "~";
                                          pos++;
                                        } else {
                                          result1 = null;

                                          if (reportFailures === 0) {
                                            matchFailed("\"~\"");
                                          }
                                        }

                                        if (result1 === null) {
                                          if (input.charCodeAt(pos) === 40) {
                                            result1 = "(";
                                            pos++;
                                          } else {
                                            result1 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\"(\"");
                                            }
                                          }

                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 41) {
                                              result1 = ")";
                                              pos++;
                                            } else {
                                              result1 = null;

                                              if (reportFailures === 0) {
                                                matchFailed("\")\"");
                                              }
                                            }

                                            if (result1 === null) {
                                              if (input.charCodeAt(pos) === 60) {
                                                result1 = "<";
                                                pos++;
                                              } else {
                                                result1 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\"<\"");
                                                }
                                              }

                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 62) {
                                                  result1 = ">";
                                                  pos++;
                                                } else {
                                                  result1 = null;

                                                  if (reportFailures === 0) {
                                                    matchFailed("\">\"");
                                                  }
                                                }

                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 58) {
                                                    result1 = ":";
                                                    pos++;
                                                  } else {
                                                    result1 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 92) {
                                                      result1 = "\\";
                                                      pos++;
                                                    } else {
                                                      result1 = null;

                                                      if (reportFailures === 0) {
                                                        matchFailed("\"\\\\\"");
                                                      }
                                                    }

                                                    if (result1 === null) {
                                                      result1 = parse_DQUOTE();

                                                      if (result1 === null) {
                                                        if (input.charCodeAt(pos) === 47) {
                                                          result1 = "/";
                                                          pos++;
                                                        } else {
                                                          result1 = null;

                                                          if (reportFailures === 0) {
                                                            matchFailed("\"/\"");
                                                          }
                                                        }

                                                        if (result1 === null) {
                                                          if (input.charCodeAt(pos) === 91) {
                                                            result1 = "[";
                                                            pos++;
                                                          } else {
                                                            result1 = null;

                                                            if (reportFailures === 0) {
                                                              matchFailed("\"[\"");
                                                            }
                                                          }

                                                          if (result1 === null) {
                                                            if (input.charCodeAt(pos) === 93) {
                                                              result1 = "]";
                                                              pos++;
                                                            } else {
                                                              result1 = null;

                                                              if (reportFailures === 0) {
                                                                matchFailed("\"]\"");
                                                              }
                                                            }

                                                            if (result1 === null) {
                                                              if (input.charCodeAt(pos) === 63) {
                                                                result1 = "?";
                                                                pos++;
                                                              } else {
                                                                result1 = null;

                                                                if (reportFailures === 0) {
                                                                  matchFailed("\"?\"");
                                                                }
                                                              }

                                                              if (result1 === null) {
                                                                if (input.charCodeAt(pos) === 123) {
                                                                  result1 = "{";
                                                                  pos++;
                                                                } else {
                                                                  result1 = null;

                                                                  if (reportFailures === 0) {
                                                                    matchFailed("\"{\"");
                                                                  }
                                                                }

                                                                if (result1 === null) {
                                                                  if (input.charCodeAt(pos) === 125) {
                                                                    result1 = "}";
                                                                    pos++;
                                                                  } else {
                                                                    result1 = null;

                                                                    if (reportFailures === 0) {
                                                                      matchFailed("\"}\"");
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_STAR() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "*";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_SLASH() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 47) {
                    result1 = "/";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"/\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "/";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_EQUAL() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    result1 = "=";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "=";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_LPAREN() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 40) {
                    result1 = "(";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"(\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "(";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_RPAREN() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result1 = ")";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return ")";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_RAQUOT() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.charCodeAt(pos) === 62) {
                  result0 = ">";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\">\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_SWS();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return ">";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_LAQUOT() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 60) {
                    result1 = "<";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"<\"");
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "<";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_COMMA() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    result1 = ",";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return ",";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_SEMI() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 59) {
                    result1 = ";";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return ";";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_COLON() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_SWS();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return ":";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_LDQUOT() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  result1 = parse_DQUOTE();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "\"";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_RDQUOT() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_DQUOTE();

                if (result0 !== null) {
                  result1 = parse_SWS();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return "\"";
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_comment() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_LPAREN();

                if (result0 !== null) {
                  result1 = [];
                  result2 = parse_ctext();

                  if (result2 === null) {
                    result2 = parse_quoted_pair();

                    if (result2 === null) {
                      result2 = parse_comment();
                    }
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    result2 = parse_ctext();

                    if (result2 === null) {
                      result2 = parse_quoted_pair();

                      if (result2 === null) {
                        result2 = parse_comment();
                      }
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_RPAREN();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_ctext() {
                var result0;

                if (/^[!-']/.test(input.charAt(pos))) {
                  result0 = input.charAt(pos);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("[!-']");
                  }
                }

                if (result0 === null) {
                  if (/^[*-[]/.test(input.charAt(pos))) {
                    result0 = input.charAt(pos);
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("[*-[]");
                    }
                  }

                  if (result0 === null) {
                    if (/^[\]-~]/.test(input.charAt(pos))) {
                      result0 = input.charAt(pos);
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("[\\]-~]");
                      }
                    }

                    if (result0 === null) {
                      result0 = parse_UTF8_NONASCII();

                      if (result0 === null) {
                        result0 = parse_LWS();
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_quoted_string() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  result1 = parse_DQUOTE();

                  if (result1 !== null) {
                    result2 = [];
                    result3 = parse_qdtext();

                    if (result3 === null) {
                      result3 = parse_quoted_pair();
                    }

                    while (result3 !== null) {
                      result2.push(result3);
                      result3 = parse_qdtext();

                      if (result3 === null) {
                        result3 = parse_quoted_pair();
                      }
                    }

                    if (result2 !== null) {
                      result3 = parse_DQUOTE();

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_quoted_string_clean() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SWS();

                if (result0 !== null) {
                  result1 = parse_DQUOTE();

                  if (result1 !== null) {
                    result2 = [];
                    result3 = parse_qdtext();

                    if (result3 === null) {
                      result3 = parse_quoted_pair();
                    }

                    while (result3 !== null) {
                      result2.push(result3);
                      result3 = parse_qdtext();

                      if (result3 === null) {
                        result3 = parse_quoted_pair();
                      }
                    }

                    if (result2 !== null) {
                      result3 = parse_DQUOTE();

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var trimmed = input.substring(pos, offset).trim();
                    return trimmed.substring(1, trimmed.length - 1) // remove outer quotes
                      .replace(/\\([\x00-\x09\x0b-\x0c\x0e-\x7f])/g, '$1');
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_qdtext() {
                var result0;
                result0 = parse_LWS();

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result0 = "!";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }

                  if (result0 === null) {
                    if (/^[#-[]/.test(input.charAt(pos))) {
                      result0 = input.charAt(pos);
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("[#-[]");
                      }
                    }

                    if (result0 === null) {
                      if (/^[\]-~]/.test(input.charAt(pos))) {
                        result0 = input.charAt(pos);
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("[\\]-~]");
                        }
                      }

                      if (result0 === null) {
                        result0 = parse_UTF8_NONASCII();
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_quoted_pair() {
                var result0, result1;
                var pos0;
                pos0 = pos;

                if (input.charCodeAt(pos) === 92) {
                  result0 = "\\";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"\\\\\"");
                  }
                }

                if (result0 !== null) {
                  if (/^[\0-\t]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("[\\0-\\t]");
                    }
                  }

                  if (result1 === null) {
                    if (/^[\x0B-\f]/.test(input.charAt(pos))) {
                      result1 = input.charAt(pos);
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("[\\x0B-\\f]");
                      }
                    }

                    if (result1 === null) {
                      if (/^[\x0E-]/.test(input.charAt(pos))) {
                        result1 = input.charAt(pos);
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("[\\x0E-]");
                        }
                      }
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_SIP_URI_noparams() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_uri_scheme();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_userinfo();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_hostport();

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    try {
                      data.uri = new URI(data.scheme, data.user, data.host, data.port);
                      delete data.scheme;
                      delete data.user;
                      delete data.host;
                      delete data.host_type;
                      delete data.port;
                    } catch (e) {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_SIP_URI() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_uri_scheme();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_userinfo();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_hostport();

                      if (result3 !== null) {
                        result4 = parse_uri_parameters();

                        if (result4 !== null) {
                          result5 = parse_headers();
                          result5 = result5 !== null ? result5 : "";

                          if (result5 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var header;

                    try {
                      data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);
                      delete data.scheme;
                      delete data.user;
                      delete data.host;
                      delete data.host_type;
                      delete data.port;
                      delete data.uri_params;

                      if (startRule === 'SIP_URI') {
                        data = data.uri;
                      }
                    } catch (e) {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_uri_scheme() {
                var result0;
                result0 = parse_uri_scheme_sips();

                if (result0 === null) {
                  result0 = parse_uri_scheme_sip();
                }

                return result0;
              }

              function parse_uri_scheme_sips() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 4).toLowerCase() === "sips") {
                  result0 = input.substr(pos, 4);
                  pos += 4;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"sips\"");
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset, scheme) {
                    data.scheme = scheme.toLowerCase();
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_uri_scheme_sip() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 3).toLowerCase() === "sip") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"sip\"");
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset, scheme) {
                    data.scheme = scheme.toLowerCase();
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_userinfo() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_user();

                if (result0 !== null) {
                  pos2 = pos;

                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_password();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 64) {
                      result2 = "@";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"@\"");
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.user = decodeURIComponent(input.substring(pos - 1, offset));
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_user() {
                var result0, result1;
                result1 = parse_unreserved();

                if (result1 === null) {
                  result1 = parse_escaped();

                  if (result1 === null) {
                    result1 = parse_user_unreserved();
                  }
                }

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_unreserved();

                    if (result1 === null) {
                      result1 = parse_escaped();

                      if (result1 === null) {
                        result1 = parse_user_unreserved();
                      }
                    }
                  }
                } else {
                  result0 = null;
                }

                return result0;
              }

              function parse_user_unreserved() {
                var result0;

                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result0 = "+";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 36) {
                        result0 = "$";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"$\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 59) {
                            result0 = ";";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\";\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 63) {
                              result0 = "?";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"?\"");
                              }
                            }

                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 47) {
                                result0 = "/";
                                pos++;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"/\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_password() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result0 = [];
                result1 = parse_unreserved();

                if (result1 === null) {
                  result1 = parse_escaped();

                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 38) {
                      result1 = "&";
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"&\"");
                      }
                    }

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 61) {
                        result1 = "=";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"=\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result1 = "+";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 36) {
                            result1 = "$";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"$\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 44) {
                              result1 = ",";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_unreserved();

                  if (result1 === null) {
                    result1 = parse_escaped();

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 38) {
                        result1 = "&";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"&\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 61) {
                          result1 = "=";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"=\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 36) {
                              result1 = "$";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"$\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 44) {
                                result1 = ",";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\",\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.password = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_hostport() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_host();

                if (result0 !== null) {
                  pos1 = pos;

                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_port();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos1;
                    }
                  } else {
                    result1 = null;
                    pos = pos1;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_host() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_hostname();

                if (result0 === null) {
                  result0 = parse_IPv4address();

                  if (result0 === null) {
                    result0 = parse_IPv6reference();
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.host = input.substring(pos, offset).toLowerCase();
                    return data.host;
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_hostname() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = [];
                pos2 = pos;
                result1 = parse_domainlabel();

                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result2 = ".";
                    pos++;
                  } else {
                    result2 = null;

                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }

                  if (result2 !== null) {
                    result1 = [result1, result2];
                  } else {
                    result1 = null;
                    pos = pos2;
                  }
                } else {
                  result1 = null;
                  pos = pos2;
                }

                while (result1 !== null) {
                  result0.push(result1);
                  pos2 = pos;
                  result1 = parse_domainlabel();

                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }
                }

                if (result0 !== null) {
                  result1 = parse_toplabel();

                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }

                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.host_type = 'domain';
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_domainlabel() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_alphanum();

                if (result0 !== null) {
                  result1 = [];
                  result2 = parse_alphanum();

                  if (result2 === null) {
                    if (input.charCodeAt(pos) === 45) {
                      result2 = "-";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"-\"");
                      }
                    }

                    if (result2 === null) {
                      if (input.charCodeAt(pos) === 95) {
                        result2 = "_";
                        pos++;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"_\"");
                        }
                      }
                    }
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    result2 = parse_alphanum();

                    if (result2 === null) {
                      if (input.charCodeAt(pos) === 45) {
                        result2 = "-";
                        pos++;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }

                      if (result2 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result2 = "_";
                          pos++;
                        } else {
                          result2 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                      }
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_toplabel() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_ALPHA();

                if (result0 !== null) {
                  result1 = [];
                  result2 = parse_alphanum();

                  if (result2 === null) {
                    if (input.charCodeAt(pos) === 45) {
                      result2 = "-";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"-\"");
                      }
                    }

                    if (result2 === null) {
                      if (input.charCodeAt(pos) === 95) {
                        result2 = "_";
                        pos++;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"_\"");
                        }
                      }
                    }
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    result2 = parse_alphanum();

                    if (result2 === null) {
                      if (input.charCodeAt(pos) === 45) {
                        result2 = "-";
                        pos++;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }

                      if (result2 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result2 = "_";
                          pos++;
                        } else {
                          result2 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                      }
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_IPv6reference() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.charCodeAt(pos) === 91) {
                  result0 = "[";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"[\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_IPv6address();

                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 93) {
                      result2 = "]";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"]\"");
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.host_type = 'IPv6';
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_IPv6address() {
                var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_h16();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_h16();

                    if (result2 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result3 = ":";
                        pos++;
                      } else {
                        result3 = null;

                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }

                      if (result3 !== null) {
                        result4 = parse_h16();

                        if (result4 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result5 = ":";
                            pos++;
                          } else {
                            result5 = null;

                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }

                          if (result5 !== null) {
                            result6 = parse_h16();

                            if (result6 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result7 = ":";
                                pos++;
                              } else {
                                result7 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }

                              if (result7 !== null) {
                                result8 = parse_h16();

                                if (result8 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result9 = ":";
                                    pos++;
                                  } else {
                                    result9 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }

                                  if (result9 !== null) {
                                    result10 = parse_h16();

                                    if (result10 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result11 = ":";
                                        pos++;
                                      } else {
                                        result11 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }

                                      if (result11 !== null) {
                                        result12 = parse_ls32();

                                        if (result12 !== null) {
                                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 === null) {
                  pos1 = pos;

                  if (input.substr(pos, 2) === "::") {
                    result0 = "::";
                    pos += 2;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"::\"");
                    }
                  }

                  if (result0 !== null) {
                    result1 = parse_h16();

                    if (result1 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result2 = ":";
                        pos++;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }

                      if (result2 !== null) {
                        result3 = parse_h16();

                        if (result3 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result4 = ":";
                            pos++;
                          } else {
                            result4 = null;

                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }

                          if (result4 !== null) {
                            result5 = parse_h16();

                            if (result5 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result6 = ":";
                                pos++;
                              } else {
                                result6 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }

                              if (result6 !== null) {
                                result7 = parse_h16();

                                if (result7 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result8 = ":";
                                    pos++;
                                  } else {
                                    result8 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }

                                  if (result8 !== null) {
                                    result9 = parse_h16();

                                    if (result9 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result10 = ":";
                                        pos++;
                                      } else {
                                        result10 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }

                                      if (result10 !== null) {
                                        result11 = parse_ls32();

                                        if (result11 !== null) {
                                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }

                  if (result0 === null) {
                    pos1 = pos;

                    if (input.substr(pos, 2) === "::") {
                      result0 = "::";
                      pos += 2;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"::\"");
                      }
                    }

                    if (result0 !== null) {
                      result1 = parse_h16();

                      if (result1 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result2 = ":";
                          pos++;
                        } else {
                          result2 = null;

                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }

                        if (result2 !== null) {
                          result3 = parse_h16();

                          if (result3 !== null) {
                            if (input.charCodeAt(pos) === 58) {
                              result4 = ":";
                              pos++;
                            } else {
                              result4 = null;

                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }

                            if (result4 !== null) {
                              result5 = parse_h16();

                              if (result5 !== null) {
                                if (input.charCodeAt(pos) === 58) {
                                  result6 = ":";
                                  pos++;
                                } else {
                                  result6 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }

                                if (result6 !== null) {
                                  result7 = parse_h16();

                                  if (result7 !== null) {
                                    if (input.charCodeAt(pos) === 58) {
                                      result8 = ":";
                                      pos++;
                                    } else {
                                      result8 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }

                                    if (result8 !== null) {
                                      result9 = parse_ls32();

                                      if (result9 !== null) {
                                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }

                    if (result0 === null) {
                      pos1 = pos;

                      if (input.substr(pos, 2) === "::") {
                        result0 = "::";
                        pos += 2;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"::\"");
                        }
                      }

                      if (result0 !== null) {
                        result1 = parse_h16();

                        if (result1 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result2 = ":";
                            pos++;
                          } else {
                            result2 = null;

                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }

                          if (result2 !== null) {
                            result3 = parse_h16();

                            if (result3 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result4 = ":";
                                pos++;
                              } else {
                                result4 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }

                              if (result4 !== null) {
                                result5 = parse_h16();

                                if (result5 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result6 = ":";
                                    pos++;
                                  } else {
                                    result6 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }

                                  if (result6 !== null) {
                                    result7 = parse_ls32();

                                    if (result7 !== null) {
                                      result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }

                      if (result0 === null) {
                        pos1 = pos;

                        if (input.substr(pos, 2) === "::") {
                          result0 = "::";
                          pos += 2;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"::\"");
                          }
                        }

                        if (result0 !== null) {
                          result1 = parse_h16();

                          if (result1 !== null) {
                            if (input.charCodeAt(pos) === 58) {
                              result2 = ":";
                              pos++;
                            } else {
                              result2 = null;

                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }

                            if (result2 !== null) {
                              result3 = parse_h16();

                              if (result3 !== null) {
                                if (input.charCodeAt(pos) === 58) {
                                  result4 = ":";
                                  pos++;
                                } else {
                                  result4 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }

                                if (result4 !== null) {
                                  result5 = parse_ls32();

                                  if (result5 !== null) {
                                    result0 = [result0, result1, result2, result3, result4, result5];
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }

                        if (result0 === null) {
                          pos1 = pos;

                          if (input.substr(pos, 2) === "::") {
                            result0 = "::";
                            pos += 2;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"::\"");
                            }
                          }

                          if (result0 !== null) {
                            result1 = parse_h16();

                            if (result1 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result2 = ":";
                                pos++;
                              } else {
                                result2 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }

                              if (result2 !== null) {
                                result3 = parse_ls32();

                                if (result3 !== null) {
                                  result0 = [result0, result1, result2, result3];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }

                          if (result0 === null) {
                            pos1 = pos;

                            if (input.substr(pos, 2) === "::") {
                              result0 = "::";
                              pos += 2;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"::\"");
                              }
                            }

                            if (result0 !== null) {
                              result1 = parse_ls32();

                              if (result1 !== null) {
                                result0 = [result0, result1];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }

                            if (result0 === null) {
                              pos1 = pos;

                              if (input.substr(pos, 2) === "::") {
                                result0 = "::";
                                pos += 2;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"::\"");
                                }
                              }

                              if (result0 !== null) {
                                result1 = parse_h16();

                                if (result1 !== null) {
                                  result0 = [result0, result1];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }

                              if (result0 === null) {
                                pos1 = pos;
                                result0 = parse_h16();

                                if (result0 !== null) {
                                  if (input.substr(pos, 2) === "::") {
                                    result1 = "::";
                                    pos += 2;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"::\"");
                                    }
                                  }

                                  if (result1 !== null) {
                                    result2 = parse_h16();

                                    if (result2 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result3 = ":";
                                        pos++;
                                      } else {
                                        result3 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }

                                      if (result3 !== null) {
                                        result4 = parse_h16();

                                        if (result4 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result5 = ":";
                                            pos++;
                                          } else {
                                            result5 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }

                                          if (result5 !== null) {
                                            result6 = parse_h16();

                                            if (result6 !== null) {
                                              if (input.charCodeAt(pos) === 58) {
                                                result7 = ":";
                                                pos++;
                                              } else {
                                                result7 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result7 !== null) {
                                                result8 = parse_h16();

                                                if (result8 !== null) {
                                                  if (input.charCodeAt(pos) === 58) {
                                                    result9 = ":";
                                                    pos++;
                                                  } else {
                                                    result9 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result9 !== null) {
                                                    result10 = parse_ls32();

                                                    if (result10 !== null) {
                                                      result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }

                                if (result0 === null) {
                                  pos1 = pos;
                                  result0 = parse_h16();

                                  if (result0 !== null) {
                                    pos2 = pos;

                                    if (input.charCodeAt(pos) === 58) {
                                      result1 = ":";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }

                                    if (result1 !== null) {
                                      result2 = parse_h16();

                                      if (result2 !== null) {
                                        result1 = [result1, result2];
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }

                                    result1 = result1 !== null ? result1 : "";

                                    if (result1 !== null) {
                                      if (input.substr(pos, 2) === "::") {
                                        result2 = "::";
                                        pos += 2;
                                      } else {
                                        result2 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"::\"");
                                        }
                                      }

                                      if (result2 !== null) {
                                        result3 = parse_h16();

                                        if (result3 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result4 = ":";
                                            pos++;
                                          } else {
                                            result4 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }

                                          if (result4 !== null) {
                                            result5 = parse_h16();

                                            if (result5 !== null) {
                                              if (input.charCodeAt(pos) === 58) {
                                                result6 = ":";
                                                pos++;
                                              } else {
                                                result6 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result6 !== null) {
                                                result7 = parse_h16();

                                                if (result7 !== null) {
                                                  if (input.charCodeAt(pos) === 58) {
                                                    result8 = ":";
                                                    pos++;
                                                  } else {
                                                    result8 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result8 !== null) {
                                                    result9 = parse_ls32();

                                                    if (result9 !== null) {
                                                      result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }

                                  if (result0 === null) {
                                    pos1 = pos;
                                    result0 = parse_h16();

                                    if (result0 !== null) {
                                      pos2 = pos;

                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }

                                      if (result1 !== null) {
                                        result2 = parse_h16();

                                        if (result2 !== null) {
                                          result1 = [result1, result2];
                                        } else {
                                          result1 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }

                                      result1 = result1 !== null ? result1 : "";

                                      if (result1 !== null) {
                                        pos2 = pos;

                                        if (input.charCodeAt(pos) === 58) {
                                          result2 = ":";
                                          pos++;
                                        } else {
                                          result2 = null;

                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }

                                        if (result2 !== null) {
                                          result3 = parse_h16();

                                          if (result3 !== null) {
                                            result2 = [result2, result3];
                                          } else {
                                            result2 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }

                                        result2 = result2 !== null ? result2 : "";

                                        if (result2 !== null) {
                                          if (input.substr(pos, 2) === "::") {
                                            result3 = "::";
                                            pos += 2;
                                          } else {
                                            result3 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\"::\"");
                                            }
                                          }

                                          if (result3 !== null) {
                                            result4 = parse_h16();

                                            if (result4 !== null) {
                                              if (input.charCodeAt(pos) === 58) {
                                                result5 = ":";
                                                pos++;
                                              } else {
                                                result5 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result5 !== null) {
                                                result6 = parse_h16();

                                                if (result6 !== null) {
                                                  if (input.charCodeAt(pos) === 58) {
                                                    result7 = ":";
                                                    pos++;
                                                  } else {
                                                    result7 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result7 !== null) {
                                                    result8 = parse_ls32();

                                                    if (result8 !== null) {
                                                      result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }

                                    if (result0 === null) {
                                      pos1 = pos;
                                      result0 = parse_h16();

                                      if (result0 !== null) {
                                        pos2 = pos;

                                        if (input.charCodeAt(pos) === 58) {
                                          result1 = ":";
                                          pos++;
                                        } else {
                                          result1 = null;

                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }

                                        if (result1 !== null) {
                                          result2 = parse_h16();

                                          if (result2 !== null) {
                                            result1 = [result1, result2];
                                          } else {
                                            result1 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result1 = null;
                                          pos = pos2;
                                        }

                                        result1 = result1 !== null ? result1 : "";

                                        if (result1 !== null) {
                                          pos2 = pos;

                                          if (input.charCodeAt(pos) === 58) {
                                            result2 = ":";
                                            pos++;
                                          } else {
                                            result2 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }

                                          if (result2 !== null) {
                                            result3 = parse_h16();

                                            if (result3 !== null) {
                                              result2 = [result2, result3];
                                            } else {
                                              result2 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result2 = null;
                                            pos = pos2;
                                          }

                                          result2 = result2 !== null ? result2 : "";

                                          if (result2 !== null) {
                                            pos2 = pos;

                                            if (input.charCodeAt(pos) === 58) {
                                              result3 = ":";
                                              pos++;
                                            } else {
                                              result3 = null;

                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }

                                            if (result3 !== null) {
                                              result4 = parse_h16();

                                              if (result4 !== null) {
                                                result3 = [result3, result4];
                                              } else {
                                                result3 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result3 = null;
                                              pos = pos2;
                                            }

                                            result3 = result3 !== null ? result3 : "";

                                            if (result3 !== null) {
                                              if (input.substr(pos, 2) === "::") {
                                                result4 = "::";
                                                pos += 2;
                                              } else {
                                                result4 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\"::\"");
                                                }
                                              }

                                              if (result4 !== null) {
                                                result5 = parse_h16();

                                                if (result5 !== null) {
                                                  if (input.charCodeAt(pos) === 58) {
                                                    result6 = ":";
                                                    pos++;
                                                  } else {
                                                    result6 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result6 !== null) {
                                                    result7 = parse_ls32();

                                                    if (result7 !== null) {
                                                      result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }

                                      if (result0 === null) {
                                        pos1 = pos;
                                        result0 = parse_h16();

                                        if (result0 !== null) {
                                          pos2 = pos;

                                          if (input.charCodeAt(pos) === 58) {
                                            result1 = ":";
                                            pos++;
                                          } else {
                                            result1 = null;

                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }

                                          if (result1 !== null) {
                                            result2 = parse_h16();

                                            if (result2 !== null) {
                                              result1 = [result1, result2];
                                            } else {
                                              result1 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result1 = null;
                                            pos = pos2;
                                          }

                                          result1 = result1 !== null ? result1 : "";

                                          if (result1 !== null) {
                                            pos2 = pos;

                                            if (input.charCodeAt(pos) === 58) {
                                              result2 = ":";
                                              pos++;
                                            } else {
                                              result2 = null;

                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }

                                            if (result2 !== null) {
                                              result3 = parse_h16();

                                              if (result3 !== null) {
                                                result2 = [result2, result3];
                                              } else {
                                                result2 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result2 = null;
                                              pos = pos2;
                                            }

                                            result2 = result2 !== null ? result2 : "";

                                            if (result2 !== null) {
                                              pos2 = pos;

                                              if (input.charCodeAt(pos) === 58) {
                                                result3 = ":";
                                                pos++;
                                              } else {
                                                result3 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result3 !== null) {
                                                result4 = parse_h16();

                                                if (result4 !== null) {
                                                  result3 = [result3, result4];
                                                } else {
                                                  result3 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result3 = null;
                                                pos = pos2;
                                              }

                                              result3 = result3 !== null ? result3 : "";

                                              if (result3 !== null) {
                                                pos2 = pos;

                                                if (input.charCodeAt(pos) === 58) {
                                                  result4 = ":";
                                                  pos++;
                                                } else {
                                                  result4 = null;

                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }

                                                if (result4 !== null) {
                                                  result5 = parse_h16();

                                                  if (result5 !== null) {
                                                    result4 = [result4, result5];
                                                  } else {
                                                    result4 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result4 = null;
                                                  pos = pos2;
                                                }

                                                result4 = result4 !== null ? result4 : "";

                                                if (result4 !== null) {
                                                  if (input.substr(pos, 2) === "::") {
                                                    result5 = "::";
                                                    pos += 2;
                                                  } else {
                                                    result5 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\"::\"");
                                                    }
                                                  }

                                                  if (result5 !== null) {
                                                    result6 = parse_ls32();

                                                    if (result6 !== null) {
                                                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }

                                        if (result0 === null) {
                                          pos1 = pos;
                                          result0 = parse_h16();

                                          if (result0 !== null) {
                                            pos2 = pos;

                                            if (input.charCodeAt(pos) === 58) {
                                              result1 = ":";
                                              pos++;
                                            } else {
                                              result1 = null;

                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }

                                            if (result1 !== null) {
                                              result2 = parse_h16();

                                              if (result2 !== null) {
                                                result1 = [result1, result2];
                                              } else {
                                                result1 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result1 = null;
                                              pos = pos2;
                                            }

                                            result1 = result1 !== null ? result1 : "";

                                            if (result1 !== null) {
                                              pos2 = pos;

                                              if (input.charCodeAt(pos) === 58) {
                                                result2 = ":";
                                                pos++;
                                              } else {
                                                result2 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result2 !== null) {
                                                result3 = parse_h16();

                                                if (result3 !== null) {
                                                  result2 = [result2, result3];
                                                } else {
                                                  result2 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result2 = null;
                                                pos = pos2;
                                              }

                                              result2 = result2 !== null ? result2 : "";

                                              if (result2 !== null) {
                                                pos2 = pos;

                                                if (input.charCodeAt(pos) === 58) {
                                                  result3 = ":";
                                                  pos++;
                                                } else {
                                                  result3 = null;

                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }

                                                if (result3 !== null) {
                                                  result4 = parse_h16();

                                                  if (result4 !== null) {
                                                    result3 = [result3, result4];
                                                  } else {
                                                    result3 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result3 = null;
                                                  pos = pos2;
                                                }

                                                result3 = result3 !== null ? result3 : "";

                                                if (result3 !== null) {
                                                  pos2 = pos;

                                                  if (input.charCodeAt(pos) === 58) {
                                                    result4 = ":";
                                                    pos++;
                                                  } else {
                                                    result4 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result4 !== null) {
                                                    result5 = parse_h16();

                                                    if (result5 !== null) {
                                                      result4 = [result4, result5];
                                                    } else {
                                                      result4 = null;
                                                      pos = pos2;
                                                    }
                                                  } else {
                                                    result4 = null;
                                                    pos = pos2;
                                                  }

                                                  result4 = result4 !== null ? result4 : "";

                                                  if (result4 !== null) {
                                                    pos2 = pos;

                                                    if (input.charCodeAt(pos) === 58) {
                                                      result5 = ":";
                                                      pos++;
                                                    } else {
                                                      result5 = null;

                                                      if (reportFailures === 0) {
                                                        matchFailed("\":\"");
                                                      }
                                                    }

                                                    if (result5 !== null) {
                                                      result6 = parse_h16();

                                                      if (result6 !== null) {
                                                        result5 = [result5, result6];
                                                      } else {
                                                        result5 = null;
                                                        pos = pos2;
                                                      }
                                                    } else {
                                                      result5 = null;
                                                      pos = pos2;
                                                    }

                                                    result5 = result5 !== null ? result5 : "";

                                                    if (result5 !== null) {
                                                      if (input.substr(pos, 2) === "::") {
                                                        result6 = "::";
                                                        pos += 2;
                                                      } else {
                                                        result6 = null;

                                                        if (reportFailures === 0) {
                                                          matchFailed("\"::\"");
                                                        }
                                                      }

                                                      if (result6 !== null) {
                                                        result7 = parse_h16();

                                                        if (result7 !== null) {
                                                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                        } else {
                                                          result0 = null;
                                                          pos = pos1;
                                                        }
                                                      } else {
                                                        result0 = null;
                                                        pos = pos1;
                                                      }
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }

                                          if (result0 === null) {
                                            pos1 = pos;
                                            result0 = parse_h16();

                                            if (result0 !== null) {
                                              pos2 = pos;

                                              if (input.charCodeAt(pos) === 58) {
                                                result1 = ":";
                                                pos++;
                                              } else {
                                                result1 = null;

                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }

                                              if (result1 !== null) {
                                                result2 = parse_h16();

                                                if (result2 !== null) {
                                                  result1 = [result1, result2];
                                                } else {
                                                  result1 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result1 = null;
                                                pos = pos2;
                                              }

                                              result1 = result1 !== null ? result1 : "";

                                              if (result1 !== null) {
                                                pos2 = pos;

                                                if (input.charCodeAt(pos) === 58) {
                                                  result2 = ":";
                                                  pos++;
                                                } else {
                                                  result2 = null;

                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }

                                                if (result2 !== null) {
                                                  result3 = parse_h16();

                                                  if (result3 !== null) {
                                                    result2 = [result2, result3];
                                                  } else {
                                                    result2 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result2 = null;
                                                  pos = pos2;
                                                }

                                                result2 = result2 !== null ? result2 : "";

                                                if (result2 !== null) {
                                                  pos2 = pos;

                                                  if (input.charCodeAt(pos) === 58) {
                                                    result3 = ":";
                                                    pos++;
                                                  } else {
                                                    result3 = null;

                                                    if (reportFailures === 0) {
                                                      matchFailed("\":\"");
                                                    }
                                                  }

                                                  if (result3 !== null) {
                                                    result4 = parse_h16();

                                                    if (result4 !== null) {
                                                      result3 = [result3, result4];
                                                    } else {
                                                      result3 = null;
                                                      pos = pos2;
                                                    }
                                                  } else {
                                                    result3 = null;
                                                    pos = pos2;
                                                  }

                                                  result3 = result3 !== null ? result3 : "";

                                                  if (result3 !== null) {
                                                    pos2 = pos;

                                                    if (input.charCodeAt(pos) === 58) {
                                                      result4 = ":";
                                                      pos++;
                                                    } else {
                                                      result4 = null;

                                                      if (reportFailures === 0) {
                                                        matchFailed("\":\"");
                                                      }
                                                    }

                                                    if (result4 !== null) {
                                                      result5 = parse_h16();

                                                      if (result5 !== null) {
                                                        result4 = [result4, result5];
                                                      } else {
                                                        result4 = null;
                                                        pos = pos2;
                                                      }
                                                    } else {
                                                      result4 = null;
                                                      pos = pos2;
                                                    }

                                                    result4 = result4 !== null ? result4 : "";

                                                    if (result4 !== null) {
                                                      pos2 = pos;

                                                      if (input.charCodeAt(pos) === 58) {
                                                        result5 = ":";
                                                        pos++;
                                                      } else {
                                                        result5 = null;

                                                        if (reportFailures === 0) {
                                                          matchFailed("\":\"");
                                                        }
                                                      }

                                                      if (result5 !== null) {
                                                        result6 = parse_h16();

                                                        if (result6 !== null) {
                                                          result5 = [result5, result6];
                                                        } else {
                                                          result5 = null;
                                                          pos = pos2;
                                                        }
                                                      } else {
                                                        result5 = null;
                                                        pos = pos2;
                                                      }

                                                      result5 = result5 !== null ? result5 : "";

                                                      if (result5 !== null) {
                                                        pos2 = pos;

                                                        if (input.charCodeAt(pos) === 58) {
                                                          result6 = ":";
                                                          pos++;
                                                        } else {
                                                          result6 = null;

                                                          if (reportFailures === 0) {
                                                            matchFailed("\":\"");
                                                          }
                                                        }

                                                        if (result6 !== null) {
                                                          result7 = parse_h16();

                                                          if (result7 !== null) {
                                                            result6 = [result6, result7];
                                                          } else {
                                                            result6 = null;
                                                            pos = pos2;
                                                          }
                                                        } else {
                                                          result6 = null;
                                                          pos = pos2;
                                                        }

                                                        result6 = result6 !== null ? result6 : "";

                                                        if (result6 !== null) {
                                                          if (input.substr(pos, 2) === "::") {
                                                            result7 = "::";
                                                            pos += 2;
                                                          } else {
                                                            result7 = null;

                                                            if (reportFailures === 0) {
                                                              matchFailed("\"::\"");
                                                            }
                                                          }

                                                          if (result7 !== null) {
                                                            result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                          } else {
                                                            result0 = null;
                                                            pos = pos1;
                                                          }
                                                        } else {
                                                          result0 = null;
                                                          pos = pos1;
                                                        }
                                                      } else {
                                                        result0 = null;
                                                        pos = pos1;
                                                      }
                                                    } else {
                                                      result0 = null;
                                                      pos = pos1;
                                                    }
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.host_type = 'IPv6';
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_h16() {
                var result0, result1, result2, result3;
                var pos0;
                pos0 = pos;
                result0 = parse_HEXDIG();

                if (result0 !== null) {
                  result1 = parse_HEXDIG();
                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result2 = parse_HEXDIG();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_HEXDIG();
                      result3 = result3 !== null ? result3 : "";

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_ls32() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_h16();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_h16();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                if (result0 === null) {
                  result0 = parse_IPv4address();
                }

                return result0;
              }

              function parse_IPv4address() {
                var result0, result1, result2, result3, result4, result5, result6;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_dec_octet();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result1 = ".";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_dec_octet();

                    if (result2 !== null) {
                      if (input.charCodeAt(pos) === 46) {
                        result3 = ".";
                        pos++;
                      } else {
                        result3 = null;

                        if (reportFailures === 0) {
                          matchFailed("\".\"");
                        }
                      }

                      if (result3 !== null) {
                        result4 = parse_dec_octet();

                        if (result4 !== null) {
                          if (input.charCodeAt(pos) === 46) {
                            result5 = ".";
                            pos++;
                          } else {
                            result5 = null;

                            if (reportFailures === 0) {
                              matchFailed("\".\"");
                            }
                          }

                          if (result5 !== null) {
                            result6 = parse_dec_octet();

                            if (result6 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.host_type = 'IPv4';
                    return input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_dec_octet() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 2) === "25") {
                  result0 = "25";
                  pos += 2;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"25\"");
                  }
                }

                if (result0 !== null) {
                  if (/^[0-5]/.test(input.charAt(pos))) {
                    result1 = input.charAt(pos);
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("[0-5]");
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                if (result0 === null) {
                  pos0 = pos;

                  if (input.charCodeAt(pos) === 50) {
                    result0 = "2";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"2\"");
                    }
                  }

                  if (result0 !== null) {
                    if (/^[0-4]/.test(input.charAt(pos))) {
                      result1 = input.charAt(pos);
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("[0-4]");
                      }
                    }

                    if (result1 !== null) {
                      result2 = parse_DIGIT();

                      if (result2 !== null) {
                        result0 = [result0, result1, result2];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }

                  if (result0 === null) {
                    pos0 = pos;

                    if (input.charCodeAt(pos) === 49) {
                      result0 = "1";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"1\"");
                      }
                    }

                    if (result0 !== null) {
                      result1 = parse_DIGIT();

                      if (result1 !== null) {
                        result2 = parse_DIGIT();

                        if (result2 !== null) {
                          result0 = [result0, result1, result2];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }

                    if (result0 === null) {
                      pos0 = pos;

                      if (/^[1-9]/.test(input.charAt(pos))) {
                        result0 = input.charAt(pos);
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("[1-9]");
                        }
                      }

                      if (result0 !== null) {
                        result1 = parse_DIGIT();

                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }

                      if (result0 === null) {
                        result0 = parse_DIGIT();
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_port() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_DIGIT();
                result0 = result0 !== null ? result0 : "";

                if (result0 !== null) {
                  result1 = parse_DIGIT();
                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result2 = parse_DIGIT();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_DIGIT();
                      result3 = result3 !== null ? result3 : "";

                      if (result3 !== null) {
                        result4 = parse_DIGIT();
                        result4 = result4 !== null ? result4 : "";

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, port) {
                    port = parseInt(port.join(''));
                    data.port = port;
                    return port;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_uri_parameters() {
                var result0, result1, result2;
                var pos0;
                result0 = [];
                pos0 = pos;

                if (input.charCodeAt(pos) === 59) {
                  result1 = ";";
                  pos++;
                } else {
                  result1 = null;

                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }

                if (result1 !== null) {
                  result2 = parse_uri_parameter();

                  if (result2 !== null) {
                    result1 = [result1, result2];
                  } else {
                    result1 = null;
                    pos = pos0;
                  }
                } else {
                  result1 = null;
                  pos = pos0;
                }

                while (result1 !== null) {
                  result0.push(result1);
                  pos0 = pos;

                  if (input.charCodeAt(pos) === 59) {
                    result1 = ";";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_uri_parameter();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos0;
                    }
                  } else {
                    result1 = null;
                    pos = pos0;
                  }
                }

                return result0;
              }

              function parse_uri_parameter() {
                var result0;
                result0 = parse_transport_param();

                if (result0 === null) {
                  result0 = parse_user_param();

                  if (result0 === null) {
                    result0 = parse_method_param();

                    if (result0 === null) {
                      result0 = parse_ttl_param();

                      if (result0 === null) {
                        result0 = parse_maddr_param();

                        if (result0 === null) {
                          result0 = parse_lr_param();

                          if (result0 === null) {
                            result0 = parse_other_param();
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_transport_param() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 10).toLowerCase() === "transport=") {
                  result0 = input.substr(pos, 10);
                  pos += 10;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"transport=\"");
                  }
                }

                if (result0 !== null) {
                  if (input.substr(pos, 3).toLowerCase() === "udp") {
                    result1 = input.substr(pos, 3);
                    pos += 3;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"udp\"");
                    }
                  }

                  if (result1 === null) {
                    if (input.substr(pos, 3).toLowerCase() === "tcp") {
                      result1 = input.substr(pos, 3);
                      pos += 3;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"tcp\"");
                      }
                    }

                    if (result1 === null) {
                      if (input.substr(pos, 4).toLowerCase() === "sctp") {
                        result1 = input.substr(pos, 4);
                        pos += 4;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"sctp\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.substr(pos, 3).toLowerCase() === "tls") {
                          result1 = input.substr(pos, 3);
                          pos += 3;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"tls\"");
                          }
                        }

                        if (result1 === null) {
                          result1 = parse_token();
                        }
                      }
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, transport) {
                    if (!data.uri_params) data.uri_params = {};
                    data.uri_params['transport'] = transport.toLowerCase();
                  }(pos0, result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_user_param() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 5).toLowerCase() === "user=") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"user=\"");
                  }
                }

                if (result0 !== null) {
                  if (input.substr(pos, 5).toLowerCase() === "phone") {
                    result1 = input.substr(pos, 5);
                    pos += 5;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"phone\"");
                    }
                  }

                  if (result1 === null) {
                    if (input.substr(pos, 2).toLowerCase() === "ip") {
                      result1 = input.substr(pos, 2);
                      pos += 2;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"ip\"");
                      }
                    }

                    if (result1 === null) {
                      result1 = parse_token();
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, user) {
                    if (!data.uri_params) data.uri_params = {};
                    data.uri_params['user'] = user.toLowerCase();
                  }(pos0, result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_method_param() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 7).toLowerCase() === "method=") {
                  result0 = input.substr(pos, 7);
                  pos += 7;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"method=\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_Method();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, method) {
                    if (!data.uri_params) data.uri_params = {};
                    data.uri_params['method'] = method;
                  }(pos0, result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_ttl_param() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 4).toLowerCase() === "ttl=") {
                  result0 = input.substr(pos, 4);
                  pos += 4;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"ttl=\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_ttl();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, ttl) {
                    if (!data.params) data.params = {};
                    data.params['ttl'] = ttl;
                  }(pos0, result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_maddr_param() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 6).toLowerCase() === "maddr=") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"maddr=\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_host();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, maddr) {
                    if (!data.uri_params) data.uri_params = {};
                    data.uri_params['maddr'] = maddr;
                  }(pos0, result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_lr_param() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 2).toLowerCase() === "lr") {
                  result0 = input.substr(pos, 2);
                  pos += 2;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"lr\"");
                  }
                }

                if (result0 !== null) {
                  pos2 = pos;

                  if (input.charCodeAt(pos) === 61) {
                    result1 = "=";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    if (!data.uri_params) data.uri_params = {};
                    data.uri_params['lr'] = undefined;
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_other_param() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_pname();

                if (result0 !== null) {
                  pos2 = pos;

                  if (input.charCodeAt(pos) === 61) {
                    result1 = "=";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_pvalue();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, param, value) {
                    if (!data.uri_params) data.uri_params = {};

                    if (typeof value === 'undefined') {
                      value = undefined;
                    } else {
                      value = value[1];
                    }

                    data.uri_params[param.toLowerCase()] = value;
                  }(pos0, result0[0], result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_pname() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_paramchar();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_paramchar();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset, pname) {
                    return pname.join('');
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_pvalue() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_paramchar();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_paramchar();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset, pvalue) {
                    return pvalue.join('');
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_paramchar() {
                var result0;
                result0 = parse_param_unreserved();

                if (result0 === null) {
                  result0 = parse_unreserved();

                  if (result0 === null) {
                    result0 = parse_escaped();
                  }
                }

                return result0;
              }

              function parse_param_unreserved() {
                var result0;

                if (input.charCodeAt(pos) === 91) {
                  result0 = "[";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"[\"");
                  }
                }

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 93) {
                    result0 = "]";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"]\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 47) {
                      result0 = "/";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"/\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result0 = ":";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 38) {
                          result0 = "&";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"&\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result0 = "+";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 36) {
                              result0 = "$";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"$\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_headers() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1;
                pos0 = pos;

                if (input.charCodeAt(pos) === 63) {
                  result0 = "?";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"?\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_header();

                  if (result1 !== null) {
                    result2 = [];
                    pos1 = pos;

                    if (input.charCodeAt(pos) === 38) {
                      result3 = "&";
                      pos++;
                    } else {
                      result3 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"&\"");
                      }
                    }

                    if (result3 !== null) {
                      result4 = parse_header();

                      if (result4 !== null) {
                        result3 = [result3, result4];
                      } else {
                        result3 = null;
                        pos = pos1;
                      }
                    } else {
                      result3 = null;
                      pos = pos1;
                    }

                    while (result3 !== null) {
                      result2.push(result3);
                      pos1 = pos;

                      if (input.charCodeAt(pos) === 38) {
                        result3 = "&";
                        pos++;
                      } else {
                        result3 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"&\"");
                        }
                      }

                      if (result3 !== null) {
                        result4 = parse_header();

                        if (result4 !== null) {
                          result3 = [result3, result4];
                        } else {
                          result3 = null;
                          pos = pos1;
                        }
                      } else {
                        result3 = null;
                        pos = pos1;
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_header() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_hname();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 61) {
                    result1 = "=";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_hvalue();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, hname, hvalue) {
                    hname = hname.join('').toLowerCase();
                    hvalue = hvalue.join('');
                    if (!data.uri_headers) data.uri_headers = {};

                    if (!data.uri_headers[hname]) {
                      data.uri_headers[hname] = [hvalue];
                    } else {
                      data.uri_headers[hname].push(hvalue);
                    }
                  }(pos0, result0[0], result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_hname() {
                var result0, result1;
                result1 = parse_hnv_unreserved();

                if (result1 === null) {
                  result1 = parse_unreserved();

                  if (result1 === null) {
                    result1 = parse_escaped();
                  }
                }

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_hnv_unreserved();

                    if (result1 === null) {
                      result1 = parse_unreserved();

                      if (result1 === null) {
                        result1 = parse_escaped();
                      }
                    }
                  }
                } else {
                  result0 = null;
                }

                return result0;
              }

              function parse_hvalue() {
                var result0, result1;
                result0 = [];
                result1 = parse_hnv_unreserved();

                if (result1 === null) {
                  result1 = parse_unreserved();

                  if (result1 === null) {
                    result1 = parse_escaped();
                  }
                }

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_hnv_unreserved();

                  if (result1 === null) {
                    result1 = parse_unreserved();

                    if (result1 === null) {
                      result1 = parse_escaped();
                    }
                  }
                }

                return result0;
              }

              function parse_hnv_unreserved() {
                var result0;

                if (input.charCodeAt(pos) === 91) {
                  result0 = "[";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"[\"");
                  }
                }

                if (result0 === null) {
                  if (input.charCodeAt(pos) === 93) {
                    result0 = "]";
                    pos++;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"]\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 47) {
                      result0 = "/";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"/\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 63) {
                        result0 = "?";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"?\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 58) {
                          result0 = ":";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result0 = "+";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 36) {
                              result0 = "$";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"$\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_Request_Response() {
                var result0;
                result0 = parse_Status_Line();

                if (result0 === null) {
                  result0 = parse_Request_Line();
                }

                return result0;
              }

              function parse_Request_Line() {
                var result0, result1, result2, result3, result4;
                var pos0;
                pos0 = pos;
                result0 = parse_Method();

                if (result0 !== null) {
                  result1 = parse_SP();

                  if (result1 !== null) {
                    result2 = parse_Request_URI();

                    if (result2 !== null) {
                      result3 = parse_SP();

                      if (result3 !== null) {
                        result4 = parse_SIP_Version();

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Request_URI() {
                var result0;
                result0 = parse_SIP_URI();

                if (result0 === null) {
                  result0 = parse_absoluteURI();
                }

                return result0;
              }

              function parse_absoluteURI() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_scheme();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_hier_part();

                    if (result2 === null) {
                      result2 = parse_opaque_part();
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_hier_part() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_net_path();

                if (result0 === null) {
                  result0 = parse_abs_path();
                }

                if (result0 !== null) {
                  pos1 = pos;

                  if (input.charCodeAt(pos) === 63) {
                    result1 = "?";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"?\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_query();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos1;
                    }
                  } else {
                    result1 = null;
                    pos = pos1;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_net_path() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 2) === "//") {
                  result0 = "//";
                  pos += 2;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"//\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_authority();

                  if (result1 !== null) {
                    result2 = parse_abs_path();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_abs_path() {
                var result0, result1;
                var pos0;
                pos0 = pos;

                if (input.charCodeAt(pos) === 47) {
                  result0 = "/";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"/\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_path_segments();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_opaque_part() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_uric_no_slash();

                if (result0 !== null) {
                  result1 = [];
                  result2 = parse_uric();

                  while (result2 !== null) {
                    result1.push(result2);
                    result2 = parse_uric();
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_uric() {
                var result0;
                result0 = parse_reserved();

                if (result0 === null) {
                  result0 = parse_unreserved();

                  if (result0 === null) {
                    result0 = parse_escaped();
                  }
                }

                return result0;
              }

              function parse_uric_no_slash() {
                var result0;
                result0 = parse_unreserved();

                if (result0 === null) {
                  result0 = parse_escaped();

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result0 = ";";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 63) {
                        result0 = "?";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"?\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 58) {
                          result0 = ":";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 64) {
                            result0 = "@";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"@\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 38) {
                              result0 = "&";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"&\"");
                              }
                            }

                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 61) {
                                result0 = "=";
                                pos++;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"=\"");
                                }
                              }

                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 43) {
                                  result0 = "+";
                                  pos++;
                                } else {
                                  result0 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"+\"");
                                  }
                                }

                                if (result0 === null) {
                                  if (input.charCodeAt(pos) === 36) {
                                    result0 = "$";
                                    pos++;
                                  } else {
                                    result0 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"$\"");
                                    }
                                  }

                                  if (result0 === null) {
                                    if (input.charCodeAt(pos) === 44) {
                                      result0 = ",";
                                      pos++;
                                    } else {
                                      result0 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\",\"");
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_path_segments() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_segment();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;

                  if (input.charCodeAt(pos) === 47) {
                    result2 = "/";
                    pos++;
                  } else {
                    result2 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"/\"");
                    }
                  }

                  if (result2 !== null) {
                    result3 = parse_segment();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;

                    if (input.charCodeAt(pos) === 47) {
                      result2 = "/";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"/\"");
                      }
                    }

                    if (result2 !== null) {
                      result3 = parse_segment();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_segment() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = [];
                result1 = parse_pchar();

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_pchar();
                }

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;

                  if (input.charCodeAt(pos) === 59) {
                    result2 = ";";
                    pos++;
                  } else {
                    result2 = null;

                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }

                  if (result2 !== null) {
                    result3 = parse_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;

                    if (input.charCodeAt(pos) === 59) {
                      result2 = ";";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }

                    if (result2 !== null) {
                      result3 = parse_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_param() {
                var result0, result1;
                result0 = [];
                result1 = parse_pchar();

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_pchar();
                }

                return result0;
              }

              function parse_pchar() {
                var result0;
                result0 = parse_unreserved();

                if (result0 === null) {
                  result0 = parse_escaped();

                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 58) {
                      result0 = ":";
                      pos++;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 64) {
                        result0 = "@";
                        pos++;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"@\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 38) {
                          result0 = "&";
                          pos++;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"&\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 61) {
                            result0 = "=";
                            pos++;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"=\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 43) {
                              result0 = "+";
                              pos++;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"+\"");
                              }
                            }

                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 36) {
                                result0 = "$";
                                pos++;
                              } else {
                                result0 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"$\"");
                                }
                              }

                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 44) {
                                  result0 = ",";
                                  pos++;
                                } else {
                                  result0 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\",\"");
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_scheme() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_ALPHA();

                if (result0 !== null) {
                  result1 = [];
                  result2 = parse_ALPHA();

                  if (result2 === null) {
                    result2 = parse_DIGIT();

                    if (result2 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result2 = "+";
                        pos++;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }

                      if (result2 === null) {
                        if (input.charCodeAt(pos) === 45) {
                          result2 = "-";
                          pos++;
                        } else {
                          result2 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"-\"");
                          }
                        }

                        if (result2 === null) {
                          if (input.charCodeAt(pos) === 46) {
                            result2 = ".";
                            pos++;
                          } else {
                            result2 = null;

                            if (reportFailures === 0) {
                              matchFailed("\".\"");
                            }
                          }
                        }
                      }
                    }
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    result2 = parse_ALPHA();

                    if (result2 === null) {
                      result2 = parse_DIGIT();

                      if (result2 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result2 = "+";
                          pos++;
                        } else {
                          result2 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }

                        if (result2 === null) {
                          if (input.charCodeAt(pos) === 45) {
                            result2 = "-";
                            pos++;
                          } else {
                            result2 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"-\"");
                            }
                          }

                          if (result2 === null) {
                            if (input.charCodeAt(pos) === 46) {
                              result2 = ".";
                              pos++;
                            } else {
                              result2 = null;

                              if (reportFailures === 0) {
                                matchFailed("\".\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.scheme = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_authority() {
                var result0;
                result0 = parse_srvr();

                if (result0 === null) {
                  result0 = parse_reg_name();
                }

                return result0;
              }

              function parse_srvr() {
                var result0, result1;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_userinfo();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 64) {
                    result1 = "@";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                result0 = result0 !== null ? result0 : "";

                if (result0 !== null) {
                  result1 = parse_hostport();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                result0 = result0 !== null ? result0 : "";
                return result0;
              }

              function parse_reg_name() {
                var result0, result1;
                result1 = parse_unreserved();

                if (result1 === null) {
                  result1 = parse_escaped();

                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result1 = "$";
                      pos++;
                    } else {
                      result1 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }

                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 44) {
                        result1 = ",";
                        pos++;
                      } else {
                        result1 = null;

                        if (reportFailures === 0) {
                          matchFailed("\",\"");
                        }
                      }

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 59) {
                          result1 = ";";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\";\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 58) {
                            result1 = ":";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 64) {
                              result1 = "@";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"@\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 38) {
                                result1 = "&";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"&\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 61) {
                                  result1 = "=";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"=\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 43) {
                                    result1 = "+";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"+\"");
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_unreserved();

                    if (result1 === null) {
                      result1 = parse_escaped();

                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 36) {
                          result1 = "$";
                          pos++;
                        } else {
                          result1 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"$\"");
                          }
                        }

                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 44) {
                            result1 = ",";
                            pos++;
                          } else {
                            result1 = null;

                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }

                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 59) {
                              result1 = ";";
                              pos++;
                            } else {
                              result1 = null;

                              if (reportFailures === 0) {
                                matchFailed("\";\"");
                              }
                            }

                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 58) {
                                result1 = ":";
                                pos++;
                              } else {
                                result1 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }

                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 64) {
                                  result1 = "@";
                                  pos++;
                                } else {
                                  result1 = null;

                                  if (reportFailures === 0) {
                                    matchFailed("\"@\"");
                                  }
                                }

                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 38) {
                                    result1 = "&";
                                    pos++;
                                  } else {
                                    result1 = null;

                                    if (reportFailures === 0) {
                                      matchFailed("\"&\"");
                                    }
                                  }

                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 61) {
                                      result1 = "=";
                                      pos++;
                                    } else {
                                      result1 = null;

                                      if (reportFailures === 0) {
                                        matchFailed("\"=\"");
                                      }
                                    }

                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 43) {
                                        result1 = "+";
                                        pos++;
                                      } else {
                                        result1 = null;

                                        if (reportFailures === 0) {
                                          matchFailed("\"+\"");
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  result0 = null;
                }

                return result0;
              }

              function parse_query() {
                var result0, result1;
                result0 = [];
                result1 = parse_uric();

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_uric();
                }

                return result0;
              }

              function parse_SIP_Version() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 3).toLowerCase() === "sip") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"SIP\"");
                  }
                }

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 47) {
                    result1 = "/";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"/\"");
                    }
                  }

                  if (result1 !== null) {
                    result3 = parse_DIGIT();

                    if (result3 !== null) {
                      result2 = [];

                      while (result3 !== null) {
                        result2.push(result3);
                        result3 = parse_DIGIT();
                      }
                    } else {
                      result2 = null;
                    }

                    if (result2 !== null) {
                      if (input.charCodeAt(pos) === 46) {
                        result3 = ".";
                        pos++;
                      } else {
                        result3 = null;

                        if (reportFailures === 0) {
                          matchFailed("\".\"");
                        }
                      }

                      if (result3 !== null) {
                        result5 = parse_DIGIT();

                        if (result5 !== null) {
                          result4 = [];

                          while (result5 !== null) {
                            result4.push(result5);
                            result5 = parse_DIGIT();
                          }
                        } else {
                          result4 = null;
                        }

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.sip_version = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_INVITEm() {
                var result0;

                if (input.substr(pos, 6) === "INVITE") {
                  result0 = "INVITE";
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"INVITE\"");
                  }
                }

                return result0;
              }

              function parse_ACKm() {
                var result0;

                if (input.substr(pos, 3) === "ACK") {
                  result0 = "ACK";
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"ACK\"");
                  }
                }

                return result0;
              }

              function parse_OPTIONSm() {
                var result0;

                if (input.substr(pos, 7) === "OPTIONS") {
                  result0 = "OPTIONS";
                  pos += 7;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"OPTIONS\"");
                  }
                }

                return result0;
              }

              function parse_BYEm() {
                var result0;

                if (input.substr(pos, 3) === "BYE") {
                  result0 = "BYE";
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"BYE\"");
                  }
                }

                return result0;
              }

              function parse_CANCELm() {
                var result0;

                if (input.substr(pos, 6) === "CANCEL") {
                  result0 = "CANCEL";
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"CANCEL\"");
                  }
                }

                return result0;
              }

              function parse_REGISTERm() {
                var result0;

                if (input.substr(pos, 8) === "REGISTER") {
                  result0 = "REGISTER";
                  pos += 8;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"REGISTER\"");
                  }
                }

                return result0;
              }

              function parse_SUBSCRIBEm() {
                var result0;

                if (input.substr(pos, 9) === "SUBSCRIBE") {
                  result0 = "SUBSCRIBE";
                  pos += 9;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"SUBSCRIBE\"");
                  }
                }

                return result0;
              }

              function parse_NOTIFYm() {
                var result0;

                if (input.substr(pos, 6) === "NOTIFY") {
                  result0 = "NOTIFY";
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"NOTIFY\"");
                  }
                }

                return result0;
              }

              function parse_REFERm() {
                var result0;

                if (input.substr(pos, 5) === "REFER") {
                  result0 = "REFER";
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"REFER\"");
                  }
                }

                return result0;
              }

              function parse_Method() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_INVITEm();

                if (result0 === null) {
                  result0 = parse_ACKm();

                  if (result0 === null) {
                    result0 = parse_OPTIONSm();

                    if (result0 === null) {
                      result0 = parse_BYEm();

                      if (result0 === null) {
                        result0 = parse_CANCELm();

                        if (result0 === null) {
                          result0 = parse_REGISTERm();

                          if (result0 === null) {
                            result0 = parse_SUBSCRIBEm();

                            if (result0 === null) {
                              result0 = parse_NOTIFYm();

                              if (result0 === null) {
                                result0 = parse_REFERm();

                                if (result0 === null) {
                                  result0 = parse_token();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.method = input.substring(pos, offset);
                    return data.method;
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Status_Line() {
                var result0, result1, result2, result3, result4;
                var pos0;
                pos0 = pos;
                result0 = parse_SIP_Version();

                if (result0 !== null) {
                  result1 = parse_SP();

                  if (result1 !== null) {
                    result2 = parse_Status_Code();

                    if (result2 !== null) {
                      result3 = parse_SP();

                      if (result3 !== null) {
                        result4 = parse_Reason_Phrase();

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Status_Code() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_extension_code();

                if (result0 !== null) {
                  result0 = function (offset, status_code) {
                    data.status_code = parseInt(status_code.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_extension_code() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_DIGIT();

                if (result0 !== null) {
                  result1 = parse_DIGIT();

                  if (result1 !== null) {
                    result2 = parse_DIGIT();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Reason_Phrase() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result0 = [];
                result1 = parse_reserved();

                if (result1 === null) {
                  result1 = parse_unreserved();

                  if (result1 === null) {
                    result1 = parse_escaped();

                    if (result1 === null) {
                      result1 = parse_UTF8_NONASCII();

                      if (result1 === null) {
                        result1 = parse_UTF8_CONT();

                        if (result1 === null) {
                          result1 = parse_SP();

                          if (result1 === null) {
                            result1 = parse_HTAB();
                          }
                        }
                      }
                    }
                  }
                }

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_reserved();

                  if (result1 === null) {
                    result1 = parse_unreserved();

                    if (result1 === null) {
                      result1 = parse_escaped();

                      if (result1 === null) {
                        result1 = parse_UTF8_NONASCII();

                        if (result1 === null) {
                          result1 = parse_UTF8_CONT();

                          if (result1 === null) {
                            result1 = parse_SP();

                            if (result1 === null) {
                              result1 = parse_HTAB();
                            }
                          }
                        }
                      }
                    }
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.reason_phrase = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Allow_Events() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_event_type();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_event_type();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_event_type();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Call_ID() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_word();

                if (result0 !== null) {
                  pos2 = pos;

                  if (input.charCodeAt(pos) === 64) {
                    result1 = "@";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_word();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Contact() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                result0 = parse_STAR();

                if (result0 === null) {
                  pos1 = pos;
                  result0 = parse_contact_param();

                  if (result0 !== null) {
                    result1 = [];
                    pos2 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_contact_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }

                    while (result2 !== null) {
                      result1.push(result2);
                      pos2 = pos;
                      result2 = parse_COMMA();

                      if (result2 !== null) {
                        result3 = parse_contact_param();

                        if (result3 !== null) {
                          result2 = [result2, result3];
                        } else {
                          result2 = null;
                          pos = pos2;
                        }
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    }

                    if (result1 !== null) {
                      result0 = [result0, result1];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var idx, length;
                    length = data.multi_header.length;

                    for (idx = 0; idx < length; idx++) {
                      if (data.multi_header[idx].parsed === null) {
                        data = null;
                        break;
                      }
                    }

                    if (data !== null) {
                      data = data.multi_header;
                    } else {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_contact_param() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SIP_URI_noparams();

                if (result0 === null) {
                  result0 = parse_name_addr();
                }

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_contact_params();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_contact_params();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var header;
                    if (!data.multi_header) data.multi_header = [];

                    try {
                      header = new NameAddrHeader(data.uri, data.display_name, data.params);
                      delete data.uri;
                      delete data.display_name;
                      delete data.params;
                    } catch (e) {
                      header = null;
                    }

                    data.multi_header.push({
                      'possition': pos,
                      'offset': offset,
                      'parsed': header
                    });
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_name_addr() {
                var result0, result1, result2, result3;
                var pos0;
                pos0 = pos;
                result0 = parse_display_name();
                result0 = result0 !== null ? result0 : "";

                if (result0 !== null) {
                  result1 = parse_LAQUOT();

                  if (result1 !== null) {
                    result2 = parse_SIP_URI();

                    if (result2 !== null) {
                      result3 = parse_RAQUOT();

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_display_name() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_LWS();

                  if (result2 !== null) {
                    result3 = parse_token();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_LWS();

                    if (result2 !== null) {
                      result3 = parse_token();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 === null) {
                  result0 = parse_quoted_string_clean();
                }

                if (result0 !== null) {
                  result0 = function (offset, display_name) {
                    if (typeof display_name === 'string') {
                      // quoted_string_clean
                      data.display_name = display_name;
                    } else {
                      // token ( LWS token )*
                      data.display_name = display_name[1].reduce(function (acc, cur) {
                        return acc + cur[0] + cur[1];
                      }, display_name[0]);
                    }
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_contact_params() {
                var result0;
                result0 = parse_c_p_q();

                if (result0 === null) {
                  result0 = parse_c_p_expires();

                  if (result0 === null) {
                    result0 = parse_generic_param();
                  }
                }

                return result0;
              }

              function parse_c_p_q() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 1).toLowerCase() === "q") {
                  result0 = input.substr(pos, 1);
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"q\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_qvalue();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, q) {
                    if (!data.params) data.params = {};
                    data.params['q'] = q;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_c_p_expires() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 7).toLowerCase() === "expires") {
                  result0 = input.substr(pos, 7);
                  pos += 7;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"expires\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_delta_seconds();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, expires) {
                    if (!data.params) data.params = {};
                    data.params['expires'] = expires;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_delta_seconds() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_DIGIT();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_DIGIT();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset, delta_seconds) {
                    return parseInt(delta_seconds.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_qvalue() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;

                if (input.charCodeAt(pos) === 48) {
                  result0 = "0";
                  pos++;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"0\"");
                  }
                }

                if (result0 !== null) {
                  pos2 = pos;

                  if (input.charCodeAt(pos) === 46) {
                    result1 = ".";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_DIGIT();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_DIGIT();
                      result3 = result3 !== null ? result3 : "";

                      if (result3 !== null) {
                        result4 = parse_DIGIT();
                        result4 = result4 !== null ? result4 : "";

                        if (result4 !== null) {
                          result1 = [result1, result2, result3, result4];
                        } else {
                          result1 = null;
                          pos = pos2;
                        }
                      } else {
                        result1 = null;
                        pos = pos2;
                      }
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    return parseFloat(input.substring(pos, offset));
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_generic_param() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  pos2 = pos;
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_gen_value();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, param, value) {
                    if (!data.params) data.params = {};

                    if (typeof value === 'undefined') {
                      value = undefined;
                    } else {
                      value = value[1];
                    }

                    data.params[param.toLowerCase()] = value;
                  }(pos0, result0[0], result0[1]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_gen_value() {
                var result0;
                result0 = parse_token();

                if (result0 === null) {
                  result0 = parse_host();

                  if (result0 === null) {
                    result0 = parse_quoted_string();
                  }
                }

                return result0;
              }

              function parse_Content_Disposition() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_disp_type();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_disp_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_disp_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_disp_type() {
                var result0;

                if (input.substr(pos, 6).toLowerCase() === "render") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"render\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 7).toLowerCase() === "session") {
                    result0 = input.substr(pos, 7);
                    pos += 7;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"session\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.substr(pos, 4).toLowerCase() === "icon") {
                      result0 = input.substr(pos, 4);
                      pos += 4;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"icon\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.substr(pos, 5).toLowerCase() === "alert") {
                        result0 = input.substr(pos, 5);
                        pos += 5;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"alert\"");
                        }
                      }

                      if (result0 === null) {
                        result0 = parse_token();
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_disp_param() {
                var result0;
                result0 = parse_handling_param();

                if (result0 === null) {
                  result0 = parse_generic_param();
                }

                return result0;
              }

              function parse_handling_param() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 8).toLowerCase() === "handling") {
                  result0 = input.substr(pos, 8);
                  pos += 8;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"handling\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    if (input.substr(pos, 8).toLowerCase() === "optional") {
                      result2 = input.substr(pos, 8);
                      pos += 8;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"optional\"");
                      }
                    }

                    if (result2 === null) {
                      if (input.substr(pos, 8).toLowerCase() === "required") {
                        result2 = input.substr(pos, 8);
                        pos += 8;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"required\"");
                        }
                      }

                      if (result2 === null) {
                        result2 = parse_token();
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Content_Encoding() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_token();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_token();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Content_Length() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_DIGIT();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_DIGIT();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset, length) {
                    data = parseInt(length.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Content_Type() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_media_type();

                if (result0 !== null) {
                  result0 = function (offset) {
                    data = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_media_type() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_m_type();

                if (result0 !== null) {
                  result1 = parse_SLASH();

                  if (result1 !== null) {
                    result2 = parse_m_subtype();

                    if (result2 !== null) {
                      result3 = [];
                      pos1 = pos;
                      result4 = parse_SEMI();

                      if (result4 !== null) {
                        result5 = parse_m_parameter();

                        if (result5 !== null) {
                          result4 = [result4, result5];
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      } else {
                        result4 = null;
                        pos = pos1;
                      }

                      while (result4 !== null) {
                        result3.push(result4);
                        pos1 = pos;
                        result4 = parse_SEMI();

                        if (result4 !== null) {
                          result5 = parse_m_parameter();

                          if (result5 !== null) {
                            result4 = [result4, result5];
                          } else {
                            result4 = null;
                            pos = pos1;
                          }
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      }

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_m_type() {
                var result0;
                result0 = parse_discrete_type();

                if (result0 === null) {
                  result0 = parse_composite_type();
                }

                return result0;
              }

              function parse_discrete_type() {
                var result0;

                if (input.substr(pos, 4).toLowerCase() === "text") {
                  result0 = input.substr(pos, 4);
                  pos += 4;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"text\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 5).toLowerCase() === "image") {
                    result0 = input.substr(pos, 5);
                    pos += 5;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"image\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.substr(pos, 5).toLowerCase() === "audio") {
                      result0 = input.substr(pos, 5);
                      pos += 5;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"audio\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.substr(pos, 5).toLowerCase() === "video") {
                        result0 = input.substr(pos, 5);
                        pos += 5;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"video\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.substr(pos, 11).toLowerCase() === "application") {
                          result0 = input.substr(pos, 11);
                          pos += 11;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"application\"");
                          }
                        }

                        if (result0 === null) {
                          result0 = parse_extension_token();
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_composite_type() {
                var result0;

                if (input.substr(pos, 7).toLowerCase() === "message") {
                  result0 = input.substr(pos, 7);
                  pos += 7;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"message\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 9).toLowerCase() === "multipart") {
                    result0 = input.substr(pos, 9);
                    pos += 9;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"multipart\"");
                    }
                  }

                  if (result0 === null) {
                    result0 = parse_extension_token();
                  }
                }

                return result0;
              }

              function parse_extension_token() {
                var result0;
                result0 = parse_token();

                if (result0 === null) {
                  result0 = parse_x_token();
                }

                return result0;
              }

              function parse_x_token() {
                var result0, result1;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 2).toLowerCase() === "x-") {
                  result0 = input.substr(pos, 2);
                  pos += 2;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"x-\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_token();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_m_subtype() {
                var result0;
                result0 = parse_extension_token();

                if (result0 === null) {
                  result0 = parse_token();
                }

                return result0;
              }

              function parse_m_parameter() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_m_value();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_m_value() {
                var result0;
                result0 = parse_token();

                if (result0 === null) {
                  result0 = parse_quoted_string();
                }

                return result0;
              }

              function parse_CSeq() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_CSeq_value();

                if (result0 !== null) {
                  result1 = parse_LWS();

                  if (result1 !== null) {
                    result2 = parse_Method();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_CSeq_value() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_DIGIT();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_DIGIT();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset, cseq_value) {
                    data.value = parseInt(cseq_value.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Expires() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_delta_seconds();

                if (result0 !== null) {
                  result0 = function (offset, expires) {
                    data = expires;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Event() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_event_type();

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_generic_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_generic_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, event_type) {
                    data.event = event_type.join('').toLowerCase();
                  }(pos0, result0[0]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_event_type() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_token_nodot();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;

                  if (input.charCodeAt(pos) === 46) {
                    result2 = ".";
                    pos++;
                  } else {
                    result2 = null;

                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }

                  if (result2 !== null) {
                    result3 = parse_token_nodot();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;

                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }

                    if (result2 !== null) {
                      result3 = parse_token_nodot();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_From() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SIP_URI_noparams();

                if (result0 === null) {
                  result0 = parse_name_addr();
                }

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_from_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_from_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var tag = data.tag;

                    try {
                      data = new NameAddrHeader(data.uri, data.display_name, data.params);

                      if (tag) {
                        data.setParam('tag', tag);
                      }
                    } catch (e) {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_from_param() {
                var result0;
                result0 = parse_tag_param();

                if (result0 === null) {
                  result0 = parse_generic_param();
                }

                return result0;
              }

              function parse_tag_param() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 3).toLowerCase() === "tag") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"tag\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, tag) {
                    data.tag = tag;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Max_Forwards() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result1 = parse_DIGIT();

                if (result1 !== null) {
                  result0 = [];

                  while (result1 !== null) {
                    result0.push(result1);
                    result1 = parse_DIGIT();
                  }
                } else {
                  result0 = null;
                }

                if (result0 !== null) {
                  result0 = function (offset, forwards) {
                    data = parseInt(forwards.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Min_Expires() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_delta_seconds();

                if (result0 !== null) {
                  result0 = function (offset, min_expires) {
                    data = min_expires;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Name_Addr_Header() {
                var result0, result1, result2, result3, result4, result5, result6;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = [];
                result1 = parse_display_name();

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_display_name();
                }

                if (result0 !== null) {
                  result1 = parse_LAQUOT();

                  if (result1 !== null) {
                    result2 = parse_SIP_URI();

                    if (result2 !== null) {
                      result3 = parse_RAQUOT();

                      if (result3 !== null) {
                        result4 = [];
                        pos2 = pos;
                        result5 = parse_SEMI();

                        if (result5 !== null) {
                          result6 = parse_generic_param();

                          if (result6 !== null) {
                            result5 = [result5, result6];
                          } else {
                            result5 = null;
                            pos = pos2;
                          }
                        } else {
                          result5 = null;
                          pos = pos2;
                        }

                        while (result5 !== null) {
                          result4.push(result5);
                          pos2 = pos;
                          result5 = parse_SEMI();

                          if (result5 !== null) {
                            result6 = parse_generic_param();

                            if (result6 !== null) {
                              result5 = [result5, result6];
                            } else {
                              result5 = null;
                              pos = pos2;
                            }
                          } else {
                            result5 = null;
                            pos = pos2;
                          }
                        }

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    try {
                      data = new NameAddrHeader(data.uri, data.display_name, data.params);
                    } catch (e) {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Proxy_Authenticate() {
                var result0;
                result0 = parse_challenge();
                return result0;
              }

              function parse_challenge() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;

                if (input.substr(pos, 6).toLowerCase() === "digest") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"Digest\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_LWS();

                  if (result1 !== null) {
                    result2 = parse_digest_cln();

                    if (result2 !== null) {
                      result3 = [];
                      pos1 = pos;
                      result4 = parse_COMMA();

                      if (result4 !== null) {
                        result5 = parse_digest_cln();

                        if (result5 !== null) {
                          result4 = [result4, result5];
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      } else {
                        result4 = null;
                        pos = pos1;
                      }

                      while (result4 !== null) {
                        result3.push(result4);
                        pos1 = pos;
                        result4 = parse_COMMA();

                        if (result4 !== null) {
                          result5 = parse_digest_cln();

                          if (result5 !== null) {
                            result4 = [result4, result5];
                          } else {
                            result4 = null;
                            pos = pos1;
                          }
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      }

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                if (result0 === null) {
                  result0 = parse_other_challenge();
                }

                return result0;
              }

              function parse_other_challenge() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = parse_LWS();

                  if (result1 !== null) {
                    result2 = parse_auth_param();

                    if (result2 !== null) {
                      result3 = [];
                      pos1 = pos;
                      result4 = parse_COMMA();

                      if (result4 !== null) {
                        result5 = parse_auth_param();

                        if (result5 !== null) {
                          result4 = [result4, result5];
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      } else {
                        result4 = null;
                        pos = pos1;
                      }

                      while (result4 !== null) {
                        result3.push(result4);
                        pos1 = pos;
                        result4 = parse_COMMA();

                        if (result4 !== null) {
                          result5 = parse_auth_param();

                          if (result5 !== null) {
                            result4 = [result4, result5];
                          } else {
                            result4 = null;
                            pos = pos1;
                          }
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      }

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_auth_param() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 === null) {
                      result2 = parse_quoted_string();
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_digest_cln() {
                var result0;
                result0 = parse_realm();

                if (result0 === null) {
                  result0 = parse_domain();

                  if (result0 === null) {
                    result0 = parse_nonce();

                    if (result0 === null) {
                      result0 = parse_opaque();

                      if (result0 === null) {
                        result0 = parse_stale();

                        if (result0 === null) {
                          result0 = parse_algorithm();

                          if (result0 === null) {
                            result0 = parse_qop_options();

                            if (result0 === null) {
                              result0 = parse_auth_param();
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_realm() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 5).toLowerCase() === "realm") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"realm\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_realm_value();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_realm_value() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_quoted_string_clean();

                if (result0 !== null) {
                  result0 = function (offset, realm) {
                    data.realm = realm;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_domain() {
                var result0, result1, result2, result3, result4, result5, result6;
                var pos0, pos1;
                pos0 = pos;

                if (input.substr(pos, 6).toLowerCase() === "domain") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"domain\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_LDQUOT();

                    if (result2 !== null) {
                      result3 = parse_URI();

                      if (result3 !== null) {
                        result4 = [];
                        pos1 = pos;
                        result6 = parse_SP();

                        if (result6 !== null) {
                          result5 = [];

                          while (result6 !== null) {
                            result5.push(result6);
                            result6 = parse_SP();
                          }
                        } else {
                          result5 = null;
                        }

                        if (result5 !== null) {
                          result6 = parse_URI();

                          if (result6 !== null) {
                            result5 = [result5, result6];
                          } else {
                            result5 = null;
                            pos = pos1;
                          }
                        } else {
                          result5 = null;
                          pos = pos1;
                        }

                        while (result5 !== null) {
                          result4.push(result5);
                          pos1 = pos;
                          result6 = parse_SP();

                          if (result6 !== null) {
                            result5 = [];

                            while (result6 !== null) {
                              result5.push(result6);
                              result6 = parse_SP();
                            }
                          } else {
                            result5 = null;
                          }

                          if (result5 !== null) {
                            result6 = parse_URI();

                            if (result6 !== null) {
                              result5 = [result5, result6];
                            } else {
                              result5 = null;
                              pos = pos1;
                            }
                          } else {
                            result5 = null;
                            pos = pos1;
                          }
                        }

                        if (result4 !== null) {
                          result5 = parse_RDQUOT();

                          if (result5 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5];
                          } else {
                            result0 = null;
                            pos = pos0;
                          }
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_URI() {
                var result0;
                result0 = parse_absoluteURI();

                if (result0 === null) {
                  result0 = parse_abs_path();
                }

                return result0;
              }

              function parse_nonce() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 5).toLowerCase() === "nonce") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"nonce\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_nonce_value();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_nonce_value() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_quoted_string_clean();

                if (result0 !== null) {
                  result0 = function (offset, nonce) {
                    data.nonce = nonce;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_opaque() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 6).toLowerCase() === "opaque") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"opaque\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_quoted_string_clean();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, opaque) {
                    data.opaque = opaque;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_stale() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;

                if (input.substr(pos, 5).toLowerCase() === "stale") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"stale\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    pos1 = pos;

                    if (input.substr(pos, 4).toLowerCase() === "true") {
                      result2 = input.substr(pos, 4);
                      pos += 4;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"true\"");
                      }
                    }

                    if (result2 !== null) {
                      result2 = function (offset) {
                        data.stale = true;
                      }(pos1);
                    }

                    if (result2 === null) {
                      pos = pos1;
                    }

                    if (result2 === null) {
                      pos1 = pos;

                      if (input.substr(pos, 5).toLowerCase() === "false") {
                        result2 = input.substr(pos, 5);
                        pos += 5;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"false\"");
                        }
                      }

                      if (result2 !== null) {
                        result2 = function (offset) {
                          data.stale = false;
                        }(pos1);
                      }

                      if (result2 === null) {
                        pos = pos1;
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_algorithm() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 9).toLowerCase() === "algorithm") {
                  result0 = input.substr(pos, 9);
                  pos += 9;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"algorithm\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    if (input.substr(pos, 3).toLowerCase() === "md5") {
                      result2 = input.substr(pos, 3);
                      pos += 3;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"MD5\"");
                      }
                    }

                    if (result2 === null) {
                      if (input.substr(pos, 8).toLowerCase() === "md5-sess") {
                        result2 = input.substr(pos, 8);
                        pos += 8;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"MD5-sess\"");
                        }
                      }

                      if (result2 === null) {
                        result2 = parse_token();
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, algorithm) {
                    data.algorithm = algorithm.toUpperCase();
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_qop_options() {
                var result0, result1, result2, result3, result4, result5, result6;
                var pos0, pos1, pos2;
                pos0 = pos;

                if (input.substr(pos, 3).toLowerCase() === "qop") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"qop\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_LDQUOT();

                    if (result2 !== null) {
                      pos1 = pos;
                      result3 = parse_qop_value();

                      if (result3 !== null) {
                        result4 = [];
                        pos2 = pos;

                        if (input.charCodeAt(pos) === 44) {
                          result5 = ",";
                          pos++;
                        } else {
                          result5 = null;

                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }

                        if (result5 !== null) {
                          result6 = parse_qop_value();

                          if (result6 !== null) {
                            result5 = [result5, result6];
                          } else {
                            result5 = null;
                            pos = pos2;
                          }
                        } else {
                          result5 = null;
                          pos = pos2;
                        }

                        while (result5 !== null) {
                          result4.push(result5);
                          pos2 = pos;

                          if (input.charCodeAt(pos) === 44) {
                            result5 = ",";
                            pos++;
                          } else {
                            result5 = null;

                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }

                          if (result5 !== null) {
                            result6 = parse_qop_value();

                            if (result6 !== null) {
                              result5 = [result5, result6];
                            } else {
                              result5 = null;
                              pos = pos2;
                            }
                          } else {
                            result5 = null;
                            pos = pos2;
                          }
                        }

                        if (result4 !== null) {
                          result3 = [result3, result4];
                        } else {
                          result3 = null;
                          pos = pos1;
                        }
                      } else {
                        result3 = null;
                        pos = pos1;
                      }

                      if (result3 !== null) {
                        result4 = parse_RDQUOT();

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_qop_value() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 8).toLowerCase() === "auth-int") {
                  result0 = input.substr(pos, 8);
                  pos += 8;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"auth-int\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 4).toLowerCase() === "auth") {
                    result0 = input.substr(pos, 4);
                    pos += 4;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"auth\"");
                    }
                  }

                  if (result0 === null) {
                    result0 = parse_token();
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset, qop_value) {
                    data.qop || (data.qop = []);
                    data.qop.push(qop_value.toLowerCase());
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Proxy_Require() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_token();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_token();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Record_Route() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_rec_route();

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_rec_route();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_rec_route();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var idx, length;
                    length = data.multi_header.length;

                    for (idx = 0; idx < length; idx++) {
                      if (data.multi_header[idx].parsed === null) {
                        data = null;
                        break;
                      }
                    }

                    if (data !== null) {
                      data = data.multi_header;
                    } else {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_rec_route() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_name_addr();

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_generic_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_generic_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var header;
                    if (!data.multi_header) data.multi_header = [];

                    try {
                      header = new NameAddrHeader(data.uri, data.display_name, data.params);
                      delete data.uri;
                      delete data.display_name;
                      delete data.params;
                    } catch (e) {
                      header = null;
                    }

                    data.multi_header.push({
                      'possition': pos,
                      'offset': offset,
                      'parsed': header
                    });
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Reason() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 3).toLowerCase() === "sip") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"SIP\"");
                  }
                }

                if (result0 === null) {
                  result0 = parse_token();
                }

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_reason_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_reason_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, protocol) {
                    data.protocol = protocol.toLowerCase();
                    if (!data.params) data.params = {};

                    if (data.params.text && data.params.text[0] === '"') {
                      var text = data.params.text;
                      data.text = text.substring(1, text.length - 1);
                      delete data.params.text;
                    }
                  }(pos0, result0[0]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_reason_param() {
                var result0;
                result0 = parse_reason_cause();

                if (result0 === null) {
                  result0 = parse_generic_param();
                }

                return result0;
              }

              function parse_reason_cause() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 5).toLowerCase() === "cause") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"cause\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result3 = parse_DIGIT();

                    if (result3 !== null) {
                      result2 = [];

                      while (result3 !== null) {
                        result2.push(result3);
                        result3 = parse_DIGIT();
                      }
                    } else {
                      result2 = null;
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, cause) {
                    data.cause = parseInt(cause.join(''));
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Require() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_token();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_token();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Route() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_route_param();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_route_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_route_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_route_param() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_name_addr();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_generic_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_generic_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Subscription_State() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_substate_value();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_subexp_params();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_subexp_params();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_substate_value() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 6).toLowerCase() === "active") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"active\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 7).toLowerCase() === "pending") {
                    result0 = input.substr(pos, 7);
                    pos += 7;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"pending\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.substr(pos, 10).toLowerCase() === "terminated") {
                      result0 = input.substr(pos, 10);
                      pos += 10;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"terminated\"");
                      }
                    }

                    if (result0 === null) {
                      result0 = parse_token();
                    }
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.state = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_subexp_params() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 6).toLowerCase() === "reason") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"reason\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_event_reason_value();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, reason) {
                    if (typeof reason !== 'undefined') data.reason = reason;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                if (result0 === null) {
                  pos0 = pos;
                  pos1 = pos;

                  if (input.substr(pos, 7).toLowerCase() === "expires") {
                    result0 = input.substr(pos, 7);
                    pos += 7;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"expires\"");
                    }
                  }

                  if (result0 !== null) {
                    result1 = parse_EQUAL();

                    if (result1 !== null) {
                      result2 = parse_delta_seconds();

                      if (result2 !== null) {
                        result0 = [result0, result1, result2];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }

                  if (result0 !== null) {
                    result0 = function (offset, expires) {
                      if (typeof expires !== 'undefined') data.expires = expires;
                    }(pos0, result0[2]);
                  }

                  if (result0 === null) {
                    pos = pos0;
                  }

                  if (result0 === null) {
                    pos0 = pos;
                    pos1 = pos;

                    if (input.substr(pos, 11).toLowerCase() === "retry_after") {
                      result0 = input.substr(pos, 11);
                      pos += 11;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"retry_after\"");
                      }
                    }

                    if (result0 !== null) {
                      result1 = parse_EQUAL();

                      if (result1 !== null) {
                        result2 = parse_delta_seconds();

                        if (result2 !== null) {
                          result0 = [result0, result1, result2];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }

                    if (result0 !== null) {
                      result0 = function (offset, retry_after) {
                        if (typeof retry_after !== 'undefined') data.retry_after = retry_after;
                      }(pos0, result0[2]);
                    }

                    if (result0 === null) {
                      pos = pos0;
                    }

                    if (result0 === null) {
                      result0 = parse_generic_param();
                    }
                  }
                }

                return result0;
              }

              function parse_event_reason_value() {
                var result0;

                if (input.substr(pos, 11).toLowerCase() === "deactivated") {
                  result0 = input.substr(pos, 11);
                  pos += 11;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"deactivated\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 9).toLowerCase() === "probation") {
                    result0 = input.substr(pos, 9);
                    pos += 9;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"probation\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.substr(pos, 8).toLowerCase() === "rejected") {
                      result0 = input.substr(pos, 8);
                      pos += 8;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"rejected\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.substr(pos, 7).toLowerCase() === "timeout") {
                        result0 = input.substr(pos, 7);
                        pos += 7;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"timeout\"");
                        }
                      }

                      if (result0 === null) {
                        if (input.substr(pos, 6).toLowerCase() === "giveup") {
                          result0 = input.substr(pos, 6);
                          pos += 6;
                        } else {
                          result0 = null;

                          if (reportFailures === 0) {
                            matchFailed("\"giveup\"");
                          }
                        }

                        if (result0 === null) {
                          if (input.substr(pos, 10).toLowerCase() === "noresource") {
                            result0 = input.substr(pos, 10);
                            pos += 10;
                          } else {
                            result0 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"noresource\"");
                            }
                          }

                          if (result0 === null) {
                            if (input.substr(pos, 9).toLowerCase() === "invariant") {
                              result0 = input.substr(pos, 9);
                              pos += 9;
                            } else {
                              result0 = null;

                              if (reportFailures === 0) {
                                matchFailed("\"invariant\"");
                              }
                            }

                            if (result0 === null) {
                              result0 = parse_token();
                            }
                          }
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_Subject() {
                var result0;
                result0 = parse_TEXT_UTF8_TRIM();
                result0 = result0 !== null ? result0 : "";
                return result0;
              }

              function parse_Supported() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_token();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_token();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                result0 = result0 !== null ? result0 : "";
                return result0;
              }

              function parse_To() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SIP_URI_noparams();

                if (result0 === null) {
                  result0 = parse_name_addr();
                }

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_to_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_to_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    var tag = data.tag;

                    try {
                      data = new NameAddrHeader(data.uri, data.display_name, data.params);

                      if (tag) {
                        data.setParam('tag', tag);
                      }
                    } catch (e) {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_to_param() {
                var result0;
                result0 = parse_tag_param();

                if (result0 === null) {
                  result0 = parse_generic_param();
                }

                return result0;
              }

              function parse_Via() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_via_param();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_COMMA();

                  if (result2 !== null) {
                    result3 = parse_via_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_COMMA();

                    if (result2 !== null) {
                      result3 = parse_via_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_param() {
                var result0, result1, result2, result3, result4, result5;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_sent_protocol();

                if (result0 !== null) {
                  result1 = parse_LWS();

                  if (result1 !== null) {
                    result2 = parse_sent_by();

                    if (result2 !== null) {
                      result3 = [];
                      pos1 = pos;
                      result4 = parse_SEMI();

                      if (result4 !== null) {
                        result5 = parse_via_params();

                        if (result5 !== null) {
                          result4 = [result4, result5];
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      } else {
                        result4 = null;
                        pos = pos1;
                      }

                      while (result4 !== null) {
                        result3.push(result4);
                        pos1 = pos;
                        result4 = parse_SEMI();

                        if (result4 !== null) {
                          result5 = parse_via_params();

                          if (result5 !== null) {
                            result4 = [result4, result5];
                          } else {
                            result4 = null;
                            pos = pos1;
                          }
                        } else {
                          result4 = null;
                          pos = pos1;
                        }
                      }

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_params() {
                var result0;
                result0 = parse_via_ttl();

                if (result0 === null) {
                  result0 = parse_via_maddr();

                  if (result0 === null) {
                    result0 = parse_via_received();

                    if (result0 === null) {
                      result0 = parse_via_branch();

                      if (result0 === null) {
                        result0 = parse_response_port();

                        if (result0 === null) {
                          result0 = parse_generic_param();
                        }
                      }
                    }
                  }
                }

                return result0;
              }

              function parse_via_ttl() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 3).toLowerCase() === "ttl") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"ttl\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_ttl();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, via_ttl_value) {
                    data.ttl = via_ttl_value;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_maddr() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 5).toLowerCase() === "maddr") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"maddr\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_host();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, via_maddr) {
                    data.maddr = via_maddr;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_received() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 8).toLowerCase() === "received") {
                  result0 = input.substr(pos, 8);
                  pos += 8;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"received\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_IPv4address();

                    if (result2 === null) {
                      result2 = parse_IPv6address();
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, via_received) {
                    data.received = via_received;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_branch() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 6).toLowerCase() === "branch") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"branch\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, via_branch) {
                    data.branch = via_branch;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_response_port() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;

                if (input.substr(pos, 5).toLowerCase() === "rport") {
                  result0 = input.substr(pos, 5);
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"rport\"");
                  }
                }

                if (result0 !== null) {
                  pos1 = pos;
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_rport();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos1;
                    }
                  } else {
                    result1 = null;
                    pos = pos1;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_rport() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_DIGIT();
                result0 = result0 !== null ? result0 : "";

                if (result0 !== null) {
                  result1 = parse_DIGIT();
                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result2 = parse_DIGIT();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_DIGIT();
                      result3 = result3 !== null ? result3 : "";

                      if (result3 !== null) {
                        result4 = parse_DIGIT();
                        result4 = result4 !== null ? result4 : "";

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, rport) {
                    data.rport = parseInt(rport.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_sent_protocol() {
                var result0, result1, result2, result3, result4;
                var pos0;
                pos0 = pos;
                result0 = parse_protocol_name();

                if (result0 !== null) {
                  result1 = parse_SLASH();

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 !== null) {
                      result3 = parse_SLASH();

                      if (result3 !== null) {
                        result4 = parse_transport();

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos0;
                        }
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_protocol_name() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 3).toLowerCase() === "sip") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"SIP\"");
                  }
                }

                if (result0 === null) {
                  result0 = parse_token();
                }

                if (result0 !== null) {
                  result0 = function (offset, via_protocol) {
                    data.protocol = via_protocol;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_transport() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 3).toLowerCase() === "udp") {
                  result0 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"UDP\"");
                  }
                }

                if (result0 === null) {
                  if (input.substr(pos, 3).toLowerCase() === "tcp") {
                    result0 = input.substr(pos, 3);
                    pos += 3;
                  } else {
                    result0 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"TCP\"");
                    }
                  }

                  if (result0 === null) {
                    if (input.substr(pos, 3).toLowerCase() === "tls") {
                      result0 = input.substr(pos, 3);
                      pos += 3;
                    } else {
                      result0 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"TLS\"");
                      }
                    }

                    if (result0 === null) {
                      if (input.substr(pos, 4).toLowerCase() === "sctp") {
                        result0 = input.substr(pos, 4);
                        pos += 4;
                      } else {
                        result0 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"SCTP\"");
                        }
                      }

                      if (result0 === null) {
                        result0 = parse_token();
                      }
                    }
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset, via_transport) {
                    data.transport = via_transport;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_sent_by() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_via_host();

                if (result0 !== null) {
                  pos1 = pos;
                  result1 = parse_COLON();

                  if (result1 !== null) {
                    result2 = parse_via_port();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos1;
                    }
                  } else {
                    result1 = null;
                    pos = pos1;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_host() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_IPv4address();

                if (result0 === null) {
                  result0 = parse_IPv6reference();

                  if (result0 === null) {
                    result0 = parse_hostname();
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.host = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_via_port() {
                var result0, result1, result2, result3, result4;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_DIGIT();
                result0 = result0 !== null ? result0 : "";

                if (result0 !== null) {
                  result1 = parse_DIGIT();
                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result2 = parse_DIGIT();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result3 = parse_DIGIT();
                      result3 = result3 !== null ? result3 : "";

                      if (result3 !== null) {
                        result4 = parse_DIGIT();
                        result4 = result4 !== null ? result4 : "";

                        if (result4 !== null) {
                          result0 = [result0, result1, result2, result3, result4];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, via_sent_by_port) {
                    data.port = parseInt(via_sent_by_port.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_ttl() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_DIGIT();

                if (result0 !== null) {
                  result1 = parse_DIGIT();
                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result2 = parse_DIGIT();
                    result2 = result2 !== null ? result2 : "";

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, ttl) {
                    return parseInt(ttl.join(''));
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_WWW_Authenticate() {
                var result0;
                result0 = parse_challenge();
                return result0;
              }

              function parse_Session_Expires() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_s_e_expires();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_s_e_params();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_s_e_params();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_s_e_expires() {
                var result0;
                var pos0;
                pos0 = pos;
                result0 = parse_delta_seconds();

                if (result0 !== null) {
                  result0 = function (offset, expires) {
                    data.expires = expires;
                  }(pos0, result0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_s_e_params() {
                var result0;
                result0 = parse_s_e_refresher();

                if (result0 === null) {
                  result0 = parse_generic_param();
                }

                return result0;
              }

              function parse_s_e_refresher() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 9).toLowerCase() === "refresher") {
                  result0 = input.substr(pos, 9);
                  pos += 9;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"refresher\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    if (input.substr(pos, 3).toLowerCase() === "uac") {
                      result2 = input.substr(pos, 3);
                      pos += 3;
                    } else {
                      result2 = null;

                      if (reportFailures === 0) {
                        matchFailed("\"uac\"");
                      }
                    }

                    if (result2 === null) {
                      if (input.substr(pos, 3).toLowerCase() === "uas") {
                        result2 = input.substr(pos, 3);
                        pos += 3;
                      } else {
                        result2 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"uas\"");
                        }
                      }
                    }

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, s_e_refresher_value) {
                    data.refresher = s_e_refresher_value.toLowerCase();
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_extension_header() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_token();

                if (result0 !== null) {
                  result1 = parse_HCOLON();

                  if (result1 !== null) {
                    result2 = parse_header_value();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_header_value() {
                var result0, result1;
                result0 = [];
                result1 = parse_TEXT_UTF8char();

                if (result1 === null) {
                  result1 = parse_UTF8_CONT();

                  if (result1 === null) {
                    result1 = parse_LWS();
                  }
                }

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_TEXT_UTF8char();

                  if (result1 === null) {
                    result1 = parse_UTF8_CONT();

                    if (result1 === null) {
                      result1 = parse_LWS();
                    }
                  }
                }

                return result0;
              }

              function parse_message_body() {
                var result0, result1;
                result0 = [];
                result1 = parse_OCTET();

                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_OCTET();
                }

                return result0;
              }

              function parse_uuid_URI() {
                var result0, result1;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 5) === "uuid:") {
                  result0 = "uuid:";
                  pos += 5;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"uuid:\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_uuid();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_uuid() {
                var result0, result1, result2, result3, result4, result5, result6, result7, result8;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_hex8();

                if (result0 !== null) {
                  if (input.charCodeAt(pos) === 45) {
                    result1 = "-";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_hex4();

                    if (result2 !== null) {
                      if (input.charCodeAt(pos) === 45) {
                        result3 = "-";
                        pos++;
                      } else {
                        result3 = null;

                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }

                      if (result3 !== null) {
                        result4 = parse_hex4();

                        if (result4 !== null) {
                          if (input.charCodeAt(pos) === 45) {
                            result5 = "-";
                            pos++;
                          } else {
                            result5 = null;

                            if (reportFailures === 0) {
                              matchFailed("\"-\"");
                            }
                          }

                          if (result5 !== null) {
                            result6 = parse_hex4();

                            if (result6 !== null) {
                              if (input.charCodeAt(pos) === 45) {
                                result7 = "-";
                                pos++;
                              } else {
                                result7 = null;

                                if (reportFailures === 0) {
                                  matchFailed("\"-\"");
                                }
                              }

                              if (result7 !== null) {
                                result8 = parse_hex12();

                                if (result8 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, uuid) {
                    data = input.substring(pos + 5, offset);
                  }(pos0, result0[0]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_hex4() {
                var result0, result1, result2, result3;
                var pos0;
                pos0 = pos;
                result0 = parse_HEXDIG();

                if (result0 !== null) {
                  result1 = parse_HEXDIG();

                  if (result1 !== null) {
                    result2 = parse_HEXDIG();

                    if (result2 !== null) {
                      result3 = parse_HEXDIG();

                      if (result3 !== null) {
                        result0 = [result0, result1, result2, result3];
                      } else {
                        result0 = null;
                        pos = pos0;
                      }
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_hex8() {
                var result0, result1;
                var pos0;
                pos0 = pos;
                result0 = parse_hex4();

                if (result0 !== null) {
                  result1 = parse_hex4();

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_hex12() {
                var result0, result1, result2;
                var pos0;
                pos0 = pos;
                result0 = parse_hex4();

                if (result0 !== null) {
                  result1 = parse_hex4();

                  if (result1 !== null) {
                    result2 = parse_hex4();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos0;
                    }
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_Refer_To() {
                var result0, result1, result2, result3;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_SIP_URI_noparams();

                if (result0 === null) {
                  result0 = parse_name_addr();
                }

                if (result0 !== null) {
                  result1 = [];
                  pos2 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_generic_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos2 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_generic_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    try {
                      data = new NameAddrHeader(data.uri, data.display_name, data.params);
                    } catch (e) {
                      data = -1;
                    }
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_Replaces() {
                var result0, result1, result2, result3;
                var pos0, pos1;
                pos0 = pos;
                result0 = parse_call_id();

                if (result0 !== null) {
                  result1 = [];
                  pos1 = pos;
                  result2 = parse_SEMI();

                  if (result2 !== null) {
                    result3 = parse_replaces_param();

                    if (result3 !== null) {
                      result2 = [result2, result3];
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  } else {
                    result2 = null;
                    pos = pos1;
                  }

                  while (result2 !== null) {
                    result1.push(result2);
                    pos1 = pos;
                    result2 = parse_SEMI();

                    if (result2 !== null) {
                      result3 = parse_replaces_param();

                      if (result3 !== null) {
                        result2 = [result2, result3];
                      } else {
                        result2 = null;
                        pos = pos1;
                      }
                    } else {
                      result2 = null;
                      pos = pos1;
                    }
                  }

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }

                return result0;
              }

              function parse_call_id() {
                var result0, result1, result2;
                var pos0, pos1, pos2;
                pos0 = pos;
                pos1 = pos;
                result0 = parse_word();

                if (result0 !== null) {
                  pos2 = pos;

                  if (input.charCodeAt(pos) === 64) {
                    result1 = "@";
                    pos++;
                  } else {
                    result1 = null;

                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }

                  if (result1 !== null) {
                    result2 = parse_word();

                    if (result2 !== null) {
                      result1 = [result1, result2];
                    } else {
                      result1 = null;
                      pos = pos2;
                    }
                  } else {
                    result1 = null;
                    pos = pos2;
                  }

                  result1 = result1 !== null ? result1 : "";

                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.call_id = input.substring(pos, offset);
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_replaces_param() {
                var result0;
                result0 = parse_to_tag();

                if (result0 === null) {
                  result0 = parse_from_tag();

                  if (result0 === null) {
                    result0 = parse_early_flag();

                    if (result0 === null) {
                      result0 = parse_generic_param();
                    }
                  }
                }

                return result0;
              }

              function parse_to_tag() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 6) === "to-tag") {
                  result0 = "to-tag";
                  pos += 6;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"to-tag\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, to_tag) {
                    data.to_tag = to_tag;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_from_tag() {
                var result0, result1, result2;
                var pos0, pos1;
                pos0 = pos;
                pos1 = pos;

                if (input.substr(pos, 8) === "from-tag") {
                  result0 = "from-tag";
                  pos += 8;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"from-tag\"");
                  }
                }

                if (result0 !== null) {
                  result1 = parse_EQUAL();

                  if (result1 !== null) {
                    result2 = parse_token();

                    if (result2 !== null) {
                      result0 = [result0, result1, result2];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }

                if (result0 !== null) {
                  result0 = function (offset, from_tag) {
                    data.from_tag = from_tag;
                  }(pos0, result0[2]);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function parse_early_flag() {
                var result0;
                var pos0;
                pos0 = pos;

                if (input.substr(pos, 10) === "early-only") {
                  result0 = "early-only";
                  pos += 10;
                } else {
                  result0 = null;

                  if (reportFailures === 0) {
                    matchFailed("\"early-only\"");
                  }
                }

                if (result0 !== null) {
                  result0 = function (offset) {
                    data.early_only = true;
                  }(pos0);
                }

                if (result0 === null) {
                  pos = pos0;
                }

                return result0;
              }

              function cleanupExpected(expected) {
                expected.sort();
                var lastExpected = null;
                var cleanExpected = [];

                for (var i = 0; i < expected.length; i++) {
                  if (expected[i] !== lastExpected) {
                    cleanExpected.push(expected[i]);
                    lastExpected = expected[i];
                  }
                }

                return cleanExpected;
              }

              function computeErrorPosition() {
                /*
                 * The first idea was to use |String.split| to break the input up to the
                 * error position along newlines and derive the line and column from
                 * there. However IE's |split| implementation is so broken that it was
                 * enough to prevent it.
                 */
                var line = 1;
                var column = 1;
                var seenCR = false;

                for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
                  var ch = input.charAt(i);

                  if (ch === "\n") {
                    if (!seenCR) {
                      line++;
                    }

                    column = 1;
                    seenCR = false;
                  } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                    line++;
                    column = 1;
                    seenCR = true;
                  } else {
                    column++;
                    seenCR = false;
                  }
                }

                return {
                  line: line,
                  column: column
                };
              }

              var URI = __webpack_require__(9);

              var NameAddrHeader = __webpack_require__(11);

              var data = {};
              var result = parseFunctions[startRule]();
              /*
               * The parser is now in one of the following three states:
               *
               * 1. The parser successfully parsed the whole input.
               *
               *    - |result !== null|
               *    - |pos === input.length|
               *    - |rightmostFailuresExpected| may or may not contain something
               *
               * 2. The parser successfully parsed only a part of the input.
               *
               *    - |result !== null|
               *    - |pos < input.length|
               *    - |rightmostFailuresExpected| may or may not contain something
               *
               * 3. The parser did not successfully parse any part of the input.
               *
               *   - |result === null|
               *   - |pos === 0|
               *   - |rightmostFailuresExpected| contains at least one failure
               *
               * All code following this comment (including called functions) must
               * handle these states.
               */

              if (result === null || pos !== input.length) {
                var offset = Math.max(pos, rightmostFailuresPos);
                var found = offset < input.length ? input.charAt(offset) : null;
                var errorPosition = computeErrorPosition();
                new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);
                return -1;
              }

              return data;
            },

            /* Returns the parser source code. */
            toSource: function toSource() {
              return this._source;
            }
          };
          /* Thrown when a parser encounters a syntax error. */

          result.SyntaxError = function (expected, found, offset, line, column) {
            function buildMessage(expected, found) {
              var expectedHumanized, foundHumanized;

              switch (expected.length) {
                case 0:
                  expectedHumanized = "end of input";
                  break;

                case 1:
                  expectedHumanized = expected[0];
                  break;

                default:
                  expectedHumanized = expected.slice(0, expected.length - 1).join(", ") + " or " + expected[expected.length - 1];
              }

              foundHumanized = found ? quote(found) : "end of input";
              return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
            }

            this.name = "SyntaxError";
            this.expected = expected;
            this.found = found;
            this.message = buildMessage(expected, found);
            this.offset = offset;
            this.line = line;
            this.column = column;
          };

          result.SyntaxError.prototype = Error.prototype;
          return result;
        }();

        /***/
      }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var URI = __webpack_require__(9);

        var Grammar = __webpack_require__(10);

        module.exports = /*#__PURE__*/function () {
          _createClass(NameAddrHeader, null, [{
            key: "parse",

            /**
             * Parse the given string and returns a NameAddrHeader instance or undefined if
             * it is an invalid NameAddrHeader.
             */
            value: function parse(name_addr_header) {
              name_addr_header = Grammar.parse(name_addr_header, 'Name_Addr_Header');

              if (name_addr_header !== -1) {
                return name_addr_header;
              } else {
                return undefined;
              }
            }
          }]);

          function NameAddrHeader(uri, display_name, parameters) {
            _classCallCheck(this, NameAddrHeader);

            // Checks.
            if (!uri || !(uri instanceof URI)) {
              throw new TypeError('missing or invalid "uri" parameter');
            } // Initialize parameters.


            this._uri = uri;
            this._parameters = {};
            this.display_name = display_name;

            for (var param in parameters) {
              if (Object.prototype.hasOwnProperty.call(parameters, param)) {
                this.setParam(param, parameters[param]);
              }
            }
          }

          _createClass(NameAddrHeader, [{
            key: "setParam",
            value: function setParam(key, value) {
              if (key) {
                this._parameters[key.toLowerCase()] = typeof value === 'undefined' || value === null ? null : value.toString();
              }
            }
          }, {
            key: "getParam",
            value: function getParam(key) {
              if (key) {
                return this._parameters[key.toLowerCase()];
              }
            }
          }, {
            key: "hasParam",
            value: function hasParam(key) {
              if (key) {
                return this._parameters.hasOwnProperty(key.toLowerCase()) && true || false;
              }
            }
          }, {
            key: "deleteParam",
            value: function deleteParam(parameter) {
              parameter = parameter.toLowerCase();

              if (this._parameters.hasOwnProperty(parameter)) {
                var value = this._parameters[parameter];
                delete this._parameters[parameter];
                return value;
              }
            }
          }, {
            key: "clearParams",
            value: function clearParams() {
              this._parameters = {};
            }
          }, {
            key: "clone",
            value: function clone() {
              return new NameAddrHeader(this._uri.clone(), this._display_name, JSON.parse(JSON.stringify(this._parameters)));
            }
          }, {
            key: "_quote",
            value: function _quote(str) {
              return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            }
          }, {
            key: "toString",
            value: function toString() {
              var body = this._display_name ? "\"".concat(this._quote(this._display_name), "\" ") : '';
              body += "<".concat(this._uri.toString(), ">");

              for (var parameter in this._parameters) {
                if (Object.prototype.hasOwnProperty.call(this._parameters, parameter)) {
                  body += ";".concat(parameter);

                  if (this._parameters[parameter] !== null) {
                    body += "=".concat(this._parameters[parameter]);
                  }
                }
              }

              return body;
            }
          }, {
            key: "uri",
            get: function get() {
              return this._uri;
            }
          }, {
            key: "display_name",
            get: function get() {
              return this._display_name;
            },
            set: function set(value) {
              this._display_name = value === 0 ? '0' : value;
            }
          }]);

          return NameAddrHeader;
        }();

        /***/
      }),
/* 12 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var Registrator = __webpack_require__(18);

        var RTCSession = __webpack_require__(28);

        var Message = __webpack_require__(35);

        var Options = __webpack_require__(36);

        var Transactions = __webpack_require__(26);

        var Transport = __webpack_require__(37);

        var Utils = __webpack_require__(8);

        var Exceptions = __webpack_require__(7);

        var URI = __webpack_require__(9);

        var Parser = __webpack_require__(39);

        var SIPMessage = __webpack_require__(19);

        var sanityCheck = __webpack_require__(40);

        var config = __webpack_require__(41);

        var logger = new Logger('UA');
        var C = {
          // UA status codes.
          STATUS_INIT: 0,
          STATUS_READY: 1,
          STATUS_USER_CLOSED: 2,
          STATUS_NOT_READY: 3,
          // UA error codes.
          CONFIGURATION_ERROR: 1,
          NETWORK_ERROR: 2
        };
        /**
         * The User-Agent class.
         * @class JsSIP.UA
         * @param {Object} configuration Configuration parameters.
         * @throws {JsSIP.Exceptions.ConfigurationError} If a configuration parameter is invalid.
         * @throws {TypeError} If no configuration is given.
         */

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(UA, _EventEmitter);

          var _super = _createSuper(UA);

          _createClass(UA, null, [{
            key: "C",
            // Expose C object.
            get: function get() {
              return C;
            }
          }]);

          function UA(configuration) {
            var _this;

            _classCallCheck(this, UA);

            logger.debug('new() [configuration:%o]', configuration);
            _this = _super.call(this);
            _this._cache = {
              credentials: {}
            };
            _this._configuration = Object.assign({}, config.settings);
            _this._dynConfiguration = {};
            _this._dialogs = {}; // User actions outside any session/dialog (MESSAGE/OPTIONS).

            _this._applicants = {};
            _this._sessions = {};
            _this._transport = null;
            _this._contact = null;
            _this._status = C.STATUS_INIT;
            _this._error = null;
            _this._transactions = {
              nist: {},
              nict: {},
              ist: {},
              ict: {}
            }; // Custom UA empty object for high level use.

            _this._data = {};
            _this._closeTimer = null; // Check configuration argument.

            if (configuration === undefined) {
              throw new TypeError('Not enough arguments');
            } // Load configuration.


            try {
              _this._loadConfig(configuration);
            } catch (e) {
              _this._status = C.STATUS_NOT_READY;
              _this._error = C.CONFIGURATION_ERROR;
              throw e;
            } // Initialize registrator.


            _this._registrator = new Registrator(_assertThisInitialized(_this));
            return _this;
          }

          _createClass(UA, [{
            key: "start",
            // =================
            //  High Level API
            // =================

            /**
             * Connect to the server if status = STATUS_INIT.
             * Resume UA after being closed.
             */
            value: function start() {
              logger.debug('start()');

              if (this._status === C.STATUS_INIT) {
                this._transport.connect();
              } else if (this._status === C.STATUS_USER_CLOSED) {
                logger.debug('restarting UA'); // Disconnect.

                if (this._closeTimer !== null) {
                  clearTimeout(this._closeTimer);
                  this._closeTimer = null;

                  this._transport.disconnect();
                } // Reconnect.


                this._status = C.STATUS_INIT;

                this._transport.connect();
              } else if (this._status === C.STATUS_READY) {
                logger.debug('UA is in READY status, not restarted');
              } else {
                logger.debug('ERROR: connection is down, Auto-Recovery system is trying to reconnect');
              } // Set dynamic configuration.


              this._dynConfiguration.register = this._configuration.register;
            }
            /**
             * Register.
             */

          }, {
            key: "register",
            value: function register() {
              logger.debug('register()');
              this._dynConfiguration.register = true;

              this._registrator.register();
            }
            /**
             * Unregister.
             */

          }, {
            key: "unregister",
            value: function unregister(options) {
              logger.debug('unregister()');
              this._dynConfiguration.register = false;

              this._registrator.unregister(options);
            }
            /**
             * Get the Registrator instance.
             */

          }, {
            key: "registrator",
            value: function registrator() {
              return this._registrator;
            }
            /**
             * Registration state.
             */

          }, {
            key: "isRegistered",
            value: function isRegistered() {
              return this._registrator.registered;
            }
            /**
             * Connection state.
             */

          }, {
            key: "isConnected",
            value: function isConnected() {
              return this._transport.isConnected();
            }
            /**
             * Make an outgoing call.
             *
             * -param {String} target
             * -param {Object} [options]
             *
             * -throws {TypeError}
             *
             */

          }, {
            key: "call",
            value: function call(target, options) {
              logger.debug('call()');
              var session = new RTCSession(this);
              session.connect(target, options);
              return session;
            }
            /**
             * Send a message.
             *
             * -param {String} target
             * -param {String} body
             * -param {Object} [options]
             *
             * -throws {TypeError}
             *
             */

          }, {
            key: "sendMessage",
            value: function sendMessage(target, body, options) {
              logger.debug('sendMessage()');
              var message = new Message(this);
              message.send(target, body, options);
              return message;
            }
            /**
             * Send a SIP OPTIONS.
             *
             * -param {String} target
             * -param {String} [body]
             * -param {Object} [options]
             *
             * -throws {TypeError}
             *
             */

          }, {
            key: "sendOptions",
            value: function sendOptions(target, body, options) {
              logger.debug('sendOptions()');
              var message = new Options(this);
              message.send(target, body, options);
              return message;
            }
            /**
             * Terminate ongoing sessions.
             */

          }, {
            key: "terminateSessions",
            value: function terminateSessions(options) {
              logger.debug('terminateSessions()');

              for (var idx in this._sessions) {
                if (!this._sessions[idx].isEnded()) {
                  this._sessions[idx].terminate(options);
                }
              }
            }
            /**
             * Gracefully close.
             *
             */

          }, {
            key: "stop",
            value: function stop() {
              var _this2 = this;

              logger.debug('stop()'); // Remove dynamic settings.

              this._dynConfiguration = {};

              if (this._status === C.STATUS_USER_CLOSED) {
                logger.debug('UA already closed');
                return;
              } // Close registrator.


              this._registrator.close(); // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.


              var num_sessions = Object.keys(this._sessions).length; // Run  _terminate_ on every Session.

              for (var session in this._sessions) {
                if (Object.prototype.hasOwnProperty.call(this._sessions, session)) {
                  logger.debug("closing session ".concat(session));

                  try {
                    this._sessions[session].terminate();
                  } catch (error) { }
                }
              } // Run  _close_ on every applicant.


              for (var applicant in this._applicants) {
                if (Object.prototype.hasOwnProperty.call(this._applicants, applicant)) try {
                  this._applicants[applicant].close();
                } catch (error) { }
              }

              this._status = C.STATUS_USER_CLOSED;
              var num_transactions = Object.keys(this._transactions.nict).length + Object.keys(this._transactions.nist).length + Object.keys(this._transactions.ict).length + Object.keys(this._transactions.ist).length;

              if (num_transactions === 0 && num_sessions === 0) {
                this._transport.disconnect();
              } else {
                this._closeTimer = setTimeout(function () {
                  _this2._closeTimer = null;

                  _this2._transport.disconnect();
                }, 2000);
              }
            }
            /**
             * Normalice a string into a valid SIP request URI
             * -param {String} target
             * -returns {JsSIP.URI|undefined}
             */

          }, {
            key: "normalizeTarget",
            value: function normalizeTarget(target) {
              return Utils.normalizeTarget(target, this._configuration.hostport_params);
            }
            /**
             * Allow retrieving configuration and autogenerated fields in runtime.
             */

          }, {
            key: "get",
            value: function get(parameter) {
              switch (parameter) {
                case 'authorization_user':
                  return this._configuration.authorization_user;

                case 'realm':
                  return this._configuration.realm;

                case 'ha1':
                  return this._configuration.ha1;

                case 'authorization_jwt':
                  return this._configuration.authorization_jwt;

                default:
                  logger.warn('get() | cannot get "%s" parameter in runtime', parameter);
                  return undefined;
              }
            }
            /**
             * Allow configuration changes in runtime.
             * Returns true if the parameter could be set.
             */

          }, {
            key: "set",
            value: function set(parameter, value) {
              switch (parameter) {
                case 'authorization_user':
                  {
                    this._configuration.authorization_user = String(value);
                    break;
                  }

                case 'password':
                  {
                    this._configuration.password = String(value);
                    break;
                  }

                case 'realm':
                  {
                    this._configuration.realm = String(value);
                    break;
                  }

                case 'ha1':
                  {
                    this._configuration.ha1 = String(value); // Delete the plain SIP password.

                    this._configuration.password = null;
                    break;
                  }

                case 'authorization_jwt':
                  {
                    this._configuration.authorization_jwt = String(value);
                    break;
                  }

                case 'display_name':
                  {
                    this._configuration.display_name = value;
                    break;
                  }

                default:
                  logger.warn('set() | cannot set "%s" parameter in runtime', parameter);
                  return false;
              }

              return true;
            } // ==========================
            // Event Handlers.
            // ==========================

            /**
             * new Transaction
             */

          }, {
            key: "newTransaction",
            value: function newTransaction(transaction) {
              this._transactions[transaction.type][transaction.id] = transaction;
              this.emit('newTransaction', {
                transaction: transaction
              });
            }
            /**
             * Transaction destroyed.
             */

          }, {
            key: "destroyTransaction",
            value: function destroyTransaction(transaction) {
              delete this._transactions[transaction.type][transaction.id];
              this.emit('transactionDestroyed', {
                transaction: transaction
              });
            }
            /**
             * new Dialog
             */

          }, {
            key: "newDialog",
            value: function newDialog(dialog) {
              this._dialogs[dialog.id] = dialog;
            }
            /**
             * Dialog destroyed.
             */

          }, {
            key: "destroyDialog",
            value: function destroyDialog(dialog) {
              delete this._dialogs[dialog.id];
            }
            /**
             *  new Message
             */

          }, {
            key: "newMessage",
            value: function newMessage(message, data) {
              this._applicants[message] = message;
              this.emit('newMessage', data);
            }
            /**
             *  new Options
             */

          }, {
            key: "newOptions",
            value: function newOptions(message, data) {
              this._applicants[message] = message;
              this.emit('newOptions', data);
            }
            /**
             *  Message destroyed.
             */

          }, {
            key: "destroyMessage",
            value: function destroyMessage(message) {
              delete this._applicants[message];
            }
            /**
             * new RTCSession
             */

          }, {
            key: "newRTCSession",
            value: function newRTCSession(session, data) {
              this._sessions[session.id] = session;
              this.emit('newRTCSession', data);
            }
            /**
             * RTCSession destroyed.
             */

          }, {
            key: "destroyRTCSession",
            value: function destroyRTCSession(session) {
              delete this._sessions[session.id];
            }
            /**
             * Registered
             */

          }, {
            key: "registered",
            value: function registered(data) {
              this.emit('registered', data);
            }
            /**
             * Unregistered
             */

          }, {
            key: "unregistered",
            value: function unregistered(data) {
              this.emit('unregistered', data);
            }
            /**
             * Registration Failed
             */

          }, {
            key: "registrationFailed",
            value: function registrationFailed(data) {
              this.emit('registrationFailed', data);
            } // =========================
            // ReceiveRequest.
            // =========================

            /**
             * Request reception
             */

          }, {
            key: "receiveRequest",
            value: function receiveRequest(request) {
              var method = request.method; // Check that request URI points to us.

              if (request.ruri.user !== this._configuration.uri.user && request.ruri.user !== this._contact.uri.user) {
                logger.debug('Request-URI does not point to us');

                if (request.method !== JsSIP_C.ACK) {
                  request.reply_sl(404);
                }

                return;
              } // Check request URI scheme.


              if (request.ruri.scheme === JsSIP_C.SIPS) {
                request.reply_sl(416);
                return;
              } // Check transaction.


              if (Transactions.checkTransaction(this, request)) {
                return;
              } // Create the server transaction.


              if (method === JsSIP_C.INVITE) {
                /* eslint-disable no-new */
                new Transactions.InviteServerTransaction(this, this._transport, request);
                /* eslint-enable no-new */
              } else if (method !== JsSIP_C.ACK && method !== JsSIP_C.CANCEL) {
                /* eslint-disable no-new */
                new Transactions.NonInviteServerTransaction(this, this._transport, request);
                /* eslint-enable no-new */
              }
              /* RFC3261 12.2.2
               * Requests that do not change in any way the state of a dialog may be
               * received within a dialog (for example, an OPTIONS request).
               * They are processed as if they had been received outside the dialog.
               */


              if (method === JsSIP_C.OPTIONS) {
                if (this.listeners('newOptions').length === 0) {
                  request.reply(200);
                  return;
                }

                var message = new Options(this);
                message.init_incoming(request);
              } else if (method === JsSIP_C.MESSAGE) {
                if (this.listeners('newMessage').length === 0) {
                  request.reply(405);
                  return;
                }

                var _message = new Message(this);

                _message.init_incoming(request);
              } else if (method === JsSIP_C.INVITE) {
                // Initial INVITE.
                if (!request.to_tag && this.listeners('newRTCSession').length === 0) {
                  request.reply(405);
                  return;
                }
              }

              var dialog;
              var session; // Initial Request.

              if (!request.to_tag) {
                switch (method) {
                  case JsSIP_C.INVITE:
                    if (window.RTCPeerConnection) {
                      // TODO
                      if (request.hasHeader('replaces')) {
                        var replaces = request.replaces;
                        dialog = this._findDialog(replaces.call_id, replaces.from_tag, replaces.to_tag);

                        if (dialog) {
                          session = dialog.owner;

                          if (!session.isEnded()) {
                            session.receiveRequest(request);
                          } else {
                            request.reply(603);
                          }
                        } else {
                          request.reply(481);
                        }
                      } else {
                        session = new RTCSession(this);
                        session.init_incoming(request);
                      }
                    } else {
                      logger.warn('INVITE received but WebRTC is not supported');
                      request.reply(488);
                    }

                    break;

                  case JsSIP_C.BYE:
                    // Out of dialog BYE received.
                    request.reply(481);
                    break;

                  case JsSIP_C.CANCEL:
                    session = this._findSession(request);

                    if (session) {
                      session.receiveRequest(request);
                    } else {
                      logger.debug('received CANCEL request for a non existent session');
                    }

                    break;

                  case JsSIP_C.ACK:
                    /* Absorb it.
                     * ACK request without a corresponding Invite Transaction
                     * and without To tag.
                     */
                    break;

                  case JsSIP_C.NOTIFY:
                    // Receive new sip event.
                    this.emit('sipEvent', {
                      event: request.event,
                      request: request
                    });
                    request.reply(200);
                    break;

                  default:
                    request.reply(405);
                    break;
                }
              } // In-dialog request.
              else {
                dialog = this._findDialog(request.call_id, request.from_tag, request.to_tag);

                if (dialog) {
                  dialog.receiveRequest(request);
                } else if (method === JsSIP_C.NOTIFY) {
                  session = this._findSession(request);

                  if (session) {
                    session.receiveRequest(request);
                  } else {
                    logger.debug('received NOTIFY request for a non existent subscription');
                    request.reply(481, 'Subscription does not exist');
                  }
                }
                /* RFC3261 12.2.2
                 * Request with to tag, but no matching dialog found.
                 * Exception: ACK for an Invite request for which a dialog has not
                 * been created.
                 */
                else if (method !== JsSIP_C.ACK) {
                  request.reply(481);
                }
              }
            } // =================
            // Utils.
            // =================

            /**
             * Get the session to which the request belongs to, if any.
             */

          }, {
            key: "_findSession",
            value: function _findSession(_ref) {
              var call_id = _ref.call_id,
                from_tag = _ref.from_tag,
                to_tag = _ref.to_tag;
              var sessionIDa = call_id + from_tag;
              var sessionA = this._sessions[sessionIDa];
              var sessionIDb = call_id + to_tag;
              var sessionB = this._sessions[sessionIDb];

              if (sessionA) {
                return sessionA;
              } else if (sessionB) {
                return sessionB;
              } else {
                return null;
              }
            }
            /**
             * Get the dialog to which the request belongs to, if any.
             */

          }, {
            key: "_findDialog",
            value: function _findDialog(call_id, from_tag, to_tag) {
              var id = call_id + from_tag + to_tag;
              var dialog = this._dialogs[id];

              if (dialog) {
                return dialog;
              } else {
                id = call_id + to_tag + from_tag;
                dialog = this._dialogs[id];

                if (dialog) {
                  return dialog;
                } else {
                  return null;
                }
              }
            }
          }, {
            key: "_loadConfig",
            value: function _loadConfig(configuration) {
              // Check and load the given configuration.
              try {
                config.load(this._configuration, configuration);
              } catch (e) {
                throw e;
              } // Post Configuration Process.
              // Allow passing 0 number as display_name.


              if (this._configuration.display_name === 0) {
                this._configuration.display_name = '0';
              } // Instance-id for GRUU.


              if (!this._configuration.instance_id) {
                this._configuration.instance_id = Utils.newUUID();
              } // Jssip_id instance parameter. Static random tag of length 5.


              this._configuration.jssip_id = Utils.createRandomToken(5); // String containing this._configuration.uri without scheme and user.

              var hostport_params = this._configuration.uri.clone();

              hostport_params.user = null;
              this._configuration.hostport_params = hostport_params.toString().replace(/^sip:/i, ''); // Transport.

              try {
                this._transport = new Transport(this._configuration.sockets, {
                  // Recovery options.
                  max_interval: this._configuration.connection_recovery_max_interval,
                  min_interval: this._configuration.connection_recovery_min_interval
                }); // Transport event callbacks.

                this._transport.onconnecting = onTransportConnecting.bind(this);
                this._transport.onconnect = onTransportConnect.bind(this);
                this._transport.ondisconnect = onTransportDisconnect.bind(this);
                this._transport.ondata = onTransportData.bind(this);
              } catch (e) {
                logger.warn(e);
                throw new Exceptions.ConfigurationError('sockets', this._configuration.sockets);
              } // Remove sockets instance from configuration object.


              delete this._configuration.sockets; // Check whether authorization_user is explicitly defined.
              // Take 'this._configuration.uri.user' value if not.

              if (!this._configuration.authorization_user) {
                this._configuration.authorization_user = this._configuration.uri.user;
              } // If no 'registrar_server' is set use the 'uri' value without user portion and
              // without URI params/headers.


              if (!this._configuration.registrar_server) {
                var registrar_server = this._configuration.uri.clone();

                registrar_server.user = null;
                registrar_server.clearParams();
                registrar_server.clearHeaders();
                this._configuration.registrar_server = registrar_server;
              } // User no_answer_timeout.


              this._configuration.no_answer_timeout *= 1000; // Via Host.

              if (this._configuration.contact_uri) {
                this._configuration.via_host = this._configuration.contact_uri.host;
              } // Contact URI.
              else {
                this._configuration.contact_uri = new URI('sip', Utils.createRandomToken(8), this._configuration.via_host, null, {
                  transport: 'ws'
                });
              }

              this._contact = {
                pub_gruu: null,
                temp_gruu: null,
                uri: this._configuration.contact_uri,
                toString: function toString() {
                  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                  var anonymous = options.anonymous || null;
                  var outbound = options.outbound || null;
                  var contact = '<';

                  if (anonymous) {
                    contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';
                  } else {
                    contact += this.pub_gruu || this.uri.toString();
                  }

                  if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {
                    contact += ';ob';
                  }

                  contact += '>';
                  return contact;
                }
              }; // Seal the configuration.

              var writable_parameters = ['authorization_user', 'password', 'realm', 'ha1', 'authorization_jwt', 'display_name', 'register'];

              for (var parameter in this._configuration) {
                if (Object.prototype.hasOwnProperty.call(this._configuration, parameter)) {
                  if (writable_parameters.indexOf(parameter) !== -1) {
                    Object.defineProperty(this._configuration, parameter, {
                      writable: true,
                      configurable: false
                    });
                  } else {
                    Object.defineProperty(this._configuration, parameter, {
                      writable: false,
                      configurable: false
                    });
                  }
                }
              }

              logger.debug('configuration parameters after validation:');

              for (var _parameter in this._configuration) {
                // Only show the user user configurable parameters.
                if (Object.prototype.hasOwnProperty.call(config.settings, _parameter)) {
                  switch (_parameter) {
                    case 'uri':
                    case 'registrar_server':
                      logger.debug("- ".concat(_parameter, ": ").concat(this._configuration[_parameter]));
                      break;

                    case 'password':
                    case 'ha1':
                    case 'authorization_jwt':
                      logger.debug("- ".concat(_parameter, ": NOT SHOWN"));
                      break;

                    default:
                      logger.debug("- ".concat(_parameter, ": ").concat(JSON.stringify(this._configuration[_parameter])));
                  }
                }
              }

              return;
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            }
          }, {
            key: "status",
            get: function get() {
              return this._status;
            }
          }, {
            key: "contact",
            get: function get() {
              return this._contact;
            }
          }, {
            key: "configuration",
            get: function get() {
              return this._configuration;
            }
          }, {
            key: "transport",
            get: function get() {
              return this._transport;
            }
          }]);

          return UA;
        }(EventEmitter);
        /**
         * Transport event handlers
         */
        // Transport connecting event.


        function onTransportConnecting(data) {
          this.emit('connecting', data);
        } // Transport connected event.


        function onTransportConnect(data) {
          if (this._status === C.STATUS_USER_CLOSED) {
            return;
          }

          this._status = C.STATUS_READY;
          this._error = null;
          this.emit('connected', data);

          if (this._dynConfiguration.register) {
            this._registrator.register();
          }
        } // Transport disconnected event.


        function onTransportDisconnect(data) {
          // Run _onTransportError_ callback on every client transaction using _transport_.
          var client_transactions = ['nict', 'ict', 'nist', 'ist'];

          for (var _i = 0, _client_transactions = client_transactions; _i < _client_transactions.length; _i++) {
            var type = _client_transactions[_i];

            for (var id in this._transactions[type]) {
              if (Object.prototype.hasOwnProperty.call(this._transactions[type], id)) {
                this._transactions[type][id].onTransportError();
              }
            }
          }

          this.emit('disconnected', data); // Call registrator _onTransportClosed_.

          this._registrator.onTransportClosed();

          if (this._status !== C.STATUS_USER_CLOSED) {
            this._status = C.STATUS_NOT_READY;
            this._error = C.NETWORK_ERROR;
          }
        } // Transport data event.


        function onTransportData(data) {
          var transport = data.transport;
          var message = data.message;
          message = Parser.parseMessage(message, this);

          if (!message) {
            return;
          }

          if (this._status === C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {
            return;
          } // Do some sanity check.


          if (!sanityCheck(message, this, transport)) {
            return;
          }

          if (message instanceof SIPMessage.IncomingRequest) {
            message.transport = transport;
            this.receiveRequest(message);
          } else if (message instanceof SIPMessage.IncomingResponse) {
            /* Unike stated in 18.1.2, if a response does not match
            * any transaction, it is discarded here and no passed to the core
            * in order to be discarded there.
            */
            var transaction;

            switch (message.method) {
              case JsSIP_C.INVITE:
                transaction = this._transactions.ict[message.via_branch];

                if (transaction) {
                  transaction.receiveResponse(message);
                }

                break;

              case JsSIP_C.ACK:
                // Just in case ;-).
                break;

              default:
                transaction = this._transactions.nict[message.via_branch];

                if (transaction) {
                  transaction.receiveResponse(message);
                }

                break;
            }
          }
        }

        /***/
      }),
/* 13 */
/***/ ((module) => {

        "use strict";
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.



        var R = typeof Reflect === 'object' ? Reflect : null
        var ReflectApply = R && typeof R.apply === 'function'
          ? R.apply
          : function ReflectApply(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
          }

        var ReflectOwnKeys
        if (R && typeof R.ownKeys === 'function') {
          ReflectOwnKeys = R.ownKeys
        } else if (Object.getOwnPropertySymbols) {
          ReflectOwnKeys = function ReflectOwnKeys(target) {
            return Object.getOwnPropertyNames(target)
              .concat(Object.getOwnPropertySymbols(target));
          };
        } else {
          ReflectOwnKeys = function ReflectOwnKeys(target) {
            return Object.getOwnPropertyNames(target);
          };
        }

        function ProcessEmitWarning(warning) {
          if (console && console.warn) console.warn(warning);
        }

        var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
          return value !== value;
        }

        function EventEmitter() {
          EventEmitter.init.call(this);
        }
        module.exports = EventEmitter;
        module.exports.once = once;

        // Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._eventsCount = 0;
        EventEmitter.prototype._maxListeners = undefined;

        // By default EventEmitters will print a warning if more than 10 listeners are
        // added to it. This is a useful default which helps finding memory leaks.
        var defaultMaxListeners = 10;

        function checkListener(listener) {
          if (typeof listener !== 'function') {
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
          }
        }

        Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
          enumerable: true,
          get: function () {
            return defaultMaxListeners;
          },
          set: function (arg) {
            if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
            }
            defaultMaxListeners = arg;
          }
        });

        EventEmitter.init = function () {

          if (this._events === undefined ||
            this._events === Object.getPrototypeOf(this)._events) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          }

          this._maxListeners = this._maxListeners || undefined;
        };

        // Obviously not all Emitters should be limited to 10. This function allows
        // that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
          }
          this._maxListeners = n;
          return this;
        };

        function _getMaxListeners(that) {
          if (that._maxListeners === undefined)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }

        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return _getMaxListeners(this);
        };

        EventEmitter.prototype.emit = function emit(type) {
          var args = [];
          for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
          var doError = (type === 'error');

          var events = this._events;
          if (events !== undefined)
            doError = (doError && events.error === undefined);
          else if (!doError)
            return false;

          // If there is no 'error' event listener then throw.
          if (doError) {
            var er;
            if (args.length > 0)
              er = args[0];
            if (er instanceof Error) {
              // Note: The comments on the `throw` lines are intentional, they show
              // up in Node's output if this results in an unhandled exception.
              throw er; // Unhandled 'error' event
            }
            // At least give some kind of context to the user
            var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
            err.context = er;
            throw err; // Unhandled 'error' event
          }

          var handler = events[type];

          if (handler === undefined)
            return false;

          if (typeof handler === 'function') {
            ReflectApply(handler, this, args);
          } else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              ReflectApply(listeners[i], this, args);
          }

          return true;
        };

        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;

          checkListener(listener);

          events = target._events;
          if (events === undefined) {
            events = target._events = Object.create(null);
            target._eventsCount = 0;
          } else {
            // To avoid recursion in the case that type === "newListener"! Before
            // adding it to the listeners, first emit "newListener".
            if (events.newListener !== undefined) {
              target.emit('newListener', type,
                listener.listener ? listener.listener : listener);

              // Re-assign `events` because a newListener handler could have caused the
              // this._events to be assigned to a new object
              events = target._events;
            }
            existing = events[type];
          }

          if (existing === undefined) {
            // Optimize the case of one listener. Don't need the extra array object.
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === 'function') {
              // Adding the second element, need to change to array.
              existing = events[type] =
                prepend ? [listener, existing] : [existing, listener];
              // If we've already got an array, just append.
            } else if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }

            // Check for listener leak
            m = _getMaxListeners(target);
            if (m > 0 && existing.length > m && !existing.warned) {
              existing.warned = true;
              // No error code for this since it is a Warning
              // eslint-disable-next-line no-restricted-syntax
              var w = new Error('Possible EventEmitter memory leak detected. ' +
                existing.length + ' ' + String(type) + ' listeners ' +
                'added. Use emitter.setMaxListeners() to ' +
                'increase limit');
              w.name = 'MaxListenersExceededWarning';
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              ProcessEmitWarning(w);
            }
          }

          return target;
        }

        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.prependListener =
          function prependListener(type, listener) {
            return _addListener(this, type, listener, true);
          };

        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            if (arguments.length === 0)
              return this.listener.call(this.target);
            return this.listener.apply(this.target, arguments);
          }
        }

        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
          var wrapped = onceWrapper.bind(state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }

        EventEmitter.prototype.once = function once(type, listener) {
          checkListener(listener);
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };

        EventEmitter.prototype.prependOnceListener =
          function prependOnceListener(type, listener) {
            checkListener(listener);
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
          };

        // Emits a 'removeListener' event if and only if the listener was removed.
        EventEmitter.prototype.removeListener =
          function removeListener(type, listener) {
            var list, events, position, i, originalListener;

            checkListener(listener);

            events = this._events;
            if (events === undefined)
              return this;

            list = events[type];
            if (list === undefined)
              return this;

            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0)
                this._events = Object.create(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit('removeListener', type, list.listener || listener);
              }
            } else if (typeof list !== 'function') {
              position = -1;

              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener;
                  position = i;
                  break;
                }
              }

              if (position < 0)
                return this;

              if (position === 0)
                list.shift();
              else {
                spliceOne(list, position);
              }

              if (list.length === 1)
                events[type] = list[0];

              if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener);
            }

            return this;
          };

        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

        EventEmitter.prototype.removeAllListeners =
          function removeAllListeners(type) {
            var listeners, events, i;

            events = this._events;
            if (events === undefined)
              return this;

            // not listening for removeListener, no need to emit
            if (events.removeListener === undefined) {
              if (arguments.length === 0) {
                this._events = Object.create(null);
                this._eventsCount = 0;
              } else if (events[type] !== undefined) {
                if (--this._eventsCount === 0)
                  this._events = Object.create(null);
                else
                  delete events[type];
              }
              return this;
            }

            // emit removeListener for all listeners on all events
            if (arguments.length === 0) {
              var keys = Object.keys(events);
              var key;
              for (i = 0; i < keys.length; ++i) {
                key = keys[i];
                if (key === 'removeListener') continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners('removeListener');
              this._events = Object.create(null);
              this._eventsCount = 0;
              return this;
            }

            listeners = events[type];

            if (typeof listeners === 'function') {
              this.removeListener(type, listeners);
            } else if (listeners !== undefined) {
              // LIFO order
              for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i]);
              }
            }

            return this;
          };

        function _listeners(target, type, unwrap) {
          var events = target._events;

          if (events === undefined)
            return [];

          var evlistener = events[type];
          if (evlistener === undefined)
            return [];

          if (typeof evlistener === 'function')
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];

          return unwrap ?
            unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }

        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };

        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };

        EventEmitter.listenerCount = function (emitter, type) {
          if (typeof emitter.listenerCount === 'function') {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };

        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;

          if (events !== undefined) {
            var evlistener = events[type];

            if (typeof evlistener === 'function') {
              return 1;
            } else if (evlistener !== undefined) {
              return evlistener.length;
            }
          }

          return 0;
        }

        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
        };

        function arrayClone(arr, n) {
          var copy = new Array(n);
          for (var i = 0; i < n; ++i)
            copy[i] = arr[i];
          return copy;
        }

        function spliceOne(list, index) {
          for (; index + 1 < list.length; index++)
            list[index] = list[index + 1];
          list.pop();
        }

        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }

        function once(emitter, name) {
          return new Promise(function (resolve, reject) {
            function errorListener(err) {
              emitter.removeListener(name, resolver);
              reject(err);
            }

            function resolver() {
              if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener);
              }
              resolve([].slice.call(arguments));
            };

            eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
            if (name !== 'error') {
              addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
            }
          });
        }

        function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
          if (typeof emitter.on === 'function') {
            eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
          }
        }

        function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
          if (typeof emitter.on === 'function') {
            if (flags.once) {
              emitter.once(name, listener);
            } else {
              emitter.on(name, listener);
            }
          } else if (typeof emitter.addEventListener === 'function') {
            // EventTarget does not have `error` event semantics like Node
            // EventEmitters, we do not listen for `error` events here.
            emitter.addEventListener(name, function wrapListener(arg) {
              // IE does not have builtin `{ once: true }` support so we
              // have to do it manually.
              if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
              }
              listener(arg);
            });
          } else {
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
          }
        }


        /***/
      }),
/* 14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var debug = __webpack_require__(15);

        var APP_NAME = 'JsSIP';

        module.exports = /*#__PURE__*/function () {
          function Logger(prefix) {
            _classCallCheck(this, Logger);

            if (prefix) {
              this._debug = debug["default"]("".concat(APP_NAME, ":").concat(prefix));
              this._warn = debug["default"]("".concat(APP_NAME, ":WARN:").concat(prefix));
              this._error = debug["default"]("".concat(APP_NAME, ":ERROR:").concat(prefix));
            } else {
              this._debug = debug["default"](APP_NAME);
              this._warn = debug["default"]("".concat(APP_NAME, ":WARN"));
              this._error = debug["default"]("".concat(APP_NAME, ":ERROR"));
            }
            /* eslint-disable no-console */


            this._debug.log = console.info.bind(console);
            this._warn.log = console.warn.bind(console);
            this._error.log = console.error.bind(console);
            /* eslint-enable no-console */
          }

          _createClass(Logger, [{
            key: "debug",
            get: function get() {
              return this._debug;
            }
          }, {
            key: "warn",
            get: function get() {
              return this._warn;
            }
          }, {
            key: "error",
            get: function get() {
              return this._error;
            }
          }]);

          return Logger;
        }();

        /***/
      }),
/* 15 */
/***/ ((module, exports, __webpack_require__) => {

        /* eslint-env browser */

        /**
         * This is the web browser implementation of `debug()`.
         */

        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = localstorage();
        exports.destroy = (() => {
          let warned = false;

          return () => {
            if (!warned) {
              warned = true;
              console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
            }
          };
        })();

        /**
         * Colors.
         */

        exports.colors = [
          '#0000CC',
          '#0000FF',
          '#0033CC',
          '#0033FF',
          '#0066CC',
          '#0066FF',
          '#0099CC',
          '#0099FF',
          '#00CC00',
          '#00CC33',
          '#00CC66',
          '#00CC99',
          '#00CCCC',
          '#00CCFF',
          '#3300CC',
          '#3300FF',
          '#3333CC',
          '#3333FF',
          '#3366CC',
          '#3366FF',
          '#3399CC',
          '#3399FF',
          '#33CC00',
          '#33CC33',
          '#33CC66',
          '#33CC99',
          '#33CCCC',
          '#33CCFF',
          '#6600CC',
          '#6600FF',
          '#6633CC',
          '#6633FF',
          '#66CC00',
          '#66CC33',
          '#9900CC',
          '#9900FF',
          '#9933CC',
          '#9933FF',
          '#99CC00',
          '#99CC33',
          '#CC0000',
          '#CC0033',
          '#CC0066',
          '#CC0099',
          '#CC00CC',
          '#CC00FF',
          '#CC3300',
          '#CC3333',
          '#CC3366',
          '#CC3399',
          '#CC33CC',
          '#CC33FF',
          '#CC6600',
          '#CC6633',
          '#CC9900',
          '#CC9933',
          '#CCCC00',
          '#CCCC33',
          '#FF0000',
          '#FF0033',
          '#FF0066',
          '#FF0099',
          '#FF00CC',
          '#FF00FF',
          '#FF3300',
          '#FF3333',
          '#FF3366',
          '#FF3399',
          '#FF33CC',
          '#FF33FF',
          '#FF6600',
          '#FF6633',
          '#FF9900',
          '#FF9933',
          '#FFCC00',
          '#FFCC33'
        ];

        /**
         * Currently only WebKit-based Web Inspectors, Firefox >= v31,
         * and the Firebug extension (any Firefox version) are known
         * to support "%c" CSS customizations.
         *
         * TODO: add a `localStorage` variable to explicitly enable/disable colors
         */

        // eslint-disable-next-line complexity
        function useColors() {
          // NB: In an Electron preload script, document will be defined but not fully
          // initialized. Since we know we're in Chrome, we'll just detect this case
          // explicitly
          if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
            return true;
          }

          // Internet Explorer and Edge do not support colors.
          if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }

          // Is webkit? http://stackoverflow.com/a/16459606/376773
          // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
          return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
            // Is firebug? http://stackoverflow.com/a/398120/376773
            (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
            // Is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
            // Double check webkit in userAgent just in case we are in a worker
            (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
        }

        /**
         * Colorize log arguments if enabled.
         *
         * @api public
         */

        function formatArgs(args) {
          args[0] = (this.useColors ? '%c' : '') +
            this.namespace +
            (this.useColors ? ' %c' : ' ') +
            args[0] +
            (this.useColors ? '%c ' : ' ') +
            '+' + module.exports.humanize(this.diff);

          if (!this.useColors) {
            return;
          }

          const c = 'color: ' + this.color;
          args.splice(1, 0, c, 'color: inherit');

          // The final "%c" is somewhat tricky, because there could be other
          // arguments passed either before or after the %c, so we need to
          // figure out the correct index to insert the CSS into
          let index = 0;
          let lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, match => {
            if (match === '%%') {
              return;
            }
            index++;
            if (match === '%c') {
              // We only are interested in the *last* %c
              // (the user may have provided their own)
              lastC = index;
            }
          });

          args.splice(lastC, 0, c);
        }

        /**
         * Invokes `console.debug()` when available.
         * No-op when `console.debug` is not a "function".
         * If `console.debug` is not available, falls back
         * to `console.log`.
         *
         * @api public
         */
        exports.log = console.debug || console.log || (() => { });

        /**
         * Save `namespaces`.
         *
         * @param {String} namespaces
         * @api private
         */
        function save(namespaces) {
          try {
            if (namespaces) {
              exports.storage.setItem('debug', namespaces);
            } else {
              exports.storage.removeItem('debug');
            }
          } catch (error) {
            // Swallow
            // XXX (@Qix-) should we be logging these?
          }
        }

        /**
         * Load `namespaces`.
         *
         * @return {String} returns the previously persisted debug modes
         * @api private
         */
        function load() {
          let r;
          try {
            r = exports.storage.getItem('debug');
          } catch (error) {
            // Swallow
            // XXX (@Qix-) should we be logging these?
          }

          // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
          if (!r && typeof process !== 'undefined' && 'env' in process) {
            r = process.env.DEBUG;
          }

          return r;
        }

        /**
         * Localstorage attempts to return the localstorage.
         *
         * This is necessary because safari throws
         * when a user disables cookies/localstorage
         * and you attempt to access it.
         *
         * @return {LocalStorage}
         * @api private
         */

        function localstorage() {
          try {
            // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
            // The Browser also has localStorage in the global context.
            return localStorage;
          } catch (error) {
            // Swallow
            // XXX (@Qix-) should we be logging these?
          }
        }

        module.exports = __webpack_require__(16)(exports);

        const { formatters } = module.exports;

        /**
         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
         */

        formatters.j = function (v) {
          try {
            return JSON.stringify(v);
          } catch (error) {
            return '[UnexpectedJSONParseError]: ' + error.message;
          }
        };


        /***/
      }),
/* 16 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


        /**
         * This is the common logic for both the Node.js and web browser
         * implementations of `debug()`.
         */

        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = __webpack_require__(17);
          createDebug.destroy = destroy;

          Object.keys(env).forEach(key => {
            createDebug[key] = env[key];
          });

          /**
          * The currently active debug mode names, and names to skip.
          */

          createDebug.names = [];
          createDebug.skips = [];

          /**
          * Map of special "%n" handling functions, for the debug "format" argument.
          *
          * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
          */
          createDebug.formatters = {};

          /**
          * Selects a color for a debug namespace
          * @param {String} namespace The namespace string for the debug instance to be colored
          * @return {Number|String} An ANSI color code for the given namespace
          * @api private
          */
          function selectColor(namespace) {
            let hash = 0;

            for (let i = 0; i < namespace.length; i++) {
              hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
              hash |= 0; // Convert to 32bit integer
            }

            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;

          /**
          * Create a debugger with the given `namespace`.
          *
          * @param {String} namespace
          * @return {Function}
          * @api public
          */
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;

            function debug(...args) {
              // Disabled?
              if (!debug.enabled) {
                return;
              }

              const self = debug;

              // Set `diff` timestamp
              const curr = Number(new Date());
              const ms = curr - (prevTime || curr);
              self.diff = ms;
              self.prev = prevTime;
              self.curr = curr;
              prevTime = curr;

              args[0] = createDebug.coerce(args[0]);

              if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
              }

              // Apply any `formatters` transformations
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                  return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                  const val = args[index];
                  match = formatter.call(self, val);

                  // Now we need to remove `args[index]` since it's inlined in the `format`
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });

              // Apply env-specific formatting (colors, etc.)
              createDebug.formatArgs.call(self, args);

              const logFn = self.log || createDebug.log;
              logFn.apply(self, args);
            }

            debug.namespace = namespace;
            debug.useColors = createDebug.useColors();
            debug.color = createDebug.selectColor(namespace);
            debug.extend = extend;
            debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

            Object.defineProperty(debug, 'enabled', {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }

                return enabledCache;
              },
              set: v => {
                enableOverride = v;
              }
            });

            // Env-specific initialization logic for debug instances
            if (typeof createDebug.init === 'function') {
              createDebug.init(debug);
            }

            return debug;
          }

          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }

          /**
          * Enables a debug mode by namespaces. This can include modes
          * separated by a colon and wildcards.
          *
          * @param {String} namespaces
          * @api public
          */
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;

            createDebug.names = [];
            createDebug.skips = [];

            let i;
            const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
            const len = split.length;

            for (i = 0; i < len; i++) {
              if (!split[i]) {
                // ignore empty strings
                continue;
              }

              namespaces = split[i].replace(/\*/g, '.*?');

              if (namespaces[0] === '-') {
                createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
              } else {
                createDebug.names.push(new RegExp('^' + namespaces + '$'));
              }
            }
          }

          /**
          * Disable debug output.
          *
          * @return {String} namespaces
          * @api public
          */
          function disable() {
            const namespaces = [
              ...createDebug.names.map(toNamespace),
              ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
            ].join(',');
            createDebug.enable('');
            return namespaces;
          }

          /**
          * Returns true if the given mode name is enabled, false otherwise.
          *
          * @param {String} name
          * @return {Boolean}
          * @api public
          */
          function enabled(name) {
            if (name[name.length - 1] === '*') {
              return true;
            }

            let i;
            let len;

            for (i = 0, len = createDebug.skips.length; i < len; i++) {
              if (createDebug.skips[i].test(name)) {
                return false;
              }
            }

            for (i = 0, len = createDebug.names.length; i < len; i++) {
              if (createDebug.names[i].test(name)) {
                return true;
              }
            }

            return false;
          }

          /**
          * Convert regexp to namespace
          *
          * @param {RegExp} regxep
          * @return {String} namespace
          * @api private
          */
          function toNamespace(regexp) {
            return regexp.toString()
              .substring(2, regexp.toString().length - 2)
              .replace(/\.\*\?$/, '*');
          }

          /**
          * Coerce `val`.
          *
          * @param {Mixed} val
          * @return {Mixed}
          * @api private
          */
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }

          /**
          * XXX DO NOT USE. This is a temporary stub function.
          * XXX It WILL be removed in the next major release.
          */
          function destroy() {
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
          }

          createDebug.enable(createDebug.load());

          return createDebug;
        }

        module.exports = setup;


        /***/
      }),
/* 17 */
/***/ ((module) => {

        /**
         * Helpers.
         */

        var s = 1000;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;

        /**
         * Parse or format the given `val`.
         *
         * Options:
         *
         *  - `long` verbose formatting [false]
         *
         * @param {String|Number} val
         * @param {Object} [options]
         * @throws {Error} throw an error if val is not a non-empty string or a number
         * @return {String|Number}
         * @api public
         */

        module.exports = function (val, options) {
          options = options || {};
          var type = typeof val;
          if (type === 'string' && val.length > 0) {
            return parse(val);
          } else if (type === 'number' && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            'val is not a non-empty string or a valid number. val=' +
            JSON.stringify(val)
          );
        };

        /**
         * Parse the given `str` and return milliseconds.
         *
         * @param {String} str
         * @return {Number}
         * @api private
         */

        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || 'ms').toLowerCase();
          switch (type) {
            case 'years':
            case 'year':
            case 'yrs':
            case 'yr':
            case 'y':
              return n * y;
            case 'weeks':
            case 'week':
            case 'w':
              return n * w;
            case 'days':
            case 'day':
            case 'd':
              return n * d;
            case 'hours':
            case 'hour':
            case 'hrs':
            case 'hr':
            case 'h':
              return n * h;
            case 'minutes':
            case 'minute':
            case 'mins':
            case 'min':
            case 'm':
              return n * m;
            case 'seconds':
            case 'second':
            case 'secs':
            case 'sec':
            case 's':
              return n * s;
            case 'milliseconds':
            case 'millisecond':
            case 'msecs':
            case 'msec':
            case 'ms':
              return n;
            default:
              return undefined;
          }
        }

        /**
         * Short format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtShort(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return Math.round(ms / d) + 'd';
          }
          if (msAbs >= h) {
            return Math.round(ms / h) + 'h';
          }
          if (msAbs >= m) {
            return Math.round(ms / m) + 'm';
          }
          if (msAbs >= s) {
            return Math.round(ms / s) + 's';
          }
          return ms + 'ms';
        }

        /**
         * Long format for `ms`.
         *
         * @param {Number} ms
         * @return {String}
         * @api private
         */

        function fmtLong(ms) {
          var msAbs = Math.abs(ms);
          if (msAbs >= d) {
            return plural(ms, msAbs, d, 'day');
          }
          if (msAbs >= h) {
            return plural(ms, msAbs, h, 'hour');
          }
          if (msAbs >= m) {
            return plural(ms, msAbs, m, 'minute');
          }
          if (msAbs >= s) {
            return plural(ms, msAbs, s, 'second');
          }
          return ms + ' ms';
        }

        /**
         * Pluralization helper.
         */

        function plural(ms, msAbs, n, name) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
        }


        /***/
      }),
/* 18 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var Utils = __webpack_require__(8);

        var JsSIP_C = __webpack_require__(6);

        var SIPMessage = __webpack_require__(19);

        var RequestSender = __webpack_require__(24);

        var logger = new Logger('Registrator');
        var MIN_REGISTER_EXPIRES = 10; // In seconds.

        module.exports = /*#__PURE__*/function () {
          function Registrator(ua, transport) {
            _classCallCheck(this, Registrator);

            // Force reg_id to 1.
            this._reg_id = 1;
            this._ua = ua;
            this._transport = transport;
            this._registrar = ua.configuration.registrar_server;
            this._expires = ua.configuration.register_expires; // Call-ID and CSeq values RFC3261 10.2.

            this._call_id = Utils.createRandomToken(22);
            this._cseq = 0;
            this._to_uri = ua.configuration.uri;
            this._registrationTimer = null; // Ongoing Register request.

            this._registering = false; // Set status.

            this._registered = false; // Contact header.

            this._contact = this._ua.contact.toString(); // Sip.ice media feature tag (RFC 5768).

            this._contact += ';+sip.ice'; // Custom headers for REGISTER and un-REGISTER.

            this._extraHeaders = []; // Custom Contact header params for REGISTER and un-REGISTER.

            this._extraContactParams = ''; // Contents of the sip.instance Contact header parameter.

            this._sipInstance = "\"<urn:uuid:".concat(this._ua.configuration.instance_id, ">\"");
            this._contact += ";reg-id=".concat(this._reg_id);
            this._contact += ";+sip.instance=".concat(this._sipInstance);
          }

          _createClass(Registrator, [{
            key: "setExtraHeaders",
            value: function setExtraHeaders(extraHeaders) {
              if (!Array.isArray(extraHeaders)) {
                extraHeaders = [];
              }

              this._extraHeaders = extraHeaders.slice();
            }
          }, {
            key: "setExtraContactParams",
            value: function setExtraContactParams(extraContactParams) {
              if (!(extraContactParams instanceof Object)) {
                extraContactParams = {};
              } // Reset it.


              this._extraContactParams = '';

              for (var param_key in extraContactParams) {
                if (Object.prototype.hasOwnProperty.call(extraContactParams, param_key)) {
                  var param_value = extraContactParams[param_key];
                  this._extraContactParams += ";".concat(param_key);

                  if (param_value) {
                    this._extraContactParams += "=".concat(param_value);
                  }
                }
              }
            }
          }, {
            key: "register",
            value: function register() {
              var _this = this;

              if (this._registering) {
                logger.debug('Register request in progress...');
                return;
              }

              var extraHeaders = this._extraHeaders.slice();

              extraHeaders.push("Contact: ".concat(this._contact, ";expires=").concat(this._expires).concat(this._extraContactParams));
              extraHeaders.push("Expires: ".concat(this._expires));
              var request = new SIPMessage.OutgoingRequest(JsSIP_C.REGISTER, this._registrar, this._ua, {
                'to_uri': this._to_uri,
                'call_id': this._call_id,
                'cseq': this._cseq += 1
              }, extraHeaders);
              var request_sender = new RequestSender(this._ua, request, {
                onRequestTimeout: function onRequestTimeout() {
                  _this._registrationFailure(null, JsSIP_C.causes.REQUEST_TIMEOUT);
                },
                onTransportError: function onTransportError() {
                  _this._registrationFailure(null, JsSIP_C.causes.CONNECTION_ERROR);
                },
                // Increase the CSeq on authentication.
                onAuthenticated: function onAuthenticated() {
                  _this._cseq += 1;
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  // Discard responses to older REGISTER/un-REGISTER requests.
                  if (response.cseq !== _this._cseq) {
                    return;
                  } // Clear registration timer.


                  if (_this._registrationTimer !== null) {
                    clearTimeout(_this._registrationTimer);
                    _this._registrationTimer = null;
                  }

                  switch (true) {
                    case /^1[0-9]{2}$/.test(response.status_code):
                      {
                        // Ignore provisional responses.
                        break;
                      }

                    case /^2[0-9]{2}$/.test(response.status_code):
                      {
                        _this._registering = false;

                        if (!response.hasHeader('Contact')) {
                          logger.debug('no Contact header in response to REGISTER, response ignored');
                          break;
                        }

                        var contacts = response.headers['Contact'].reduce(function (a, b) {
                          return a.concat(b.parsed);
                        }, []); // Get the Contact pointing to us and update the expires value accordingly.
                        // Try to find a matching Contact using sip.instance and reg-id.

                        var contact = contacts.find(function (element) {
                          return _this._sipInstance === element.getParam('+sip.instance') && _this._reg_id === parseInt(element.getParam('reg-id'));
                        }); // If no match was found using the sip.instance try comparing the URIs.

                        if (!contact) {
                          contact = contacts.find(function (element) {
                            return element.uri.user === _this._ua.contact.uri.user;
                          });
                        }

                        if (!contact) {
                          logger.debug('no Contact header pointing to us, response ignored');
                          break;
                        }

                        var expires = contact.getParam('expires');

                        if (!expires && response.hasHeader('expires')) {
                          expires = response.getHeader('expires');
                        }

                        if (!expires) {
                          expires = _this._expires;
                        }

                        expires = Number(expires);
                        if (expires < MIN_REGISTER_EXPIRES) expires = MIN_REGISTER_EXPIRES;
                        var timeout = expires > 64 ? expires * 1000 / 2 + Math.floor((expires / 2 - 32) * 1000 * Math.random()) : expires * 1000 - 5000; // Re-Register or emit an event before the expiration interval has elapsed.
                        // For that, decrease the expires value. ie: 3 seconds.

                        _this._registrationTimer = setTimeout(function () {
                          _this._registrationTimer = null; // If there are no listeners for registrationExpiring, renew registration.
                          // If there are listeners, let the function listening do the register call.

                          if (_this._ua.listeners('registrationExpiring').length === 0) {
                            _this.register();
                          } else {
                            _this._ua.emit('registrationExpiring');
                          }
                        }, timeout); // Save gruu values.

                        if (contact.hasParam('temp-gruu')) {
                          _this._ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/"/g, '');
                        }

                        if (contact.hasParam('pub-gruu')) {
                          _this._ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/"/g, '');
                        }

                        if (!_this._registered) {
                          _this._registered = true;

                          _this._ua.registered({
                            response: response
                          });
                        }

                        break;
                      }
                    // Interval too brief RFC3261 10.2.8.

                    case /^423$/.test(response.status_code):
                      {
                        if (response.hasHeader('min-expires')) {
                          // Increase our registration interval to the suggested minimum.
                          _this._expires = Number(response.getHeader('min-expires'));
                          if (_this._expires < MIN_REGISTER_EXPIRES) _this._expires = MIN_REGISTER_EXPIRES; // Attempt the registration again immediately.

                          _this.register();
                        } else {
                          // This response MUST contain a Min-Expires header field.
                          logger.debug('423 response received for REGISTER without Min-Expires');

                          _this._registrationFailure(response, JsSIP_C.causes.SIP_FAILURE_CODE);
                        }

                        break;
                      }

                    default:
                      {
                        var cause = Utils.sipErrorCause(response.status_code);

                        _this._registrationFailure(response, cause);
                      }
                  }
                }
              });
              this._registering = true;
              request_sender.send();
            }
          }, {
            key: "unregister",
            value: function unregister() {
              var _this2 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              if (!this._registered) {
                logger.debug('already unregistered');
                return;
              }

              this._registered = false; // Clear the registration timer.

              if (this._registrationTimer !== null) {
                clearTimeout(this._registrationTimer);
                this._registrationTimer = null;
              }

              var extraHeaders = this._extraHeaders.slice();

              if (options.all) {
                extraHeaders.push("Contact: *".concat(this._extraContactParams));
              } else {
                extraHeaders.push("Contact: ".concat(this._contact, ";expires=0").concat(this._extraContactParams));
              }

              extraHeaders.push('Expires: 0');
              var request = new SIPMessage.OutgoingRequest(JsSIP_C.REGISTER, this._registrar, this._ua, {
                'to_uri': this._to_uri,
                'call_id': this._call_id,
                'cseq': this._cseq += 1
              }, extraHeaders);
              var request_sender = new RequestSender(this._ua, request, {
                onRequestTimeout: function onRequestTimeout() {
                  _this2._unregistered(null, JsSIP_C.causes.REQUEST_TIMEOUT);
                },
                onTransportError: function onTransportError() {
                  _this2._unregistered(null, JsSIP_C.causes.CONNECTION_ERROR);
                },
                // Increase the CSeq on authentication.
                onAuthenticated: function onAuthenticated() {
                  _this2._cseq += 1;
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  switch (true) {
                    case /^1[0-9]{2}$/.test(response.status_code):
                      // Ignore provisional responses.
                      break;

                    case /^2[0-9]{2}$/.test(response.status_code):
                      _this2._unregistered(response);

                      break;

                    default:
                      {
                        var cause = Utils.sipErrorCause(response.status_code);

                        _this2._unregistered(response, cause);
                      }
                  }
                }
              });
              request_sender.send();
            }
          }, {
            key: "close",
            value: function close() {
              if (this._registered) {
                this.unregister();
              }
            }
          }, {
            key: "onTransportClosed",
            value: function onTransportClosed() {
              this._registering = false;

              if (this._registrationTimer !== null) {
                clearTimeout(this._registrationTimer);
                this._registrationTimer = null;
              }

              if (this._registered) {
                this._registered = false;

                this._ua.unregistered({});
              }
            }
          }, {
            key: "_registrationFailure",
            value: function _registrationFailure(response, cause) {
              this._registering = false;

              this._ua.registrationFailed({
                response: response || null,
                cause: cause
              });

              if (this._registered) {
                this._registered = false;

                this._ua.unregistered({
                  response: response || null,
                  cause: cause
                });
              }
            }
          }, {
            key: "_unregistered",
            value: function _unregistered(response, cause) {
              this._registering = false;
              this._registered = false;

              this._ua.unregistered({
                response: response || null,
                cause: cause || null
              });
            }
          }, {
            key: "registered",
            get: function get() {
              return this._registered;
            }
          }]);

          return Registrator;
        }();

        /***/
      }),
/* 19 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var sdp_transform = __webpack_require__(20);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var Utils = __webpack_require__(8);

        var NameAddrHeader = __webpack_require__(11);

        var Grammar = __webpack_require__(10);

        var logger = new Logger('SIPMessage');
        /**
         * -param {String} method request method
         * -param {String} ruri request uri
         * -param {UA} ua
         * -param {Object} params parameters that will have priority over ua.configuration parameters:
         * <br>
         *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set
         * -param {Object} [headers] extra headers
         * -param {String} [body]
         */

        var OutgoingRequest = /*#__PURE__*/function () {
          function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {
            _classCallCheck(this, OutgoingRequest);

            // Mandatory parameters check.
            if (!method || !ruri || !ua) {
              return null;
            }

            params = params || {};
            this.ua = ua;
            this.headers = {};
            this.method = method;
            this.ruri = ruri;
            this.body = body;
            this.extraHeaders = Utils.cloneArray(extraHeaders); // Fill the Common SIP Request Headers.
            // Route.

            if (params.route_set) {
              this.setHeader('route', params.route_set);
            } else if (ua.configuration.use_preloaded_route) {
              this.setHeader('route', "<".concat(ua.transport.sip_uri, ";lr>"));
            } // Via.
            // Empty Via header. Will be filled by the client transaction.


            this.setHeader('via', ''); // Max-Forwards.

            this.setHeader('max-forwards', JsSIP_C.MAX_FORWARDS); // To

            var to_uri = params.to_uri || ruri;
            var to_params = params.to_tag ? {
              tag: params.to_tag
            } : null;
            var to_display_name = typeof params.to_display_name !== 'undefined' ? params.to_display_name : null;
            this.to = new NameAddrHeader(to_uri, to_display_name, to_params);
            this.setHeader('to', this.to.toString()); // From.

            var from_uri = params.from_uri || ua.configuration.uri;
            var from_params = {
              tag: params.from_tag || Utils.newTag()
            };
            var display_name;

            if (typeof params.from_display_name !== 'undefined') {
              display_name = params.from_display_name;
            } else if (ua.configuration.display_name) {
              display_name = ua.configuration.display_name;
            } else {
              display_name = null;
            }

            this.from = new NameAddrHeader(from_uri, display_name, from_params);
            this.setHeader('from', this.from.toString()); // Call-ID.

            var call_id = params.call_id || ua.configuration.jssip_id + Utils.createRandomToken(15);
            this.call_id = call_id;
            this.setHeader('call-id', call_id); // CSeq.

            var cseq = params.cseq || Math.floor(Math.random() * 10000);
            this.cseq = cseq;
            this.setHeader('cseq', "".concat(cseq, " ").concat(method));
          }
          /**
           * Replace the the given header by the given value.
           * -param {String} name header name
           * -param {String | Array} value header value
           */


          _createClass(OutgoingRequest, [{
            key: "setHeader",
            value: function setHeader(name, value) {
              // Remove the header from extraHeaders if present.
              var regexp = new RegExp("^\\s*".concat(name, "\\s*:"), 'i');

              for (var idx = 0; idx < this.extraHeaders.length; idx++) {
                if (regexp.test(this.extraHeaders[idx])) {
                  this.extraHeaders.splice(idx, 1);
                }
              }

              this.headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];
            }
            /**
             * Get the value of the given header name at the given position.
             * -param {String} name header name
             * -returns {String|undefined} Returns the specified header, null if header doesn't exist.
             */

          }, {
            key: "getHeader",
            value: function getHeader(name) {
              var headers = this.headers[Utils.headerize(name)];

              if (headers) {
                if (headers[0]) {
                  return headers[0];
                }
              } else {
                var regexp = new RegExp("^\\s*".concat(name, "\\s*:"), 'i');

                var _iterator = _createForOfIteratorHelper(this.extraHeaders),
                  _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var header = _step.value;

                    if (regexp.test(header)) {
                      return header.substring(header.indexOf(':') + 1).trim();
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }

              return;
            }
            /**
             * Get the header/s of the given name.
             * -param {String} name header name
             * -returns {Array} Array with all the headers of the specified name.
             */

          }, {
            key: "getHeaders",
            value: function getHeaders(name) {
              var headers = this.headers[Utils.headerize(name)];
              var result = [];

              if (headers) {
                var _iterator2 = _createForOfIteratorHelper(headers),
                  _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var header = _step2.value;
                    result.push(header);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }

                return result;
              } else {
                var regexp = new RegExp("^\\s*".concat(name, "\\s*:"), 'i');

                var _iterator3 = _createForOfIteratorHelper(this.extraHeaders),
                  _step3;

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var _header = _step3.value;

                    if (regexp.test(_header)) {
                      result.push(_header.substring(_header.indexOf(':') + 1).trim());
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                return result;
              }
            }
            /**
             * Verify the existence of the given header.
             * -param {String} name header name
             * -returns {boolean} true if header with given name exists, false otherwise
             */

          }, {
            key: "hasHeader",
            value: function hasHeader(name) {
              if (this.headers[Utils.headerize(name)]) {
                return true;
              } else {
                var regexp = new RegExp("^\\s*".concat(name, "\\s*:"), 'i');

                var _iterator4 = _createForOfIteratorHelper(this.extraHeaders),
                  _step4;

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var header = _step4.value;

                    if (regexp.test(header)) {
                      return true;
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }

              return false;
            }
            /**
             * Parse the current body as a SDP and store the resulting object
             * into this.sdp.
             * -param {Boolean} force: Parse even if this.sdp already exists.
             *
             * Returns this.sdp.
             */

          }, {
            key: "parseSDP",
            value: function parseSDP(force) {
              if (!force && this.sdp) {
                return this.sdp;
              } else {
                this.sdp = sdp_transform.parse(this.body || '');
                return this.sdp;
              }
            }
          }, {
            key: "toString",
            value: function toString() {
              var msg = "".concat(this.method, " ").concat(this.ruri, " SIP/2.0\r\n");

              for (var headerName in this.headers) {
                if (Object.prototype.hasOwnProperty.call(this.headers, headerName)) {
                  var _iterator5 = _createForOfIteratorHelper(this.headers[headerName]),
                    _step5;

                  try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                      var headerValue = _step5.value;
                      msg += "".concat(headerName, ": ").concat(headerValue, "\r\n");
                    }
                  } catch (err) {
                    _iterator5.e(err);
                  } finally {
                    _iterator5.f();
                  }
                }
              }

              var _iterator6 = _createForOfIteratorHelper(this.extraHeaders),
                _step6;

              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var header = _step6.value;
                  msg += "".concat(header.trim(), "\r\n");
                } // Supported.

              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }

              var supported = [];

              switch (this.method) {
                case JsSIP_C.REGISTER:
                  supported.push('path', 'gruu');
                  break;

                case JsSIP_C.INVITE:
                  if (this.ua.configuration.session_timers) {
                    supported.push('timer');
                  }

                  if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
                    supported.push('gruu');
                  }

                  supported.push('ice', 'replaces');
                  break;

                case JsSIP_C.UPDATE:
                  if (this.ua.configuration.session_timers) {
                    supported.push('timer');
                  }

                  supported.push('ice');
                  break;
              }

              supported.push('outbound');
              var userAgent = this.ua.configuration.user_agent || JsSIP_C.USER_AGENT; // Allow.

              msg += "Allow: ".concat(JsSIP_C.ALLOWED_METHODS, "\r\n");
              msg += "Supported: ".concat(supported, "\r\n");
              msg += "User-Agent: ".concat(userAgent, "\r\n");

              if (this.body) {
                var length = Utils.str_utf8_length(this.body);
                msg += "Content-Length: ".concat(length, "\r\n\r\n");
                msg += this.body;
              } else {
                msg += 'Content-Length: 0\r\n\r\n';
              }

              return msg;
            }
          }, {
            key: "clone",
            value: function clone() {
              var request = new OutgoingRequest(this.method, this.ruri, this.ua);
              Object.keys(this.headers).forEach(function (name) {
                request.headers[name] = this.headers[name].slice();
              }, this);
              request.body = this.body;
              request.extraHeaders = Utils.cloneArray(this.extraHeaders);
              request.to = this.to;
              request.from = this.from;
              request.call_id = this.call_id;
              request.cseq = this.cseq;
              return request;
            }
          }]);

          return OutgoingRequest;
        }();

        var InitialOutgoingInviteRequest = /*#__PURE__*/function (_OutgoingRequest) {
          _inherits(InitialOutgoingInviteRequest, _OutgoingRequest);

          var _super = _createSuper(InitialOutgoingInviteRequest);

          function InitialOutgoingInviteRequest(ruri, ua, params, extraHeaders, body) {
            var _this;

            _classCallCheck(this, InitialOutgoingInviteRequest);

            _this = _super.call(this, JsSIP_C.INVITE, ruri, ua, params, extraHeaders, body);
            _this.transaction = null;
            return _this;
          }

          _createClass(InitialOutgoingInviteRequest, [{
            key: "cancel",
            value: function cancel(reason) {
              this.transaction.cancel(reason);
            }
          }, {
            key: "clone",
            value: function clone() {
              var request = new InitialOutgoingInviteRequest(this.ruri, this.ua);
              Object.keys(this.headers).forEach(function (name) {
                request.headers[name] = this.headers[name].slice();
              }, this);
              request.body = this.body;
              request.extraHeaders = Utils.cloneArray(this.extraHeaders);
              request.to = this.to;
              request.from = this.from;
              request.call_id = this.call_id;
              request.cseq = this.cseq;
              request.transaction = this.transaction;
              return request;
            }
          }]);

          return InitialOutgoingInviteRequest;
        }(OutgoingRequest);

        var IncomingMessage = /*#__PURE__*/function () {
          function IncomingMessage() {
            _classCallCheck(this, IncomingMessage);

            this.data = null;
            this.headers = null;
            this.method = null;
            this.via = null;
            this.via_branch = null;
            this.call_id = null;
            this.cseq = null;
            this.from = null;
            this.from_tag = null;
            this.to = null;
            this.to_tag = null;
            this.body = null;
            this.sdp = null;
          }
          /**
          * Insert a header of the given name and value into the last position of the
          * header array.
          */


          _createClass(IncomingMessage, [{
            key: "addHeader",
            value: function addHeader(name, value) {
              var header = {
                raw: value
              };
              name = Utils.headerize(name);

              if (this.headers[name]) {
                this.headers[name].push(header);
              } else {
                this.headers[name] = [header];
              }
            }
            /**
             * Get the value of the given header name at the given position.
             */

          }, {
            key: "getHeader",
            value: function getHeader(name) {
              var header = this.headers[Utils.headerize(name)];

              if (header) {
                if (header[0]) {
                  return header[0].raw;
                }
              } else {
                return;
              }
            }
            /**
             * Get the header/s of the given name.
             */

          }, {
            key: "getHeaders",
            value: function getHeaders(name) {
              var headers = this.headers[Utils.headerize(name)];
              var result = [];

              if (!headers) {
                return [];
              }

              var _iterator7 = _createForOfIteratorHelper(headers),
                _step7;

              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var header = _step7.value;
                  result.push(header.raw);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }

              return result;
            }
            /**
             * Verify the existence of the given header.
             */

          }, {
            key: "hasHeader",
            value: function hasHeader(name) {
              return this.headers[Utils.headerize(name)] ? true : false;
            }
            /**
            * Parse the given header on the given index.
            * -param {String} name header name
            * -param {Number} [idx=0] header index
            * -returns {Object|undefined} Parsed header object, undefined if the header
            *  is not present or in case of a parsing error.
            */

          }, {
            key: "parseHeader",
            value: function parseHeader(name) {
              var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              name = Utils.headerize(name);

              if (!this.headers[name]) {
                logger.debug("header \"".concat(name, "\" not present"));
                return;
              } else if (idx >= this.headers[name].length) {
                logger.debug("not so many \"".concat(name, "\" headers present"));
                return;
              }

              var header = this.headers[name][idx];
              var value = header.raw;

              if (header.parsed) {
                return header.parsed;
              } // Substitute '-' by '_' for grammar rule matching.


              var parsed = Grammar.parse(value, name.replace(/-/g, '_'));

              if (parsed === -1) {
                this.headers[name].splice(idx, 1); // delete from headers

                logger.debug("error parsing \"".concat(name, "\" header field with value \"").concat(value, "\""));
                return;
              } else {
                header.parsed = parsed;
                return parsed;
              }
            }
            /**
             * Message Header attribute selector. Alias of parseHeader.
             * -param {String} name header name
             * -param {Number} [idx=0] header index
             * -returns {Object|undefined} Parsed header object, undefined if the header
             *  is not present or in case of a parsing error.
             *
             * -example
             * message.s('via',3).port
             */

          }, {
            key: "s",
            value: function s(name, idx) {
              return this.parseHeader(name, idx);
            }
            /**
            * Replace the value of the given header by the value.
            * -param {String} name header name
            * -param {String} value header value
            */

          }, {
            key: "setHeader",
            value: function setHeader(name, value) {
              var header = {
                raw: value
              };
              this.headers[Utils.headerize(name)] = [header];
            }
            /**
             * Parse the current body as a SDP and store the resulting object
             * into this.sdp.
             * -param {Boolean} force: Parse even if this.sdp already exists.
             *
             * Returns this.sdp.
             */

          }, {
            key: "parseSDP",
            value: function parseSDP(force) {
              if (!force && this.sdp) {
                return this.sdp;
              } else {
                this.sdp = sdp_transform.parse(this.body || '');
                return this.sdp;
              }
            }
          }, {
            key: "toString",
            value: function toString() {
              return this.data;
            }
          }]);

          return IncomingMessage;
        }();

        var IncomingRequest = /*#__PURE__*/function (_IncomingMessage) {
          _inherits(IncomingRequest, _IncomingMessage);

          var _super2 = _createSuper(IncomingRequest);

          function IncomingRequest(ua) {
            var _this2;

            _classCallCheck(this, IncomingRequest);

            _this2 = _super2.call(this);
            _this2.ua = ua;
            _this2.headers = {};
            _this2.ruri = null;
            _this2.transport = null;
            _this2.server_transaction = null;
            return _this2;
          }
          /**
          * Stateful reply.
          * -param {Number} code status code
          * -param {String} reason reason phrase
          * -param {Object} headers extra headers
          * -param {String} body body
          * -param {Function} [onSuccess] onSuccess callback
          * -param {Function} [onFailure] onFailure callback
          */


          _createClass(IncomingRequest, [{
            key: "reply",
            value: function reply(code, reason, extraHeaders, body, onSuccess, onFailure) {
              var supported = [];
              var to = this.getHeader('To');
              code = code || null;
              reason = reason || null; // Validate code and reason values.

              if (!code || code < 100 || code > 699) {
                throw new TypeError("Invalid status_code: ".concat(code));
              } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
                throw new TypeError("Invalid reason_phrase: ".concat(reason));
              }

              reason = reason || JsSIP_C.REASON_PHRASE[code] || '';
              extraHeaders = Utils.cloneArray(extraHeaders);
              var response = "SIP/2.0 ".concat(code, " ").concat(reason, "\r\n");

              if (this.method === JsSIP_C.INVITE && code > 100 && code <= 200) {
                var headers = this.getHeaders('record-route');

                var _iterator8 = _createForOfIteratorHelper(headers),
                  _step8;

                try {
                  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                    var header = _step8.value;
                    response += "Record-Route: ".concat(header, "\r\n");
                  }
                } catch (err) {
                  _iterator8.e(err);
                } finally {
                  _iterator8.f();
                }
              }

              var vias = this.getHeaders('via');

              var _iterator9 = _createForOfIteratorHelper(vias),
                _step9;

              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var via = _step9.value;
                  response += "Via: ".concat(via, "\r\n");
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }

              if (!this.to_tag && code > 100) {
                to += ";tag=".concat(Utils.newTag());
              } else if (this.to_tag && !this.s('to').hasParam('tag')) {
                to += ";tag=".concat(this.to_tag);
              }

              response += "To: ".concat(to, "\r\n");
              response += "From: ".concat(this.getHeader('From'), "\r\n");
              response += "Call-ID: ".concat(this.call_id, "\r\n");
              response += "CSeq: ".concat(this.cseq, " ").concat(this.method, "\r\n");

              var _iterator10 = _createForOfIteratorHelper(extraHeaders),
                _step10;

              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var _header2 = _step10.value;
                  response += "".concat(_header2.trim(), "\r\n");
                } // Supported.

              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }

              switch (this.method) {
                case JsSIP_C.INVITE:
                  if (this.ua.configuration.session_timers) {
                    supported.push('timer');
                  }

                  if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
                    supported.push('gruu');
                  }

                  supported.push('ice', 'replaces');
                  break;

                case JsSIP_C.UPDATE:
                  if (this.ua.configuration.session_timers) {
                    supported.push('timer');
                  }

                  if (body) {
                    supported.push('ice');
                  }

                  supported.push('replaces');
              }

              supported.push('outbound'); // Allow and Accept.

              if (this.method === JsSIP_C.OPTIONS) {
                response += "Allow: ".concat(JsSIP_C.ALLOWED_METHODS, "\r\n");
                response += "Accept: ".concat(JsSIP_C.ACCEPTED_BODY_TYPES, "\r\n");
              } else if (code === 405) {
                response += "Allow: ".concat(JsSIP_C.ALLOWED_METHODS, "\r\n");
              } else if (code === 415) {
                response += "Accept: ".concat(JsSIP_C.ACCEPTED_BODY_TYPES, "\r\n");
              }

              response += "Supported: ".concat(supported, "\r\n");

              if (body) {
                var length = Utils.str_utf8_length(body);
                response += 'Content-Type: application/sdp\r\n';
                response += "Content-Length: ".concat(length, "\r\n\r\n");
                response += body;
              } else {
                response += "Content-Length: ".concat(0, "\r\n\r\n");
              }

              this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);
            }
            /**
            * Stateless reply.
            * -param {Number} code status code
            * -param {String} reason reason phrase
            */

          }, {
            key: "reply_sl",
            value: function reply_sl() {
              var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var vias = this.getHeaders('via'); // Validate code and reason values.

              if (!code || code < 100 || code > 699) {
                throw new TypeError("Invalid status_code: ".concat(code));
              } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
                throw new TypeError("Invalid reason_phrase: ".concat(reason));
              }

              reason = reason || JsSIP_C.REASON_PHRASE[code] || '';
              var response = "SIP/2.0 ".concat(code, " ").concat(reason, "\r\n");

              var _iterator11 = _createForOfIteratorHelper(vias),
                _step11;

              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  var via = _step11.value;
                  response += "Via: ".concat(via, "\r\n");
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }

              var to = this.getHeader('To');

              if (!this.to_tag && code > 100) {
                to += ";tag=".concat(Utils.newTag());
              } else if (this.to_tag && !this.s('to').hasParam('tag')) {
                to += ";tag=".concat(this.to_tag);
              }

              response += "To: ".concat(to, "\r\n");
              response += "From: ".concat(this.getHeader('From'), "\r\n");
              response += "Call-ID: ".concat(this.call_id, "\r\n");
              response += "CSeq: ".concat(this.cseq, " ").concat(this.method, "\r\n");
              response += "Content-Length: ".concat(0, "\r\n\r\n");
              this.transport.send(response);
            }
          }]);

          return IncomingRequest;
        }(IncomingMessage);

        var IncomingResponse = /*#__PURE__*/function (_IncomingMessage2) {
          _inherits(IncomingResponse, _IncomingMessage2);

          var _super3 = _createSuper(IncomingResponse);

          function IncomingResponse() {
            var _this3;

            _classCallCheck(this, IncomingResponse);

            _this3 = _super3.call(this);
            _this3.headers = {};
            _this3.status_code = null;
            _this3.reason_phrase = null;
            return _this3;
          }

          return IncomingResponse;
        }(IncomingMessage);

        module.exports = {
          OutgoingRequest: OutgoingRequest,
          InitialOutgoingInviteRequest: InitialOutgoingInviteRequest,
          IncomingRequest: IncomingRequest,
          IncomingResponse: IncomingResponse
        };

        /***/
      }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        var parser = __webpack_require__(21);
        var writer = __webpack_require__(23);

        exports.write = writer;
        exports.parse = parser.parse;
        exports.parseParams = parser.parseParams;
        exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
        exports.parsePayloads = parser.parsePayloads;
        exports.parseRemoteCandidates = parser.parseRemoteCandidates;
        exports.parseImageAttributes = parser.parseImageAttributes;
        exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;


        /***/
      }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        var toIntIfInt = function (v) {
          return String(Number(v)) === v ? Number(v) : v;
        };

        var attachProperties = function (match, location, names, rawName) {
          if (rawName && !names) {
            location[rawName] = toIntIfInt(match[1]);
          }
          else {
            for (var i = 0; i < names.length; i += 1) {
              if (match[i + 1] != null) {
                location[names[i]] = toIntIfInt(match[i + 1]);
              }
            }
          }
        };

        var parseReg = function (obj, location, content) {
          var needsBlank = obj.name && obj.names;
          if (obj.push && !location[obj.push]) {
            location[obj.push] = [];
          }
          else if (needsBlank && !location[obj.name]) {
            location[obj.name] = {};
          }
          var keyLocation = obj.push ?
            {} :  // blank object that will be pushed
            needsBlank ? location[obj.name] : location; // otherwise, named location or root

          attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

          if (obj.push) {
            location[obj.push].push(keyLocation);
          }
        };

        var grammar = __webpack_require__(22);
        var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

        exports.parse = function (sdp) {
          var session = {}
            , media = []
            , location = session; // points at where properties go under (one of the above)

          // parse lines we understand
          sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
            var type = l[0];
            var content = l.slice(2);
            if (type === 'm') {
              media.push({ rtp: [], fmtp: [] });
              location = media[media.length - 1]; // point at latest media line
            }

            for (var j = 0; j < (grammar[type] || []).length; j += 1) {
              var obj = grammar[type][j];
              if (obj.reg.test(content)) {
                return parseReg(obj, location, content);
              }
            }
          });

          session.media = media; // link it up
          return session;
        };

        var paramReducer = function (acc, expr) {
          var s = expr.split(/=(.+)/, 2);
          if (s.length === 2) {
            acc[s[0]] = toIntIfInt(s[1]);
          } else if (s.length === 1 && expr.length > 1) {
            acc[s[0]] = undefined;
          }
          return acc;
        };

        exports.parseParams = function (str) {
          return str.split(/;\s?/).reduce(paramReducer, {});
        };

        // For backward compatibility - alias will be removed in 3.0.0
        exports.parseFmtpConfig = exports.parseParams;

        exports.parsePayloads = function (str) {
          return str.toString().split(' ').map(Number);
        };

        exports.parseRemoteCandidates = function (str) {
          var candidates = [];
          var parts = str.split(' ').map(toIntIfInt);
          for (var i = 0; i < parts.length; i += 3) {
            candidates.push({
              component: parts[i],
              ip: parts[i + 1],
              port: parts[i + 2]
            });
          }
          return candidates;
        };

        exports.parseImageAttributes = function (str) {
          return str.split(' ').map(function (item) {
            return item.substring(1, item.length - 1).split(',').reduce(paramReducer, {});
          });
        };

        exports.parseSimulcastStreamList = function (str) {
          return str.split(';').map(function (stream) {
            return stream.split(',').map(function (format) {
              var scid, paused = false;

              if (format[0] !== '~') {
                scid = toIntIfInt(format);
              } else {
                scid = toIntIfInt(format.substring(1, format.length));
                paused = true;
              }

              return {
                scid: scid,
                paused: paused
              };
            });
          });
        };


        /***/
      }),
/* 22 */
/***/ ((module) => {

        var grammar = module.exports = {
          v: [{
            name: 'version',
            reg: /^(\d*)$/
          }],
          o: [{
            // o=- 20518 0 IN IP4 203.0.113.1
            // NB: sessionId will be a String in most cases because it is huge
            name: 'origin',
            reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
            names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
            format: '%s %s %d %s IP%d %s'
          }],
          // default parsing of these only (though some of these feel outdated)
          s: [{ name: 'name' }],
          i: [{ name: 'description' }],
          u: [{ name: 'uri' }],
          e: [{ name: 'email' }],
          p: [{ name: 'phone' }],
          z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
          r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
          // k: [{}], // outdated thing ignored
          t: [{
            // t=0 0
            name: 'timing',
            reg: /^(\d*) (\d*)/,
            names: ['start', 'stop'],
            format: '%d %d'
          }],
          c: [{
            // c=IN IP4 10.47.197.26
            name: 'connection',
            reg: /^IN IP(\d) (\S*)/,
            names: ['version', 'ip'],
            format: 'IN IP%d %s'
          }],
          b: [{
            // b=AS:4000
            push: 'bandwidth',
            reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
            names: ['type', 'limit'],
            format: '%s:%s'
          }],
          m: [{
            // m=video 51744 RTP/AVP 126 97 98 34 31
            // NB: special - pushes to session
            // TODO: rtp/fmtp should be filtered by the payloads found here?
            reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
            names: ['type', 'port', 'protocol', 'payloads'],
            format: '%s %d %s %s'
          }],
          a: [
            {
              // a=rtpmap:110 opus/48000/2
              push: 'rtp',
              reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
              names: ['payload', 'codec', 'rate', 'encoding'],
              format: function (o) {
                return (o.encoding)
                  ? 'rtpmap:%d %s/%s/%s'
                  : o.rate
                    ? 'rtpmap:%d %s/%s'
                    : 'rtpmap:%d %s';
              }
            },
            {
              // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
              // a=fmtp:111 minptime=10; useinbandfec=1
              push: 'fmtp',
              reg: /^fmtp:(\d*) ([\S| ]*)/,
              names: ['payload', 'config'],
              format: 'fmtp:%d %s'
            },
            {
              // a=control:streamid=0
              name: 'control',
              reg: /^control:(.*)/,
              format: 'control:%s'
            },
            {
              // a=rtcp:65179 IN IP4 193.84.77.194
              name: 'rtcp',
              reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
              names: ['port', 'netType', 'ipVer', 'address'],
              format: function (o) {
                return (o.address != null)
                  ? 'rtcp:%d %s IP%d %s'
                  : 'rtcp:%d';
              }
            },
            {
              // a=rtcp-fb:98 trr-int 100
              push: 'rtcpFbTrrInt',
              reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
              names: ['payload', 'value'],
              format: 'rtcp-fb:%s trr-int %d'
            },
            {
              // a=rtcp-fb:98 nack rpsi
              push: 'rtcpFb',
              reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
              names: ['payload', 'type', 'subtype'],
              format: function (o) {
                return (o.subtype != null)
                  ? 'rtcp-fb:%s %s %s'
                  : 'rtcp-fb:%s %s';
              }
            },
            {
              // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
              // a=extmap:1/recvonly URI-gps-string
              // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
              push: 'ext',
              reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
              names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
              format: function (o) {
                return (
                  'extmap:%d' +
                  (o.direction ? '/%s' : '%v') +
                  (o['encrypt-uri'] ? ' %s' : '%v') +
                  ' %s' +
                  (o.config ? ' %s' : '')
                );
              }
            },
            {
              // a=extmap-allow-mixed
              name: 'extmapAllowMixed',
              reg: /^(extmap-allow-mixed)/
            },
            {
              // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
              push: 'crypto',
              reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
              names: ['id', 'suite', 'config', 'sessionConfig'],
              format: function (o) {
                return (o.sessionConfig != null)
                  ? 'crypto:%d %s %s %s'
                  : 'crypto:%d %s %s';
              }
            },
            {
              // a=setup:actpass
              name: 'setup',
              reg: /^setup:(\w*)/,
              format: 'setup:%s'
            },
            {
              // a=connection:new
              name: 'connectionType',
              reg: /^connection:(new|existing)/,
              format: 'connection:%s'
            },
            {
              // a=mid:1
              name: 'mid',
              reg: /^mid:([^\s]*)/,
              format: 'mid:%s'
            },
            {
              // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
              name: 'msid',
              reg: /^msid:(.*)/,
              format: 'msid:%s'
            },
            {
              // a=ptime:20
              name: 'ptime',
              reg: /^ptime:(\d*(?:\.\d*)*)/,
              format: 'ptime:%d'
            },
            {
              // a=maxptime:60
              name: 'maxptime',
              reg: /^maxptime:(\d*(?:\.\d*)*)/,
              format: 'maxptime:%d'
            },
            {
              // a=sendrecv
              name: 'direction',
              reg: /^(sendrecv|recvonly|sendonly|inactive)/
            },
            {
              // a=ice-lite
              name: 'icelite',
              reg: /^(ice-lite)/
            },
            {
              // a=ice-ufrag:F7gI
              name: 'iceUfrag',
              reg: /^ice-ufrag:(\S*)/,
              format: 'ice-ufrag:%s'
            },
            {
              // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
              name: 'icePwd',
              reg: /^ice-pwd:(\S*)/,
              format: 'ice-pwd:%s'
            },
            {
              // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
              name: 'fingerprint',
              reg: /^fingerprint:(\S*) (\S*)/,
              names: ['type', 'hash'],
              format: 'fingerprint:%s %s'
            },
            {
              // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
              // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
              // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
              // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
              // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
              push: 'candidates',
              reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
              names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
              format: function (o) {
                var str = 'candidate:%s %d %s %d %s %d typ %s';

                str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';

                // NB: candidate has three optional chunks, so %void middles one if it's missing
                str += (o.tcptype != null) ? ' tcptype %s' : '%v';

                if (o.generation != null) {
                  str += ' generation %d';
                }

                str += (o['network-id'] != null) ? ' network-id %d' : '%v';
                str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
                return str;
              }
            },
            {
              // a=end-of-candidates (keep after the candidates line for readability)
              name: 'endOfCandidates',
              reg: /^(end-of-candidates)/
            },
            {
              // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
              name: 'remoteCandidates',
              reg: /^remote-candidates:(.*)/,
              format: 'remote-candidates:%s'
            },
            {
              // a=ice-options:google-ice
              name: 'iceOptions',
              reg: /^ice-options:(\S*)/,
              format: 'ice-options:%s'
            },
            {
              // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
              push: 'ssrcs',
              reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
              names: ['id', 'attribute', 'value'],
              format: function (o) {
                var str = 'ssrc:%d';
                if (o.attribute != null) {
                  str += ' %s';
                  if (o.value != null) {
                    str += ':%s';
                  }
                }
                return str;
              }
            },
            {
              // a=ssrc-group:FEC 1 2
              // a=ssrc-group:FEC-FR 3004364195 1080772241
              push: 'ssrcGroups',
              // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
              reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
              names: ['semantics', 'ssrcs'],
              format: 'ssrc-group:%s %s'
            },
            {
              // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
              name: 'msidSemantic',
              reg: /^msid-semantic:\s?(\w*) (\S*)/,
              names: ['semantic', 'token'],
              format: 'msid-semantic: %s %s' // space after ':' is not accidental
            },
            {
              // a=group:BUNDLE audio video
              push: 'groups',
              reg: /^group:(\w*) (.*)/,
              names: ['type', 'mids'],
              format: 'group:%s %s'
            },
            {
              // a=rtcp-mux
              name: 'rtcpMux',
              reg: /^(rtcp-mux)/
            },
            {
              // a=rtcp-rsize
              name: 'rtcpRsize',
              reg: /^(rtcp-rsize)/
            },
            {
              // a=sctpmap:5000 webrtc-datachannel 1024
              name: 'sctpmap',
              reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
              names: ['sctpmapNumber', 'app', 'maxMessageSize'],
              format: function (o) {
                return (o.maxMessageSize != null)
                  ? 'sctpmap:%s %s %s'
                  : 'sctpmap:%s %s';
              }
            },
            {
              // a=x-google-flag:conference
              name: 'xGoogleFlag',
              reg: /^x-google-flag:([^\s]*)/,
              format: 'x-google-flag:%s'
            },
            {
              // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
              push: 'rids',
              reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
              names: ['id', 'direction', 'params'],
              format: function (o) {
                return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
              }
            },
            {
              // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
              // a=imageattr:* send [x=800,y=640] recv *
              // a=imageattr:100 recv [x=320,y=240]
              push: 'imageattrs',
              reg: new RegExp(
                // a=imageattr:97
                '^imageattr:(\\d+|\\*)' +
                // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
                '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
                // recv [x=330,y=250]
                '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
              ),
              names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
              format: function (o) {
                return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
              }
            },
            {
              // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
              // a=simulcast:recv 1;4,5 send 6;7
              name: 'simulcast',
              reg: new RegExp(
                // a=simulcast:
                '^simulcast:' +
                // send 1,2,3;~4,~5
                '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
                // space + recv 6;~7,~8
                '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
                // end
                '$'
              ),
              names: ['dir1', 'list1', 'dir2', 'list2'],
              format: function (o) {
                return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
              }
            },
            {
              // old simulcast draft 03 (implemented by Firefox)
              //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
              // a=simulcast: recv pt=97;98 send pt=97
              // a=simulcast: send rid=5;6;7 paused=6,7
              name: 'simulcast_03',
              reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
              names: ['value'],
              format: 'simulcast: %s'
            },
            {
              // a=framerate:25
              // a=framerate:29.97
              name: 'framerate',
              reg: /^framerate:(\d+(?:$|\.\d+))/,
              format: 'framerate:%s'
            },
            {
              // RFC4570
              // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
              name: 'sourceFilter',
              reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
              names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
              format: 'source-filter: %s %s %s %s %s'
            },
            {
              // a=bundle-only
              name: 'bundleOnly',
              reg: /^(bundle-only)/
            },
            {
              // a=label:1
              name: 'label',
              reg: /^label:(.+)/,
              format: 'label:%s'
            },
            {
              // RFC version 26 for SCTP over DTLS
              // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
              name: 'sctpPort',
              reg: /^sctp-port:(\d+)$/,
              format: 'sctp-port:%s'
            },
            {
              // RFC version 26 for SCTP over DTLS
              // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
              name: 'maxMessageSize',
              reg: /^max-message-size:(\d+)$/,
              format: 'max-message-size:%s'
            },
            {
              // RFC7273
              // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
              push: 'tsRefClocks',
              reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
              names: ['clksrc', 'clksrcExt'],
              format: function (o) {
                return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
              }
            },
            {
              // RFC7273
              // a=mediaclk:direct=963214424
              name: 'mediaClk',
              reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
              names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
              format: function (o) {
                var str = 'mediaclk:';
                str += (o.id != null ? 'id=%s %s' : '%v%s');
                str += (o.mediaClockValue != null ? '=%s' : '');
                str += (o.rateNumerator != null ? ' rate=%s' : '');
                str += (o.rateDenominator != null ? '/%s' : '');
                return str;
              }
            },
            {
              // a=keywds:keywords
              name: 'keywords',
              reg: /^keywds:(.+)$/,
              format: 'keywds:%s'
            },
            {
              // a=content:main
              name: 'content',
              reg: /^content:(.+)/,
              format: 'content:%s'
            },
            // BFCP https://tools.ietf.org/html/rfc4583
            {
              // a=floorctrl:c-s
              name: 'bfcpFloorCtrl',
              reg: /^floorctrl:(c-only|s-only|c-s)/,
              format: 'floorctrl:%s'
            },
            {
              // a=confid:1
              name: 'bfcpConfId',
              reg: /^confid:(\d+)/,
              format: 'confid:%s'
            },
            {
              // a=userid:1
              name: 'bfcpUserId',
              reg: /^userid:(\d+)/,
              format: 'userid:%s'
            },
            {
              // a=floorid:1
              name: 'bfcpFloorId',
              reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
              names: ['id', 'mStream'],
              format: 'floorid:%s mstrm:%s'
            },
            {
              // any a= that we don't understand is kept verbatim on media.invalid
              push: 'invalid',
              names: ['value']
            }
          ]
        };

        // set sensible defaults to avoid polluting the grammar with boring details
        Object.keys(grammar).forEach(function (key) {
          var objs = grammar[key];
          objs.forEach(function (obj) {
            if (!obj.reg) {
              obj.reg = /(.*)/;
            }
            if (!obj.format) {
              obj.format = '%s';
            }
          });
        });


        /***/
      }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        var grammar = __webpack_require__(22);

        // customized util.format - discards excess arguments and can void middle ones
        var formatRegExp = /%[sdv%]/g;
        var format = function (formatStr) {
          var i = 1;
          var args = arguments;
          var len = args.length;
          return formatStr.replace(formatRegExp, function (x) {
            if (i >= len) {
              return x; // missing argument
            }
            var arg = args[i];
            i += 1;
            switch (x) {
              case '%%':
                return '%';
              case '%s':
                return String(arg);
              case '%d':
                return Number(arg);
              case '%v':
                return '';
            }
          });
          // NB: we discard excess arguments - they are typically undefined from makeLine
        };

        var makeLine = function (type, obj, location) {
          var str = obj.format instanceof Function ?
            (obj.format(obj.push ? location : location[obj.name])) :
            obj.format;

          var args = [type + '=' + str];
          if (obj.names) {
            for (var i = 0; i < obj.names.length; i += 1) {
              var n = obj.names[i];
              if (obj.name) {
                args.push(location[obj.name][n]);
              }
              else { // for mLine and push attributes
                args.push(location[obj.names[i]]);
              }
            }
          }
          else {
            args.push(location[obj.name]);
          }
          return format.apply(null, args);
        };

        // RFC specified order
        // TODO: extend this with all the rest
        var defaultOuterOrder = [
          'v', 'o', 's', 'i',
          'u', 'e', 'p', 'c',
          'b', 't', 'r', 'z', 'a'
        ];
        var defaultInnerOrder = ['i', 'c', 'b', 'a'];


        module.exports = function (session, opts) {
          opts = opts || {};
          // ensure certain properties exist
          if (session.version == null) {
            session.version = 0; // 'v=0' must be there (only defined version atm)
          }
          if (session.name == null) {
            session.name = ' '; // 's= ' must be there if no meaningful name set
          }
          session.media.forEach(function (mLine) {
            if (mLine.payloads == null) {
              mLine.payloads = '';
            }
          });

          var outerOrder = opts.outerOrder || defaultOuterOrder;
          var innerOrder = opts.innerOrder || defaultInnerOrder;
          var sdp = [];

          // loop through outerOrder for matching properties on session
          outerOrder.forEach(function (type) {
            grammar[type].forEach(function (obj) {
              if (obj.name in session && session[obj.name] != null) {
                sdp.push(makeLine(type, obj, session));
              }
              else if (obj.push in session && session[obj.push] != null) {
                session[obj.push].forEach(function (el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });

          // then for each media line, follow the innerOrder
          session.media.forEach(function (mLine) {
            sdp.push(makeLine('m', grammar.m[0], mLine));

            innerOrder.forEach(function (type) {
              grammar[type].forEach(function (obj) {
                if (obj.name in mLine && mLine[obj.name] != null) {
                  sdp.push(makeLine(type, obj, mLine));
                }
                else if (obj.push in mLine && mLine[obj.push] != null) {
                  mLine[obj.push].forEach(function (el) {
                    sdp.push(makeLine(type, obj, el));
                  });
                }
              });
            });
          });

          return sdp.join('\r\n') + '\r\n';
        };


        /***/
      }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var DigestAuthentication = __webpack_require__(25);

        var Transactions = __webpack_require__(26);

        var logger = new Logger('RequestSender'); // Default event handlers.

        var EventHandlers = {
          onRequestTimeout: function onRequestTimeout() { },
          onTransportError: function onTransportError() { },
          onReceiveResponse: function onReceiveResponse() { },
          onAuthenticated: function onAuthenticated() { }
        };

        module.exports = /*#__PURE__*/function () {
          function RequestSender(ua, request, eventHandlers) {
            _classCallCheck(this, RequestSender);

            this._ua = ua;
            this._eventHandlers = eventHandlers;
            this._method = request.method;
            this._request = request;
            this._auth = null;
            this._challenged = false;
            this._staled = false; // Define the undefined handlers.

            for (var handler in EventHandlers) {
              if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {
                if (!this._eventHandlers[handler]) {
                  this._eventHandlers[handler] = EventHandlers[handler];
                }
              }
            } // If ua is in closing process or even closed just allow sending Bye and ACK.


            if (ua.status === ua.C.STATUS_USER_CLOSED && (this._method !== JsSIP_C.BYE || this._method !== JsSIP_C.ACK)) {
              this._eventHandlers.onTransportError();
            }
          }
          /**
          * Create the client transaction and send the message.
          */


          _createClass(RequestSender, [{
            key: "send",
            value: function send() {
              var _this = this;

              var eventHandlers = {
                onRequestTimeout: function onRequestTimeout() {
                  _this._eventHandlers.onRequestTimeout();
                },
                onTransportError: function onTransportError() {
                  _this._eventHandlers.onTransportError();
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  _this._receiveResponse(response);
                }
              };

              switch (this._method) {
                case 'INVITE':
                  this.clientTransaction = new Transactions.InviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);
                  break;

                case 'ACK':
                  this.clientTransaction = new Transactions.AckClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);
                  break;

                default:
                  this.clientTransaction = new Transactions.NonInviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);
              } // If authorization JWT is present, use it.


              if (this._ua._configuration.authorization_jwt) {
                this._request.setHeader('Authorization', this._ua._configuration.authorization_jwt);
              }

              this.clientTransaction.send();
            }
            /**
            * Called from client transaction when receiving a correct response to the request.
            * Authenticate request if needed or pass the response back to the applicant.
            */

          }, {
            key: "_receiveResponse",
            value: function _receiveResponse(response) {
              var challenge;
              var authorization_header_name;
              var status_code = response.status_code;
              /*
              * Authentication
              * Authenticate once. _challenged_ flag used to avoid infinite authentications.
              */

              if ((status_code === 401 || status_code === 407) && (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null)) {
                // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
                if (response.status_code === 401) {
                  challenge = response.parseHeader('www-authenticate');
                  authorization_header_name = 'authorization';
                } else {
                  challenge = response.parseHeader('proxy-authenticate');
                  authorization_header_name = 'proxy-authorization';
                } // Verify it seems a valid challenge.


                if (!challenge) {
                  logger.debug("".concat(response.status_code, " with wrong or missing challenge, cannot authenticate"));

                  this._eventHandlers.onReceiveResponse(response);

                  return;
                }

                if (!this._challenged || !this._staled && challenge.stale === true) {
                  if (!this._auth) {
                    this._auth = new DigestAuthentication({
                      username: this._ua.configuration.authorization_user,
                      password: this._ua.configuration.password,
                      realm: this._ua.configuration.realm,
                      ha1: this._ua.configuration.ha1
                    });
                  } // Verify that the challenge is really valid.


                  if (!this._auth.authenticate(this._request, challenge)) {
                    this._eventHandlers.onReceiveResponse(response);

                    return;
                  }

                  this._challenged = true; // Update ha1 and realm in the UA.

                  this._ua.set('realm', this._auth.get('realm'));

                  this._ua.set('ha1', this._auth.get('ha1'));

                  if (challenge.stale) {
                    this._staled = true;
                  }

                  this._request = this._request.clone();
                  this._request.cseq += 1;

                  this._request.setHeader('cseq', "".concat(this._request.cseq, " ").concat(this._method));

                  this._request.setHeader(authorization_header_name, this._auth.toString());

                  this._eventHandlers.onAuthenticated(this._request);

                  this.send();
                } else {
                  this._eventHandlers.onReceiveResponse(response);
                }
              } else {
                this._eventHandlers.onReceiveResponse(response);
              }
            }
          }]);

          return RequestSender;
        }();

        /***/
      }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var Utils = __webpack_require__(8);

        var logger = new Logger('DigestAuthentication');

        module.exports = /*#__PURE__*/function () {
          function DigestAuthentication(credentials) {
            _classCallCheck(this, DigestAuthentication);

            this._credentials = credentials;
            this._cnonce = null;
            this._nc = 0;
            this._ncHex = '00000000';
            this._algorithm = null;
            this._realm = null;
            this._nonce = null;
            this._opaque = null;
            this._stale = null;
            this._qop = null;
            this._method = null;
            this._uri = null;
            this._ha1 = null;
            this._response = null;
          }

          _createClass(DigestAuthentication, [{
            key: "get",
            value: function get(parameter) {
              switch (parameter) {
                case 'realm':
                  return this._realm;

                case 'ha1':
                  return this._ha1;

                default:
                  logger.warn('get() | cannot get "%s" parameter', parameter);
                  return undefined;
              }
            }
            /**
            * Performs Digest authentication given a SIP request and the challenge
            * received in a response to that request.
            * Returns true if auth was successfully generated, false otherwise.
            */

          }, {
            key: "authenticate",
            value: function authenticate(_ref, challenge)
    /* test interface */ {
              var method = _ref.method,
                ruri = _ref.ruri,
                body = _ref.body;
              var cnonce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              this._algorithm = challenge.algorithm;
              this._realm = challenge.realm;
              this._nonce = challenge.nonce;
              this._opaque = challenge.opaque;
              this._stale = challenge.stale;

              if (this._algorithm) {
                if (this._algorithm !== 'MD5') {
                  logger.warn('authenticate() | challenge with Digest algorithm different than "MD5", authentication aborted');
                  return false;
                }
              } else {
                this._algorithm = 'MD5';
              }

              if (!this._nonce) {
                logger.warn('authenticate() | challenge without Digest nonce, authentication aborted');
                return false;
              }

              if (!this._realm) {
                logger.warn('authenticate() | challenge without Digest realm, authentication aborted');
                return false;
              } // If no plain SIP password is provided.


              if (!this._credentials.password) {
                // If ha1 is not provided we cannot authenticate.
                if (!this._credentials.ha1) {
                  logger.warn('authenticate() | no plain SIP password nor ha1 provided, authentication aborted');
                  return false;
                } // If the realm does not match the stored realm we cannot authenticate.


                if (this._credentials.realm !== this._realm) {
                  logger.warn('authenticate() | no plain SIP password, and stored `realm` does not match the given `realm`, cannot authenticate [stored:"%s", given:"%s"]', this._credentials.realm, this._realm);
                  return false;
                }
              } // 'qop' can contain a list of values (Array). Let's choose just one.


              if (challenge.qop) {
                if (challenge.qop.indexOf('auth-int') > -1) {
                  this._qop = 'auth-int';
                } else if (challenge.qop.indexOf('auth') > -1) {
                  this._qop = 'auth';
                } else {
                  // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
                  logger.warn('authenticate() | challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
                  return false;
                }
              } else {
                this._qop = null;
              } // Fill other attributes.


              this._method = method;
              this._uri = ruri;
              this._cnonce = cnonce || Utils.createRandomToken(12);
              this._nc += 1;
              var hex = Number(this._nc).toString(16);
              this._ncHex = '00000000'.substr(0, 8 - hex.length) + hex; // Nc-value = 8LHEX. Max value = 'FFFFFFFF'.

              if (this._nc === 4294967296) {
                this._nc = 1;
                this._ncHex = '00000001';
              } // Calculate the Digest "response" value.
              // If we have plain SIP password then regenerate ha1.


              if (this._credentials.password) {
                // HA1 = MD5(A1) = MD5(username:realm:password).
                this._ha1 = Utils.calculateMD5("".concat(this._credentials.username, ":").concat(this._realm, ":").concat(this._credentials.password));
              } // Otherwise reuse the stored ha1.
              else {
                this._ha1 = this._credentials.ha1;
              }

              var a2;
              var ha2;

              if (this._qop === 'auth') {
                // HA2 = MD5(A2) = MD5(method:digestURI).
                a2 = "".concat(this._method, ":").concat(this._uri);
                ha2 = Utils.calculateMD5(a2);
                logger.debug('authenticate() | using qop=auth [a2:"%s"]', a2); // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).

                this._response = Utils.calculateMD5("".concat(this._ha1, ":").concat(this._nonce, ":").concat(this._ncHex, ":").concat(this._cnonce, ":auth:").concat(ha2));
              } else if (this._qop === 'auth-int') {
                // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody)).
                a2 = "".concat(this._method, ":").concat(this._uri, ":").concat(Utils.calculateMD5(body ? body : ''));
                ha2 = Utils.calculateMD5(a2);
                logger.debug('authenticate() | using qop=auth-int [a2:"%s"]', a2); // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).

                this._response = Utils.calculateMD5("".concat(this._ha1, ":").concat(this._nonce, ":").concat(this._ncHex, ":").concat(this._cnonce, ":auth-int:").concat(ha2));
              } else if (this._qop === null) {
                // HA2 = MD5(A2) = MD5(method:digestURI).
                a2 = "".concat(this._method, ":").concat(this._uri);
                ha2 = Utils.calculateMD5(a2);
                logger.debug('authenticate() | using qop=null [a2:"%s"]', a2); // Response = MD5(HA1:nonce:HA2).

                this._response = Utils.calculateMD5("".concat(this._ha1, ":").concat(this._nonce, ":").concat(ha2));
              }

              logger.debug('authenticate() | response generated');
              return true;
            }
            /**
            * Return the Proxy-Authorization or WWW-Authorization header value.
            */

          }, {
            key: "toString",
            value: function toString() {
              var auth_params = [];

              if (!this._response) {
                throw new Error('response field does not exist, cannot generate Authorization header');
              }

              auth_params.push("algorithm=".concat(this._algorithm));
              auth_params.push("username=\"".concat(this._credentials.username, "\""));
              auth_params.push("realm=\"".concat(this._realm, "\""));
              auth_params.push("nonce=\"".concat(this._nonce, "\""));
              auth_params.push("uri=\"".concat(this._uri, "\""));
              auth_params.push("response=\"".concat(this._response, "\""));

              if (this._opaque) {
                auth_params.push("opaque=\"".concat(this._opaque, "\""));
              }

              if (this._qop) {
                auth_params.push("qop=".concat(this._qop));
                auth_params.push("cnonce=\"".concat(this._cnonce, "\""));
                auth_params.push("nc=".concat(this._ncHex));
              }

              return "Digest ".concat(auth_params.join(', '));
            }
          }]);

          return DigestAuthentication;
        }();

        /***/
      }),
/* 26 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var SIPMessage = __webpack_require__(19);

        var Timers = __webpack_require__(27);

        var loggernict = new Logger('NonInviteClientTransaction');
        var loggerict = new Logger('InviteClientTransaction');
        var loggeract = new Logger('AckClientTransaction');
        var loggernist = new Logger('NonInviteServerTransaction');
        var loggerist = new Logger('InviteServerTransaction');
        var C = {
          // Transaction states.
          STATUS_TRYING: 1,
          STATUS_PROCEEDING: 2,
          STATUS_CALLING: 3,
          STATUS_ACCEPTED: 4,
          STATUS_COMPLETED: 5,
          STATUS_TERMINATED: 6,
          STATUS_CONFIRMED: 7,
          // Transaction types.
          NON_INVITE_CLIENT: 'nict',
          NON_INVITE_SERVER: 'nist',
          INVITE_CLIENT: 'ict',
          INVITE_SERVER: 'ist'
        };

        var NonInviteClientTransaction = /*#__PURE__*/function (_EventEmitter) {
          _inherits(NonInviteClientTransaction, _EventEmitter);

          var _super = _createSuper(NonInviteClientTransaction);

          function NonInviteClientTransaction(ua, transport, request, eventHandlers) {
            var _this;

            _classCallCheck(this, NonInviteClientTransaction);

            _this = _super.call(this);
            _this.type = C.NON_INVITE_CLIENT;
            _this.id = "z9hG4bK".concat(Math.floor(Math.random() * 10000000));
            _this.ua = ua;
            _this.transport = transport;
            _this.request = request;
            _this.eventHandlers = eventHandlers;
            var via = "SIP/2.0/".concat(transport.via_transport);
            via += " ".concat(ua.configuration.via_host, ";branch=").concat(_this.id);

            _this.request.setHeader('via', via);

            _this.ua.newTransaction(_assertThisInitialized(_this));

            return _this;
          }

          _createClass(NonInviteClientTransaction, [{
            key: "stateChanged",
            value: function stateChanged(state) {
              this.state = state;
              this.emit('stateChanged');
            }
          }, {
            key: "send",
            value: function send() {
              var _this2 = this;

              this.stateChanged(C.STATUS_TRYING);
              this.F = setTimeout(function () {
                _this2.timer_F();
              }, Timers.TIMER_F);

              if (!this.transport.send(this.request)) {
                this.onTransportError();
              }
            }
          }, {
            key: "onTransportError",
            value: function onTransportError() {
              loggernict.debug("transport error occurred, deleting transaction ".concat(this.id));
              clearTimeout(this.F);
              clearTimeout(this.K);
              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
              this.eventHandlers.onTransportError();
            }
          }, {
            key: "timer_F",
            value: function timer_F() {
              loggernict.debug("Timer F expired for transaction ".concat(this.id));
              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
              this.eventHandlers.onRequestTimeout();
            }
          }, {
            key: "timer_K",
            value: function timer_K() {
              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
            }
          }, {
            key: "receiveResponse",
            value: function receiveResponse(response) {
              var _this3 = this;

              var status_code = response.status_code;

              if (status_code < 200) {
                switch (this.state) {
                  case C.STATUS_TRYING:
                  case C.STATUS_PROCEEDING:
                    this.stateChanged(C.STATUS_PROCEEDING);
                    this.eventHandlers.onReceiveResponse(response);
                    break;
                }
              } else {
                switch (this.state) {
                  case C.STATUS_TRYING:
                  case C.STATUS_PROCEEDING:
                    this.stateChanged(C.STATUS_COMPLETED);
                    clearTimeout(this.F);

                    if (status_code === 408) {
                      this.eventHandlers.onRequestTimeout();
                    } else {
                      this.eventHandlers.onReceiveResponse(response);
                    }

                    this.K = setTimeout(function () {
                      _this3.timer_K();
                    }, Timers.TIMER_K);
                    break;

                  case C.STATUS_COMPLETED:
                    break;
                }
              }
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            }
          }]);

          return NonInviteClientTransaction;
        }(EventEmitter);

        var InviteClientTransaction = /*#__PURE__*/function (_EventEmitter2) {
          _inherits(InviteClientTransaction, _EventEmitter2);

          var _super2 = _createSuper(InviteClientTransaction);

          function InviteClientTransaction(ua, transport, request, eventHandlers) {
            var _this4;

            _classCallCheck(this, InviteClientTransaction);

            _this4 = _super2.call(this);
            _this4.type = C.INVITE_CLIENT;
            _this4.id = "z9hG4bK".concat(Math.floor(Math.random() * 10000000));
            _this4.ua = ua;
            _this4.transport = transport;
            _this4.request = request;
            _this4.eventHandlers = eventHandlers;
            request.transaction = _assertThisInitialized(_this4);
            var via = "SIP/2.0/".concat(transport.via_transport);
            via += " ".concat(ua.configuration.via_host, ";branch=").concat(_this4.id);

            _this4.request.setHeader('via', via);

            _this4.ua.newTransaction(_assertThisInitialized(_this4));

            return _this4;
          }

          _createClass(InviteClientTransaction, [{
            key: "stateChanged",
            value: function stateChanged(state) {
              this.state = state;
              this.emit('stateChanged');
            }
          }, {
            key: "send",
            value: function send() {
              var _this5 = this;

              this.stateChanged(C.STATUS_CALLING);
              this.B = setTimeout(function () {
                _this5.timer_B();
              }, Timers.TIMER_B);

              if (!this.transport.send(this.request)) {
                this.onTransportError();
              }
            }
          }, {
            key: "onTransportError",
            value: function onTransportError() {
              clearTimeout(this.B);
              clearTimeout(this.D);
              clearTimeout(this.M);

              if (this.state !== C.STATUS_ACCEPTED) {
                loggerict.debug("transport error occurred, deleting transaction ".concat(this.id));
                this.eventHandlers.onTransportError();
              }

              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
            } // RFC 6026 7.2.

          }, {
            key: "timer_M",
            value: function timer_M() {
              loggerict.debug("Timer M expired for transaction ".concat(this.id));

              if (this.state === C.STATUS_ACCEPTED) {
                clearTimeout(this.B);
                this.stateChanged(C.STATUS_TERMINATED);
                this.ua.destroyTransaction(this);
              }
            } // RFC 3261 17.1.1.

          }, {
            key: "timer_B",
            value: function timer_B() {
              loggerict.debug("Timer B expired for transaction ".concat(this.id));

              if (this.state === C.STATUS_CALLING) {
                this.stateChanged(C.STATUS_TERMINATED);
                this.ua.destroyTransaction(this);
                this.eventHandlers.onRequestTimeout();
              }
            }
          }, {
            key: "timer_D",
            value: function timer_D() {
              loggerict.debug("Timer D expired for transaction ".concat(this.id));
              clearTimeout(this.B);
              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
            }
          }, {
            key: "sendACK",
            value: function sendACK(response) {
              var _this6 = this;

              var ack = new SIPMessage.OutgoingRequest(JsSIP_C.ACK, this.request.ruri, this.ua, {
                'route_set': this.request.getHeaders('route'),
                'call_id': this.request.getHeader('call-id'),
                'cseq': this.request.cseq
              });
              ack.setHeader('from', this.request.getHeader('from'));
              ack.setHeader('via', this.request.getHeader('via'));
              ack.setHeader('to', response.getHeader('to'));
              this.D = setTimeout(function () {
                _this6.timer_D();
              }, Timers.TIMER_D);
              this.transport.send(ack);
            }
          }, {
            key: "cancel",
            value: function cancel(reason) {
              // Send only if a provisional response (>100) has been received.
              if (this.state !== C.STATUS_PROCEEDING) {
                return;
              }

              var cancel = new SIPMessage.OutgoingRequest(JsSIP_C.CANCEL, this.request.ruri, this.ua, {
                'route_set': this.request.getHeaders('route'),
                'call_id': this.request.getHeader('call-id'),
                'cseq': this.request.cseq
              });
              cancel.setHeader('from', this.request.getHeader('from'));
              cancel.setHeader('via', this.request.getHeader('via'));
              cancel.setHeader('to', this.request.getHeader('to'));

              if (reason) {
                cancel.setHeader('reason', reason);
              }

              this.transport.send(cancel);
            }
          }, {
            key: "receiveResponse",
            value: function receiveResponse(response) {
              var _this7 = this;

              var status_code = response.status_code;

              if (status_code >= 100 && status_code <= 199) {
                switch (this.state) {
                  case C.STATUS_CALLING:
                    this.stateChanged(C.STATUS_PROCEEDING);
                    this.eventHandlers.onReceiveResponse(response);
                    break;

                  case C.STATUS_PROCEEDING:
                    this.eventHandlers.onReceiveResponse(response);
                    break;
                }
              } else if (status_code >= 200 && status_code <= 299) {
                switch (this.state) {
                  case C.STATUS_CALLING:
                  case C.STATUS_PROCEEDING:
                    this.stateChanged(C.STATUS_ACCEPTED);
                    this.M = setTimeout(function () {
                      _this7.timer_M();
                    }, Timers.TIMER_M);
                    this.eventHandlers.onReceiveResponse(response);
                    break;

                  case C.STATUS_ACCEPTED:
                    this.eventHandlers.onReceiveResponse(response);
                    break;
                }
              } else if (status_code >= 300 && status_code <= 699) {
                switch (this.state) {
                  case C.STATUS_CALLING:
                  case C.STATUS_PROCEEDING:
                    this.stateChanged(C.STATUS_COMPLETED);
                    this.sendACK(response);
                    this.eventHandlers.onReceiveResponse(response);
                    break;

                  case C.STATUS_COMPLETED:
                    this.sendACK(response);
                    break;
                }
              }
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            }
          }]);

          return InviteClientTransaction;
        }(EventEmitter);

        var AckClientTransaction = /*#__PURE__*/function (_EventEmitter3) {
          _inherits(AckClientTransaction, _EventEmitter3);

          var _super3 = _createSuper(AckClientTransaction);

          function AckClientTransaction(ua, transport, request, eventHandlers) {
            var _this8;

            _classCallCheck(this, AckClientTransaction);

            _this8 = _super3.call(this);
            _this8.id = "z9hG4bK".concat(Math.floor(Math.random() * 10000000));
            _this8.transport = transport;
            _this8.request = request;
            _this8.eventHandlers = eventHandlers;
            var via = "SIP/2.0/".concat(transport.via_transport);
            via += " ".concat(ua.configuration.via_host, ";branch=").concat(_this8.id);

            _this8.request.setHeader('via', via);

            return _this8;
          }

          _createClass(AckClientTransaction, [{
            key: "send",
            value: function send() {
              if (!this.transport.send(this.request)) {
                this.onTransportError();
              }
            }
          }, {
            key: "onTransportError",
            value: function onTransportError() {
              loggeract.debug("transport error occurred for transaction ".concat(this.id));
              this.eventHandlers.onTransportError();
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            }
          }]);

          return AckClientTransaction;
        }(EventEmitter);

        var NonInviteServerTransaction = /*#__PURE__*/function (_EventEmitter4) {
          _inherits(NonInviteServerTransaction, _EventEmitter4);

          var _super4 = _createSuper(NonInviteServerTransaction);

          function NonInviteServerTransaction(ua, transport, request) {
            var _this9;

            _classCallCheck(this, NonInviteServerTransaction);

            _this9 = _super4.call(this);
            _this9.type = C.NON_INVITE_SERVER;
            _this9.id = request.via_branch;
            _this9.ua = ua;
            _this9.transport = transport;
            _this9.request = request;
            _this9.last_response = '';
            request.server_transaction = _assertThisInitialized(_this9);
            _this9.state = C.STATUS_TRYING;
            ua.newTransaction(_assertThisInitialized(_this9));
            return _this9;
          }

          _createClass(NonInviteServerTransaction, [{
            key: "stateChanged",
            value: function stateChanged(state) {
              this.state = state;
              this.emit('stateChanged');
            }
          }, {
            key: "timer_J",
            value: function timer_J() {
              loggernist.debug("Timer J expired for transaction ".concat(this.id));
              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
            }
          }, {
            key: "onTransportError",
            value: function onTransportError() {
              if (!this.transportError) {
                this.transportError = true;
                loggernist.debug("transport error occurred, deleting transaction ".concat(this.id));
                clearTimeout(this.J);
                this.stateChanged(C.STATUS_TERMINATED);
                this.ua.destroyTransaction(this);
              }
            }
          }, {
            key: "receiveResponse",
            value: function receiveResponse(status_code, response, onSuccess, onFailure) {
              var _this10 = this;

              if (status_code === 100) {
                /* RFC 4320 4.1
                 * 'A SIP element MUST NOT
                 * send any provisional response with a
                 * Status-Code other than 100 to a non-INVITE request.'
                 */
                switch (this.state) {
                  case C.STATUS_TRYING:
                    this.stateChanged(C.STATUS_PROCEEDING);

                    if (!this.transport.send(response)) {
                      this.onTransportError();
                    }

                    break;

                  case C.STATUS_PROCEEDING:
                    this.last_response = response;

                    if (!this.transport.send(response)) {
                      this.onTransportError();

                      if (onFailure) {
                        onFailure();
                      }
                    } else if (onSuccess) {
                      onSuccess();
                    }

                    break;
                }
              } else if (status_code >= 200 && status_code <= 699) {
                switch (this.state) {
                  case C.STATUS_TRYING:
                  case C.STATUS_PROCEEDING:
                    this.stateChanged(C.STATUS_COMPLETED);
                    this.last_response = response;
                    this.J = setTimeout(function () {
                      _this10.timer_J();
                    }, Timers.TIMER_J);

                    if (!this.transport.send(response)) {
                      this.onTransportError();

                      if (onFailure) {
                        onFailure();
                      }
                    } else if (onSuccess) {
                      onSuccess();
                    }

                    break;

                  case C.STATUS_COMPLETED:
                    break;
                }
              }
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            }
          }]);

          return NonInviteServerTransaction;
        }(EventEmitter);

        var InviteServerTransaction = /*#__PURE__*/function (_EventEmitter5) {
          _inherits(InviteServerTransaction, _EventEmitter5);

          var _super5 = _createSuper(InviteServerTransaction);

          function InviteServerTransaction(ua, transport, request) {
            var _this11;

            _classCallCheck(this, InviteServerTransaction);

            _this11 = _super5.call(this);
            _this11.type = C.INVITE_SERVER;
            _this11.id = request.via_branch;
            _this11.ua = ua;
            _this11.transport = transport;
            _this11.request = request;
            _this11.last_response = '';
            request.server_transaction = _assertThisInitialized(_this11);
            _this11.state = C.STATUS_PROCEEDING;
            ua.newTransaction(_assertThisInitialized(_this11));
            _this11.resendProvisionalTimer = null;
            request.reply(100);
            return _this11;
          }

          _createClass(InviteServerTransaction, [{
            key: "stateChanged",
            value: function stateChanged(state) {
              this.state = state;
              this.emit('stateChanged');
            }
          }, {
            key: "timer_H",
            value: function timer_H() {
              loggerist.debug("Timer H expired for transaction ".concat(this.id));

              if (this.state === C.STATUS_COMPLETED) {
                loggerist.debug('ACK not received, dialog will be terminated');
              }

              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
            }
          }, {
            key: "timer_I",
            value: function timer_I() {
              this.stateChanged(C.STATUS_TERMINATED);
              this.ua.destroyTransaction(this);
            } // RFC 6026 7.1.

          }, {
            key: "timer_L",
            value: function timer_L() {
              loggerist.debug("Timer L expired for transaction ".concat(this.id));

              if (this.state === C.STATUS_ACCEPTED) {
                this.stateChanged(C.STATUS_TERMINATED);
                this.ua.destroyTransaction(this);
              }
            }
          }, {
            key: "onTransportError",
            value: function onTransportError() {
              if (!this.transportError) {
                this.transportError = true;
                loggerist.debug("transport error occurred, deleting transaction ".concat(this.id));

                if (this.resendProvisionalTimer !== null) {
                  clearInterval(this.resendProvisionalTimer);
                  this.resendProvisionalTimer = null;
                }

                clearTimeout(this.L);
                clearTimeout(this.H);
                clearTimeout(this.I);
                this.stateChanged(C.STATUS_TERMINATED);
                this.ua.destroyTransaction(this);
              }
            }
          }, {
            key: "resend_provisional",
            value: function resend_provisional() {
              if (!this.transport.send(this.last_response)) {
                this.onTransportError();
              }
            } // INVITE Server Transaction RFC 3261 17.2.1.

          }, {
            key: "receiveResponse",
            value: function receiveResponse(status_code, response, onSuccess, onFailure) {
              var _this12 = this;

              if (status_code >= 100 && status_code <= 199) {
                switch (this.state) {
                  case C.STATUS_PROCEEDING:
                    if (!this.transport.send(response)) {
                      this.onTransportError();
                    }

                    this.last_response = response;
                    break;
                }
              }

              if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
                // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
                if (this.resendProvisionalTimer === null) {
                  this.resendProvisionalTimer = setInterval(function () {
                    _this12.resend_provisional();
                  }, Timers.PROVISIONAL_RESPONSE_INTERVAL);
                }
              } else if (status_code >= 200 && status_code <= 299) {
                switch (this.state) {
                  case C.STATUS_PROCEEDING:
                    this.stateChanged(C.STATUS_ACCEPTED);
                    this.last_response = response;
                    this.L = setTimeout(function () {
                      _this12.timer_L();
                    }, Timers.TIMER_L);

                    if (this.resendProvisionalTimer !== null) {
                      clearInterval(this.resendProvisionalTimer);
                      this.resendProvisionalTimer = null;
                    }

                  /* falls through */

                  case C.STATUS_ACCEPTED:
                    // Note that this point will be reached for proceeding this.state also.
                    if (!this.transport.send(response)) {
                      this.onTransportError();

                      if (onFailure) {
                        onFailure();
                      }
                    } else if (onSuccess) {
                      onSuccess();
                    }

                    break;
                }
              } else if (status_code >= 300 && status_code <= 699) {
                switch (this.state) {
                  case C.STATUS_PROCEEDING:
                    if (this.resendProvisionalTimer !== null) {
                      clearInterval(this.resendProvisionalTimer);
                      this.resendProvisionalTimer = null;
                    }

                    if (!this.transport.send(response)) {
                      this.onTransportError();

                      if (onFailure) {
                        onFailure();
                      }
                    } else {
                      this.stateChanged(C.STATUS_COMPLETED);
                      this.H = setTimeout(function () {
                        _this12.timer_H();
                      }, Timers.TIMER_H);

                      if (onSuccess) {
                        onSuccess();
                      }
                    }

                    break;
                }
              }
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            }
          }]);

          return InviteServerTransaction;
        }(EventEmitter);
        /**
         * INVITE:
         *  _true_ if retransmission
         *  _false_ new request
         *
         * ACK:
         *  _true_  ACK to non2xx response
         *  _false_ ACK must be passed to TU (accepted state)
         *          ACK to 2xx response
         *
         * CANCEL:
         *  _true_  no matching invite transaction
         *  _false_ matching invite transaction and no final response sent
         *
         * OTHER:
         *  _true_  retransmission
         *  _false_ new request
         */


        function checkTransaction(_ref, request) {
          var _transactions = _ref._transactions;
          var tr;

          switch (request.method) {
            case JsSIP_C.INVITE:
              tr = _transactions.ist[request.via_branch];

              if (tr) {
                switch (tr.state) {
                  case C.STATUS_PROCEEDING:
                    tr.transport.send(tr.last_response);
                    break;
                  // RFC 6026 7.1 Invite retransmission.
                  // Received while in C.STATUS_ACCEPTED state. Absorb it.

                  case C.STATUS_ACCEPTED:
                    break;
                }

                return true;
              }

              break;

            case JsSIP_C.ACK:
              tr = _transactions.ist[request.via_branch]; // RFC 6026 7.1.

              if (tr) {
                if (tr.state === C.STATUS_ACCEPTED) {
                  return false;
                } else if (tr.state === C.STATUS_COMPLETED) {
                  tr.state = C.STATUS_CONFIRMED;
                  tr.I = setTimeout(function () {
                    tr.timer_I();
                  }, Timers.TIMER_I);
                  return true;
                }
              } // ACK to 2XX Response.
              else {
                return false;
              }

              break;

            case JsSIP_C.CANCEL:
              tr = _transactions.ist[request.via_branch];

              if (tr) {
                request.reply_sl(200);

                if (tr.state === C.STATUS_PROCEEDING) {
                  return false;
                } else {
                  return true;
                }
              } else {
                request.reply_sl(481);
                return true;
              }

            default:
              // Non-INVITE Server Transaction RFC 3261 17.2.2.
              tr = _transactions.nist[request.via_branch];

              if (tr) {
                switch (tr.state) {
                  case C.STATUS_TRYING:
                    break;

                  case C.STATUS_PROCEEDING:
                  case C.STATUS_COMPLETED:
                    tr.transport.send(tr.last_response);
                    break;
                }

                return true;
              }

              break;
          }
        }

        module.exports = {
          C: C,
          NonInviteClientTransaction: NonInviteClientTransaction,
          InviteClientTransaction: InviteClientTransaction,
          AckClientTransaction: AckClientTransaction,
          NonInviteServerTransaction: NonInviteServerTransaction,
          InviteServerTransaction: InviteServerTransaction,
          checkTransaction: checkTransaction
        };

        /***/
      }),
/* 27 */
/***/ ((module) => {

        "use strict";


        var T1 = 500,
          T2 = 4000,
          T4 = 5000;
        module.exports = {
          T1: T1,
          T2: T2,
          T4: T4,
          TIMER_B: 64 * T1,
          TIMER_D: 0 * T1,
          TIMER_F: 64 * T1,
          TIMER_H: 64 * T1,
          TIMER_I: 0 * T1,
          TIMER_J: 0 * T1,
          TIMER_K: 0 * T4,
          TIMER_L: 64 * T1,
          TIMER_M: 64 * T1,
          PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1

        };

        /***/
      }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        /* globals RTCPeerConnection: false, RTCSessionDescription: false */
        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var sdp_transform = __webpack_require__(20);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var Exceptions = __webpack_require__(7);

        var Transactions = __webpack_require__(26);

        var Utils = __webpack_require__(8);

        var Timers = __webpack_require__(27);

        var SIPMessage = __webpack_require__(19);

        var Dialog = __webpack_require__(29);

        var RequestSender = __webpack_require__(24);

        var RTCSession_DTMF = __webpack_require__(31);

        var RTCSession_Info = __webpack_require__(32);

        var RTCSession_ReferNotifier = __webpack_require__(33);

        var RTCSession_ReferSubscriber = __webpack_require__(34);

        var URI = __webpack_require__(9);

        var logger = new Logger('RTCSession');
        var C = {
          // RTCSession states.
          STATUS_NULL: 0,
          STATUS_INVITE_SENT: 1,
          STATUS_1XX_RECEIVED: 2,
          STATUS_INVITE_RECEIVED: 3,
          STATUS_WAITING_FOR_ANSWER: 4,
          STATUS_ANSWERED: 5,
          STATUS_WAITING_FOR_ACK: 6,
          STATUS_CANCELED: 7,
          STATUS_TERMINATED: 8,
          STATUS_CONFIRMED: 9
        };
        /**
         * Local variables.
         */

        var holdMediaTypes = ['audio', 'video'];

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(RTCSession, _EventEmitter);

          var _super = _createSuper(RTCSession);

          _createClass(RTCSession, null, [{
            key: "C",

            /**
             * Expose C object.
             */
            get: function get() {
              return C;
            }
          }]);

          function RTCSession(ua) {
            var _this;

            _classCallCheck(this, RTCSession);

            logger.debug('new');
            _this = _super.call(this);
            _this._id = null;
            _this._ua = ua;
            _this._status = C.STATUS_NULL;
            _this._dialog = null;
            _this._earlyDialogs = {};
            _this._contact = null;
            _this._from_tag = null;
            _this._to_tag = null; // The RTCPeerConnection instance (public attribute).

            _this._connection = null; // Prevent races on serial PeerConnction operations.

            _this._connectionPromiseQueue = Promise.resolve(); // Incoming/Outgoing request being currently processed.

            _this._request = null; // Cancel state for initial outgoing request.

            _this._is_canceled = false;
            _this._cancel_reason = ''; // RTCSession confirmation flag.

            _this._is_confirmed = false; // Is late SDP being negotiated.

            _this._late_sdp = false; // Default rtcOfferConstraints and rtcAnswerConstrainsts (passed in connect() or answer()).

            _this._rtcOfferConstraints = null;
            _this._rtcAnswerConstraints = null; // Local MediaStream.

            _this._localMediaStream = null;
            _this._localMediaStreamLocallyGenerated = false; // Flag to indicate PeerConnection ready for new actions.

            _this._rtcReady = true; // Flag to indicate ICE candidate gathering is finished even if iceGatheringState is not yet 'complete'.

            _this._iceReady = false; // SIP Timers.

            _this._timers = {
              ackTimer: null,
              expiresTimer: null,
              invite2xxTimer: null,
              userNoAnswerTimer: null
            }; // Session info.

            _this._direction = null;
            _this._local_identity = null;
            _this._remote_identity = null;
            _this._start_time = null;
            _this._end_time = null;
            _this._tones = null; // Mute/Hold state.

            _this._audioMuted = false;
            _this._videoMuted = false;
            _this._localHold = false;
            _this._remoteHold = false; // Session Timers (RFC 4028).

            _this._sessionTimers = {
              enabled: _this._ua.configuration.session_timers,
              refreshMethod: _this._ua.configuration.session_timers_refresh_method,
              defaultExpires: JsSIP_C.SESSION_EXPIRES,
              currentExpires: null,
              running: false,
              refresher: false,
              timer: null // A setTimeout.

            }; // Map of ReferSubscriber instances indexed by the REFER's CSeq number.

            _this._referSubscribers = {}; // Custom session empty object for high level use.

            _this._data = {};
            return _this;
          }
          /**
           * User API
           */
          // Expose RTCSession constants as a property of the RTCSession instance.


          _createClass(RTCSession, [{
            key: "isInProgress",
            value: function isInProgress() {
              switch (this._status) {
                case C.STATUS_NULL:
                case C.STATUS_INVITE_SENT:
                case C.STATUS_1XX_RECEIVED:
                case C.STATUS_INVITE_RECEIVED:
                case C.STATUS_WAITING_FOR_ANSWER:
                  return true;

                default:
                  return false;
              }
            }
          }, {
            key: "isEstablished",
            value: function isEstablished() {
              switch (this._status) {
                case C.STATUS_ANSWERED:
                case C.STATUS_WAITING_FOR_ACK:
                case C.STATUS_CONFIRMED:
                  return true;

                default:
                  return false;
              }
            }
          }, {
            key: "isEnded",
            value: function isEnded() {
              switch (this._status) {
                case C.STATUS_CANCELED:
                case C.STATUS_TERMINATED:
                  return true;

                default:
                  return false;
              }
            }
          }, {
            key: "isMuted",
            value: function isMuted() {
              return {
                audio: this._audioMuted,
                video: this._videoMuted
              };
            }
          }, {
            key: "isOnHold",
            value: function isOnHold() {
              return {
                local: this._localHold,
                remote: this._remoteHold
              };
            }
          }, {
            key: "connect",
            value: function connect(target) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var initCallback = arguments.length > 2 ? arguments[2] : undefined;
              logger.debug('connect()');
              var originalTarget = target;
              var eventHandlers = Utils.cloneObject(options.eventHandlers);
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var mediaConstraints = Utils.cloneObject(options.mediaConstraints, {
                audio: true,
                video: true
              });
              var mediaStream = options.mediaStream || null;
              var pcConfig = Utils.cloneObject(options.pcConfig, {
                iceServers: []
              });
              var rtcConstraints = options.rtcConstraints || null;
              var rtcOfferConstraints = options.rtcOfferConstraints || null;
              this._rtcOfferConstraints = rtcOfferConstraints;
              this._rtcAnswerConstraints = options.rtcAnswerConstraints || null;
              this._data = options.data || this._data; // Check target.

              if (target === undefined) {
                throw new TypeError('Not enough arguments');
              } // Check Session Status.


              if (this._status !== C.STATUS_NULL) {
                throw new Exceptions.InvalidStateError(this._status);
              } // Check WebRTC support.


              if (!window.RTCPeerConnection) {
                throw new Exceptions.NotSupportedError('WebRTC not supported');
              } // Check target validity.


              target = this._ua.normalizeTarget(target);

              if (!target) {
                throw new TypeError("Invalid target: ".concat(originalTarget));
              } // Session Timers.


              if (this._sessionTimers.enabled) {
                if (Utils.isDecimal(options.sessionTimersExpires)) {
                  if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES) {
                    this._sessionTimers.defaultExpires = options.sessionTimersExpires;
                  } else {
                    this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;
                  }
                }
              } // Set event handlers.


              for (var event in eventHandlers) {
                if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {
                  this.on(event, eventHandlers[event]);
                }
              } // Session parameter initialization.


              this._from_tag = Utils.newTag(); // Set anonymous property.

              var anonymous = options.anonymous || false;
              var requestParams = {
                from_tag: this._from_tag
              };
              this._contact = this._ua.contact.toString({
                anonymous: anonymous,
                outbound: true
              });

              if (anonymous) {
                requestParams.from_display_name = 'Anonymous';
                requestParams.from_uri = new URI('sip', 'anonymous', 'anonymous.invalid');
                extraHeaders.push("P-Preferred-Identity: ".concat(this._ua.configuration.uri.toString()));
                extraHeaders.push('Privacy: id');
              } else if (options.fromUserName) {
                requestParams.from_uri = new URI('sip', options.fromUserName, this._ua.configuration.uri.host);
                extraHeaders.push("P-Preferred-Identity: ".concat(this._ua.configuration.uri.toString()));
              }

              if (options.fromDisplayName) {
                requestParams.from_display_name = options.fromDisplayName;
              }

              extraHeaders.push("Contact: ".concat(this._contact));
              extraHeaders.push('Content-Type: application/sdp');

              if (this._sessionTimers.enabled) {
                extraHeaders.push("Session-Expires: ".concat(this._sessionTimers.defaultExpires).concat(this._ua.configuration.session_timers_force_refresher ? ';refresher=uac' : ''));
              }

              this._request = new SIPMessage.InitialOutgoingInviteRequest(target, this._ua, requestParams, extraHeaders);
              this._id = this._request.call_id + this._from_tag; // Create a new RTCPeerConnection instance.

              this._createRTCConnection(pcConfig, rtcConstraints); // Set internal properties.


              this._direction = 'outgoing';
              this._local_identity = this._request.from;
              this._remote_identity = this._request.to; // User explicitly provided a newRTCSession callback for this session.

              if (initCallback) {
                initCallback(this);
              }

              this._newRTCSession('local', this._request);

              this._sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream);
            }
          }, {
            key: "init_incoming",
            value: function init_incoming(request, initCallback) {
              var _this2 = this;

              logger.debug('init_incoming()');
              var expires;
              var contentType = request.hasHeader('Content-Type') ? request.getHeader('Content-Type').toLowerCase() : undefined; // Check body and content type.

              if (request.body && contentType !== 'application/sdp') {
                request.reply(415);
                return;
              } // Session parameter initialization.


              this._status = C.STATUS_INVITE_RECEIVED;
              this._from_tag = request.from_tag;
              this._id = request.call_id + this._from_tag;
              this._request = request;
              this._contact = this._ua.contact.toString(); // Get the Expires header value if exists.

              if (request.hasHeader('expires')) {
                expires = request.getHeader('expires') * 1000;
              }
              /* Set the to_tag before
               * replying a response code that will create a dialog.
               */


              request.to_tag = Utils.newTag(); // An error on dialog creation will fire 'failed' event.

              if (!this._createDialog(request, 'UAS', true)) {
                request.reply(500, 'Missing Contact header field');
                return;
              }

              if (request.body) {
                this._late_sdp = false;
              } else {
                this._late_sdp = true;
              }

              this._status = C.STATUS_WAITING_FOR_ANSWER; // Set userNoAnswerTimer.

              this._timers.userNoAnswerTimer = setTimeout(function () {
                request.reply(408);

                _this2._failed('local', null, JsSIP_C.causes.NO_ANSWER);
              }, this._ua.configuration.no_answer_timeout);
              /* Set expiresTimer
               * RFC3261 13.3.1
               */

              if (expires) {
                this._timers.expiresTimer = setTimeout(function () {
                  if (_this2._status === C.STATUS_WAITING_FOR_ANSWER) {
                    request.reply(487);

                    _this2._failed('system', null, JsSIP_C.causes.EXPIRES);
                  }
                }, expires);
              } // Set internal properties.


              this._direction = 'incoming';
              this._local_identity = request.to;
              this._remote_identity = request.from; // A init callback was specifically defined.

              if (initCallback) {
                initCallback(this);
              } // Fire 'newRTCSession' event.


              this._newRTCSession('remote', request); // The user may have rejected the call in the 'newRTCSession' event.


              if (this._status === C.STATUS_TERMINATED) {
                return;
              } // Reply 180.


              request.reply(180, null, ["Contact: ".concat(this._contact)]); // Fire 'progress' event.
              // TODO: Document that 'response' field in 'progress' event is null for incoming calls.

              this._progress('local', null);
            }
            /**
             * Answer the call.
             */

          }, {
            key: "answer",
            value: function answer() {
              var _this3 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              logger.debug('answer()');
              var request = this._request;
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var mediaConstraints = Utils.cloneObject(options.mediaConstraints);
              var mediaStream = options.mediaStream || null;
              var pcConfig = Utils.cloneObject(options.pcConfig, {
                iceServers: []
              });
              var rtcConstraints = options.rtcConstraints || null;
              var rtcAnswerConstraints = options.rtcAnswerConstraints || null;
              var rtcOfferConstraints = Utils.cloneObject(options.rtcOfferConstraints);
              var tracks;
              var peerHasAudioLine = false;
              var peerHasVideoLine = false;
              var peerOffersFullAudio = false;
              var peerOffersFullVideo = false;
              this._rtcAnswerConstraints = rtcAnswerConstraints;
              this._rtcOfferConstraints = options.rtcOfferConstraints || null;
              this._data = options.data || this._data; // Check Session Direction and Status.

              if (this._direction !== 'incoming') {
                throw new Exceptions.NotSupportedError('"answer" not supported for outgoing RTCSession');
              } // Check Session status.


              if (this._status !== C.STATUS_WAITING_FOR_ANSWER) {
                throw new Exceptions.InvalidStateError(this._status);
              } // Session Timers.


              if (this._sessionTimers.enabled) {
                if (Utils.isDecimal(options.sessionTimersExpires)) {
                  if (options.sessionTimersExpires >= JsSIP_C.MIN_SESSION_EXPIRES) {
                    this._sessionTimers.defaultExpires = options.sessionTimersExpires;
                  } else {
                    this._sessionTimers.defaultExpires = JsSIP_C.SESSION_EXPIRES;
                  }
                }
              }

              this._status = C.STATUS_ANSWERED; // An error on dialog creation will fire 'failed' event.

              if (!this._createDialog(request, 'UAS')) {
                request.reply(500, 'Error creating dialog');
                return;
              }

              clearTimeout(this._timers.userNoAnswerTimer);
              extraHeaders.unshift("Contact: ".concat(this._contact)); // Determine incoming media from incoming SDP offer (if any).

              var sdp = request.parseSDP(); // Make sure sdp.media is an array, not the case if there is only one media.

              if (!Array.isArray(sdp.media)) {
                sdp.media = [sdp.media];
              } // Go through all medias in SDP to find offered capabilities to answer with.


              var _iterator = _createForOfIteratorHelper(sdp.media),
                _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var m = _step.value;

                  if (m.type === 'audio') {
                    peerHasAudioLine = true;

                    if (!m.direction || m.direction === 'sendrecv') {
                      peerOffersFullAudio = true;
                    }
                  }

                  if (m.type === 'video') {
                    peerHasVideoLine = true;

                    if (!m.direction || m.direction === 'sendrecv') {
                      peerOffersFullVideo = true;
                    }
                  }
                } // Remove audio from mediaStream if suggested by mediaConstraints.

              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

              if (mediaStream && mediaConstraints.audio === false) {
                tracks = mediaStream.getAudioTracks();

                var _iterator2 = _createForOfIteratorHelper(tracks),
                  _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var track = _step2.value;
                    mediaStream.removeTrack(track);
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
              } // Remove video from mediaStream if suggested by mediaConstraints.


              if (mediaStream && mediaConstraints.video === false) {
                tracks = mediaStream.getVideoTracks();

                var _iterator3 = _createForOfIteratorHelper(tracks),
                  _step3;

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var _track = _step3.value;
                    mediaStream.removeTrack(_track);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              } // Set audio constraints based on incoming stream if not supplied.


              if (!mediaStream && mediaConstraints.audio === undefined) {
                mediaConstraints.audio = peerOffersFullAudio;
              } // Set video constraints based on incoming stream if not supplied.


              if (!mediaStream && mediaConstraints.video === undefined) {
                mediaConstraints.video = peerOffersFullVideo;
              } // Don't ask for audio if the incoming offer has no audio section.


              if (!mediaStream && !peerHasAudioLine && !rtcOfferConstraints.offerToReceiveAudio) {
                mediaConstraints.audio = false;
              } // Don't ask for video if the incoming offer has no video section.


              if (!mediaStream && !peerHasVideoLine && !rtcOfferConstraints.offerToReceiveVideo) {
                mediaConstraints.video = false;
              } // Create a new RTCPeerConnection instance.
              // TODO: This may throw an error, should react.


              this._createRTCConnection(pcConfig, rtcConstraints);

              Promise.resolve() // Handle local MediaStream.
                .then(function () {
                  // A local MediaStream is given, use it.
                  if (mediaStream) {
                    return mediaStream;
                  } // Audio and/or video requested, prompt getUserMedia.
                  else if (mediaConstraints.audio || mediaConstraints.video) {
                    _this3._localMediaStreamLocallyGenerated = true;
                    return navigator.mediaDevices.getUserMedia(mediaConstraints)["catch"](function (error) {
                      if (_this3._status === C.STATUS_TERMINATED) {
                        throw new Error('terminated');
                      }

                      request.reply(480);

                      _this3._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);

                      logger.warn('emit "getusermediafailed" [error:%o]', error);

                      _this3.emit('getusermediafailed', error);

                      throw new Error('getUserMedia() failed');
                    });
                  }
                }) // Attach MediaStream to RTCPeerconnection.
                .then(function (stream) {
                  if (_this3._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  _this3._localMediaStream = stream;

                  if (stream) {
                    stream.getTracks().forEach(function (track) {
                      _this3._connection.addTrack(track, stream);
                    });
                  }
                }) // Set remote description.
                .then(function () {
                  if (_this3._late_sdp) {
                    return;
                  }

                  var e = {
                    originator: 'remote',
                    type: 'offer',
                    sdp: request.body
                  };
                  logger.debug('emit "sdp"');

                  _this3.emit('sdp', e);

                  var offer = new RTCSessionDescription({
                    type: 'offer',
                    sdp: e.sdp
                  });
                  _this3._connectionPromiseQueue = _this3._connectionPromiseQueue.then(function () {
                    return _this3._connection.setRemoteDescription(offer);
                  })["catch"](function (error) {
                    request.reply(488);

                    _this3._failed('system', null, JsSIP_C.causes.WEBRTC_ERROR);

                    logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                    _this3.emit('peerconnection:setremotedescriptionfailed', error);

                    throw new Error('peerconnection.setRemoteDescription() failed');
                  });
                  return _this3._connectionPromiseQueue;
                }) // Create local description.
                .then(function () {
                  if (_this3._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  } // TODO: Is this event already useful?


                  _this3._connecting(request);

                  if (!_this3._late_sdp) {
                    return _this3._createLocalDescription('answer', rtcAnswerConstraints)["catch"](function () {
                      request.reply(500);
                      throw new Error('_createLocalDescription() failed');
                    });
                  } else {
                    return _this3._createLocalDescription('offer', _this3._rtcOfferConstraints)["catch"](function () {
                      request.reply(500);
                      throw new Error('_createLocalDescription() failed');
                    });
                  }
                }) // Send reply.
                .then(function (desc) {
                  if (_this3._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  _this3._handleSessionTimersInIncomingRequest(request, extraHeaders);

                  request.reply(200, null, extraHeaders, desc, function () {
                    _this3._status = C.STATUS_WAITING_FOR_ACK;

                    _this3._setInvite2xxTimer(request, desc);

                    _this3._setACKTimer();

                    _this3._accepted('local');
                  }, function () {
                    _this3._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);
                  });
                })["catch"](function (error) {
                  if (_this3._status === C.STATUS_TERMINATED) {
                    return;
                  }

                  logger.warn(error);
                });
            }
            /**
             * Terminate the call.
             */

          }, {
            key: "terminate",
            value: function terminate() {
              var _this4 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              logger.debug('terminate()');
              var cause = options.cause || JsSIP_C.causes.BYE;
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var body = options.body;
              var cancel_reason;
              var status_code = options.status_code;
              var reason_phrase = options.reason_phrase; // Check Session Status.

              if (this._status === C.STATUS_TERMINATED) {
                throw new Exceptions.InvalidStateError(this._status);
              }

              switch (this._status) {
                // - UAC -
                case C.STATUS_NULL:
                case C.STATUS_INVITE_SENT:
                case C.STATUS_1XX_RECEIVED:
                  logger.debug('canceling session');

                  if (status_code && (status_code < 200 || status_code >= 700)) {
                    throw new TypeError("Invalid status_code: ".concat(status_code));
                  } else if (status_code) {
                    reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';
                    cancel_reason = "SIP ;cause=".concat(status_code, " ;text=\"").concat(reason_phrase, "\"");
                  } // Check Session Status.


                  if (this._status === C.STATUS_NULL || this._status === C.STATUS_INVITE_SENT) {
                    this._is_canceled = true;
                    this._cancel_reason = cancel_reason;
                  } else if (this._status === C.STATUS_1XX_RECEIVED) {
                    this._request.cancel(cancel_reason);
                  }

                  this._status = C.STATUS_CANCELED;

                  this._failed('local', null, JsSIP_C.causes.CANCELED);

                  break;
                // - UAS -

                case C.STATUS_WAITING_FOR_ANSWER:
                case C.STATUS_ANSWERED:
                  logger.debug('rejecting session');
                  status_code = status_code || 480;

                  if (status_code < 300 || status_code >= 700) {
                    throw new TypeError("Invalid status_code: ".concat(status_code));
                  }

                  this._request.reply(status_code, reason_phrase, extraHeaders, body);

                  this._failed('local', null, JsSIP_C.causes.REJECTED);

                  break;

                case C.STATUS_WAITING_FOR_ACK:
                case C.STATUS_CONFIRMED:
                  logger.debug('terminating session');
                  reason_phrase = options.reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';

                  if (status_code && (status_code < 200 || status_code >= 700)) {
                    throw new TypeError("Invalid status_code: ".concat(status_code));
                  } else if (status_code) {
                    extraHeaders.push("Reason: SIP ;cause=".concat(status_code, "; text=\"").concat(reason_phrase, "\""));
                  }
                  /* RFC 3261 section 15 (Terminating a session):
                    *
                    * "...the callee's UA MUST NOT send a BYE on a confirmed dialog
                    * until it has received an ACK for its 2xx response or until the server
                    * transaction times out."
                    */


                  if (this._status === C.STATUS_WAITING_FOR_ACK && this._direction === 'incoming' && this._request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {
                    // Save the dialog for later restoration.
                    var dialog = this._dialog; // Send the BYE as soon as the ACK is received...

                    this.receiveRequest = function (_ref) {
                      var method = _ref.method;

                      if (method === JsSIP_C.ACK) {
                        _this4.sendRequest(JsSIP_C.BYE, {
                          extraHeaders: extraHeaders,
                          body: body
                        });

                        dialog.terminate();
                      }
                    }; // .., or when the INVITE transaction times out


                    this._request.server_transaction.on('stateChanged', function () {
                      if (_this4._request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {
                        _this4.sendRequest(JsSIP_C.BYE, {
                          extraHeaders: extraHeaders,
                          body: body
                        });

                        dialog.terminate();
                      }
                    });

                    this._ended('local', null, cause); // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-).


                    this._dialog = dialog; // Restore the dialog into 'ua' so the ACK can reach 'this' session.

                    this._ua.newDialog(dialog);
                  } else {
                    this.sendRequest(JsSIP_C.BYE, {
                      extraHeaders: extraHeaders,
                      body: body
                    });

                    this._ended('local', null, cause);
                  }

              }
            }
          }, {
            key: "sendDTMF",
            value: function sendDTMF(tones) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              logger.debug('sendDTMF() | tones: %s', tones);
              var position = 0;
              var duration = options.duration || null;
              var interToneGap = options.interToneGap || null;
              var transportType = options.transportType || JsSIP_C.DTMF_TRANSPORT.INFO;

              if (tones === undefined) {
                throw new TypeError('Not enough arguments');
              } // Check Session Status.


              if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_1XX_RECEIVED) {
                throw new Exceptions.InvalidStateError(this._status);
              } // Check Transport type.


              if (transportType !== JsSIP_C.DTMF_TRANSPORT.INFO && transportType !== JsSIP_C.DTMF_TRANSPORT.RFC2833) {
                throw new TypeError("invalid transportType: ".concat(transportType));
              } // Convert to string.


              if (typeof tones === 'number') {
                tones = tones.toString();
              } // Check tones.


              if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-DR#*,]+$/i)) {
                throw new TypeError("Invalid tones: ".concat(tones));
              } // Check duration.


              if (duration && !Utils.isDecimal(duration)) {
                throw new TypeError("Invalid tone duration: ".concat(duration));
              } else if (!duration) {
                duration = RTCSession_DTMF.C.DEFAULT_DURATION;
              } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {
                logger.debug("\"duration\" value is lower than the minimum allowed, setting it to ".concat(RTCSession_DTMF.C.MIN_DURATION, " milliseconds"));
                duration = RTCSession_DTMF.C.MIN_DURATION;
              } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {
                logger.debug("\"duration\" value is greater than the maximum allowed, setting it to ".concat(RTCSession_DTMF.C.MAX_DURATION, " milliseconds"));
                duration = RTCSession_DTMF.C.MAX_DURATION;
              } else {
                duration = Math.abs(duration);
              }

              options.duration = duration; // Check interToneGap.

              if (interToneGap && !Utils.isDecimal(interToneGap)) {
                throw new TypeError("Invalid interToneGap: ".concat(interToneGap));
              } else if (!interToneGap) {
                interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;
              } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {
                logger.debug("\"interToneGap\" value is lower than the minimum allowed, setting it to ".concat(RTCSession_DTMF.C.MIN_INTER_TONE_GAP, " milliseconds"));
                interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;
              } else {
                interToneGap = Math.abs(interToneGap);
              } // RFC2833. Let RTCDTMFSender enqueue the DTMFs.


              if (transportType === JsSIP_C.DTMF_TRANSPORT.RFC2833) {
                // Send DTMF in current audio RTP stream.
                var sender = this._getDTMFRTPSender();

                if (sender) {
                  // Add remaining buffered tones.
                  tones = sender.toneBuffer + tones; // Insert tones.

                  sender.insertDTMF(tones, duration, interToneGap);
                }

                return;
              }

              if (this._tones) {
                // Tones are already queued, just add to the queue.
                this._tones += tones;
                return;
              }

              this._tones = tones; // Send the first tone.

              _sendDTMF.call(this);

              function _sendDTMF() {
                var _this5 = this;

                var timeout;

                if (this._status === C.STATUS_TERMINATED || !this._tones || position >= this._tones.length) {
                  // Stop sending DTMF.
                  this._tones = null;
                  return;
                }

                var tone = this._tones[position];
                position += 1;

                if (tone === ',') {
                  timeout = 2000;
                } else {
                  // Send DTMF via SIP INFO messages.
                  var dtmf = new RTCSession_DTMF(this);
                  options.eventHandlers = {
                    onFailed: function onFailed() {
                      _this5._tones = null;
                    }
                  };
                  dtmf.send(tone, options);
                  timeout = duration + interToneGap;
                } // Set timeout for the next tone.


                setTimeout(_sendDTMF.bind(this), timeout);
              }
            }
          }, {
            key: "sendInfo",
            value: function sendInfo(contentType, body) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              logger.debug('sendInfo()'); // Check Session Status.

              if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_1XX_RECEIVED) {
                throw new Exceptions.InvalidStateError(this._status);
              }

              var info = new RTCSession_Info(this);
              info.send(contentType, body, options);
            }
            /**
             * Mute
             */

          }, {
            key: "mute",
            value: function mute() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                audio: true,
                video: false
              };
              logger.debug('mute()');
              var audioMuted = false,
                videoMuted = false;

              if (this._audioMuted === false && options.audio) {
                audioMuted = true;
                this._audioMuted = true;

                this._toggleMuteAudio(true);
              }

              if (this._videoMuted === false && options.video) {
                videoMuted = true;
                this._videoMuted = true;

                this._toggleMuteVideo(true);
              }

              if (audioMuted === true || videoMuted === true) {
                this._onmute({
                  audio: audioMuted,
                  video: videoMuted
                });
              }
            }
            /**
             * Unmute
             */

          }, {
            key: "unmute",
            value: function unmute() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
                audio: true,
                video: true
              };
              logger.debug('unmute()');
              var audioUnMuted = false,
                videoUnMuted = false;

              if (this._audioMuted === true && options.audio) {
                audioUnMuted = true;
                this._audioMuted = false;

                if (this._localHold === false) {
                  this._toggleMuteAudio(false);
                }
              }

              if (this._videoMuted === true && options.video) {
                videoUnMuted = true;
                this._videoMuted = false;

                if (this._localHold === false) {
                  this._toggleMuteVideo(false);
                }
              }

              if (audioUnMuted === true || videoUnMuted === true) {
                this._onunmute({
                  audio: audioUnMuted,
                  video: videoUnMuted
                });
              }
            }
            /**
             * Hold
             */

          }, {
            key: "hold",
            value: function hold() {
              var _this6 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var done = arguments.length > 1 ? arguments[1] : undefined;
              logger.debug('hold()');

              if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {
                return false;
              }

              if (this._localHold === true) {
                return false;
              }

              if (!this._isReadyToReOffer()) {
                return false;
              }

              this._localHold = true;

              this._onhold('local');

              var eventHandlers = {
                succeeded: function succeeded() {
                  if (done) {
                    done();
                  }
                },
                failed: function failed() {
                  _this6.terminate({
                    cause: JsSIP_C.causes.WEBRTC_ERROR,
                    status_code: 500,
                    reason_phrase: 'Hold Failed'
                  });
                }
              };

              if (options.useUpdate) {
                this._sendUpdate({
                  sdpOffer: true,
                  eventHandlers: eventHandlers,
                  extraHeaders: options.extraHeaders
                });
              } else {
                this._sendReinvite({
                  eventHandlers: eventHandlers,
                  extraHeaders: options.extraHeaders
                });
              }

              return true;
            }
          }, {
            key: "unhold",
            value: function unhold() {
              var _this7 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var done = arguments.length > 1 ? arguments[1] : undefined;
              logger.debug('unhold()');

              if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {
                return false;
              }

              if (this._localHold === false) {
                return false;
              }

              if (!this._isReadyToReOffer()) {
                return false;
              }

              this._localHold = false;

              this._onunhold('local');

              var eventHandlers = {
                succeeded: function succeeded() {
                  if (done) {
                    done();
                  }
                },
                failed: function failed() {
                  _this7.terminate({
                    cause: JsSIP_C.causes.WEBRTC_ERROR,
                    status_code: 500,
                    reason_phrase: 'Unhold Failed'
                  });
                }
              };

              if (options.useUpdate) {
                this._sendUpdate({
                  sdpOffer: true,
                  eventHandlers: eventHandlers,
                  extraHeaders: options.extraHeaders
                });
              } else {
                this._sendReinvite({
                  eventHandlers: eventHandlers,
                  extraHeaders: options.extraHeaders
                });
              }

              return true;
            }
          }, {
            key: "renegotiate",
            value: function renegotiate() {
              var _this8 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var done = arguments.length > 1 ? arguments[1] : undefined;
              logger.debug('renegotiate()');
              var rtcOfferConstraints = options.rtcOfferConstraints || null;

              if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {
                return false;
              }

              if (!this._isReadyToReOffer()) {
                return false;
              }

              var eventHandlers = {
                succeeded: function succeeded() {
                  if (done) {
                    done();
                  }
                },
                failed: function failed() {
                  _this8.terminate({
                    cause: JsSIP_C.causes.WEBRTC_ERROR,
                    status_code: 500,
                    reason_phrase: 'Media Renegotiation Failed'
                  });
                }
              };

              this._setLocalMediaStatus();

              if (options.useUpdate) {
                this._sendUpdate({
                  sdpOffer: true,
                  eventHandlers: eventHandlers,
                  rtcOfferConstraints: rtcOfferConstraints,
                  extraHeaders: options.extraHeaders
                });
              } else {
                this._sendReinvite({
                  eventHandlers: eventHandlers,
                  rtcOfferConstraints: rtcOfferConstraints,
                  extraHeaders: options.extraHeaders
                });
              }

              return true;
            }
            /**
             * Refer
             */

          }, {
            key: "refer",
            value: function refer(target, options) {
              var _this9 = this;

              logger.debug('refer()');
              var originalTarget = target;

              if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {
                return false;
              } // Check target validity.


              target = this._ua.normalizeTarget(target);

              if (!target) {
                throw new TypeError("Invalid target: ".concat(originalTarget));
              }

              var referSubscriber = new RTCSession_ReferSubscriber(this);
              referSubscriber.sendRefer(target, options); // Store in the map.

              var id = referSubscriber.id;
              this._referSubscribers[id] = referSubscriber; // Listen for ending events so we can remove it from the map.

              referSubscriber.on('requestFailed', function () {
                delete _this9._referSubscribers[id];
              });
              referSubscriber.on('accepted', function () {
                delete _this9._referSubscribers[id];
              });
              referSubscriber.on('failed', function () {
                delete _this9._referSubscribers[id];
              });
              return referSubscriber;
            }
            /**
             * Send a generic in-dialog Request
             */

          }, {
            key: "sendRequest",
            value: function sendRequest(method, options) {
              logger.debug('sendRequest()');
              return this._dialog.sendRequest(method, options);
            }
            /**
             * In dialog Request Reception
             */

          }, {
            key: "receiveRequest",
            value: function receiveRequest(request) {
              var _this10 = this;

              logger.debug('receiveRequest()');

              if (request.method === JsSIP_C.CANCEL) {
                /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
                * was in progress and that the UAC MAY continue with the session established by
                * any 2xx response, or MAY terminate with BYE. JsSIP does continue with the
                * established session. So the CANCEL is processed only if the session is not yet
                * established.
                */

                /*
                * Terminate the whole session in case the user didn't accept (or yet send the answer)
                * nor reject the request opening the session.
                */
                if (this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED) {
                  this._status = C.STATUS_CANCELED;

                  this._request.reply(487);

                  this._failed('remote', request, JsSIP_C.causes.CANCELED);
                }
              } else {
                // Requests arriving here are in-dialog requests.
                switch (request.method) {
                  case JsSIP_C.ACK:
                    if (this._status !== C.STATUS_WAITING_FOR_ACK) {
                      return;
                    } // Update signaling status.


                    this._status = C.STATUS_CONFIRMED;
                    clearTimeout(this._timers.ackTimer);
                    clearTimeout(this._timers.invite2xxTimer);

                    if (this._late_sdp) {
                      if (!request.body) {
                        this.terminate({
                          cause: JsSIP_C.causes.MISSING_SDP,
                          status_code: 400
                        });
                        break;
                      }

                      var e = {
                        originator: 'remote',
                        type: 'answer',
                        sdp: request.body
                      };
                      logger.debug('emit "sdp"');
                      this.emit('sdp', e);
                      var answer = new RTCSessionDescription({
                        type: 'answer',
                        sdp: e.sdp
                      });
                      this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                        return _this10._connection.setRemoteDescription(answer);
                      }).then(function () {
                        if (!_this10._is_confirmed) {
                          _this10._confirmed('remote', request);
                        }
                      })["catch"](function (error) {
                        _this10.terminate({
                          cause: JsSIP_C.causes.BAD_MEDIA_DESCRIPTION,
                          status_code: 488
                        });

                        logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                        _this10.emit('peerconnection:setremotedescriptionfailed', error);
                      });
                    } else if (!this._is_confirmed) {
                      this._confirmed('remote', request);
                    }

                    break;

                  case JsSIP_C.BYE:
                    if (this._status === C.STATUS_CONFIRMED || this._status === C.STATUS_WAITING_FOR_ACK) {
                      request.reply(200);

                      this._ended('remote', request, JsSIP_C.causes.BYE);
                    } else if (this._status === C.STATUS_INVITE_RECEIVED || this._status === C.STATUS_WAITING_FOR_ANSWER) {
                      request.reply(200);

                      this._request.reply(487, 'BYE Received');

                      this._ended('remote', request, JsSIP_C.causes.BYE);
                    } else {
                      request.reply(403, 'Wrong Status');
                    }

                    break;

                  case JsSIP_C.INVITE:
                    if (this._status === C.STATUS_CONFIRMED) {
                      if (request.hasHeader('replaces')) {
                        this._receiveReplaces(request);
                      } else {
                        this._receiveReinvite(request);
                      }
                    } else {
                      request.reply(403, 'Wrong Status');
                    }

                    break;

                  case JsSIP_C.INFO:
                    if (this._status === C.STATUS_1XX_RECEIVED || this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED || this._status === C.STATUS_WAITING_FOR_ACK || this._status === C.STATUS_CONFIRMED) {
                      var contentType = request.hasHeader('Content-Type') ? request.getHeader('Content-Type').toLowerCase() : undefined;

                      if (contentType && contentType.match(/^application\/dtmf-relay/i)) {
                        new RTCSession_DTMF(this).init_incoming(request);
                      } else if (contentType !== undefined) {
                        new RTCSession_Info(this).init_incoming(request);
                      } else {
                        request.reply(415);
                      }
                    } else {
                      request.reply(403, 'Wrong Status');
                    }

                    break;

                  case JsSIP_C.UPDATE:
                    if (this._status === C.STATUS_CONFIRMED) {
                      this._receiveUpdate(request);
                    } else {
                      request.reply(403, 'Wrong Status');
                    }

                    break;

                  case JsSIP_C.REFER:
                    if (this._status === C.STATUS_CONFIRMED) {
                      this._receiveRefer(request);
                    } else {
                      request.reply(403, 'Wrong Status');
                    }

                    break;

                  case JsSIP_C.NOTIFY:
                    if (this._status === C.STATUS_CONFIRMED) {
                      this._receiveNotify(request);
                    } else {
                      request.reply(403, 'Wrong Status');
                    }

                    break;

                  default:
                    request.reply(501);
                }
              }
            }
            /**
             * Session Callbacks
             */

          }, {
            key: "onTransportError",
            value: function onTransportError() {
              logger.warn('onTransportError()');

              if (this._status !== C.STATUS_TERMINATED) {
                this.terminate({
                  status_code: 500,
                  reason_phrase: JsSIP_C.causes.CONNECTION_ERROR,
                  cause: JsSIP_C.causes.CONNECTION_ERROR
                });
              }
            }
          }, {
            key: "onRequestTimeout",
            value: function onRequestTimeout() {
              logger.warn('onRequestTimeout()');

              if (this._status !== C.STATUS_TERMINATED) {
                this.terminate({
                  status_code: 408,
                  reason_phrase: JsSIP_C.causes.REQUEST_TIMEOUT,
                  cause: JsSIP_C.causes.REQUEST_TIMEOUT
                });
              }
            }
          }, {
            key: "onDialogError",
            value: function onDialogError() {
              logger.warn('onDialogError()');

              if (this._status !== C.STATUS_TERMINATED) {
                this.terminate({
                  status_code: 500,
                  reason_phrase: JsSIP_C.causes.DIALOG_ERROR,
                  cause: JsSIP_C.causes.DIALOG_ERROR
                });
              }
            } // Called from DTMF handler.

          }, {
            key: "newDTMF",
            value: function newDTMF(data) {
              logger.debug('newDTMF()');
              this.emit('newDTMF', data);
            } // Called from Info handler.

          }, {
            key: "newInfo",
            value: function newInfo(data) {
              logger.debug('newInfo()');
              this.emit('newInfo', data);
            }
            /**
             * Check if RTCSession is ready for an outgoing re-INVITE or UPDATE with SDP.
             */

          }, {
            key: "_isReadyToReOffer",
            value: function _isReadyToReOffer() {
              if (!this._rtcReady) {
                logger.debug('_isReadyToReOffer() | internal WebRTC status not ready');
                return false;
              } // No established yet.


              if (!this._dialog) {
                logger.debug('_isReadyToReOffer() | session not established yet');
                return false;
              } // Another INVITE transaction is in progress.


              if (this._dialog.uac_pending_reply === true || this._dialog.uas_pending_reply === true) {
                logger.debug('_isReadyToReOffer() | there is another INVITE/UPDATE transaction in progress');
                return false;
              }

              return true;
            }
          }, {
            key: "_close",
            value: function _close() {
              logger.debug('close()'); // Close local MediaStream if it was not given by the user.

              if (this._localMediaStream && this._localMediaStreamLocallyGenerated) {
                logger.debug('close() | closing local MediaStream');
                Utils.closeMediaStream(this._localMediaStream);
              }

              if (this._status === C.STATUS_TERMINATED) {
                return;
              }

              this._status = C.STATUS_TERMINATED; // Terminate RTC.

              if (this._connection) {
                try {
                  this._connection.close();
                } catch (error) {
                  logger.warn('close() | error closing the RTCPeerConnection: %o', error);
                }
              } // Terminate signaling.
              // Clear SIP timers.


              for (var timer in this._timers) {
                if (Object.prototype.hasOwnProperty.call(this._timers, timer)) {
                  clearTimeout(this._timers[timer]);
                }
              } // Clear Session Timers.


              clearTimeout(this._sessionTimers.timer); // Terminate confirmed dialog.

              if (this._dialog) {
                this._dialog.terminate();

                delete this._dialog;
              } // Terminate early dialogs.


              for (var dialog in this._earlyDialogs) {
                if (Object.prototype.hasOwnProperty.call(this._earlyDialogs, dialog)) {
                  this._earlyDialogs[dialog].terminate();

                  delete this._earlyDialogs[dialog];
                }
              } // Terminate REFER subscribers.


              for (var subscriber in this._referSubscribers) {
                if (Object.prototype.hasOwnProperty.call(this._referSubscribers, subscriber)) {
                  delete this._referSubscribers[subscriber];
                }
              }

              this._ua.destroyRTCSession(this);
            }
            /**
             * Private API.
             */

            /**
             * RFC3261 13.3.1.4
             * Response retransmissions cannot be accomplished by transaction layer
             *  since it is destroyed when receiving the first 2xx answer
             */

          }, {
            key: "_setInvite2xxTimer",
            value: function _setInvite2xxTimer(request, body) {
              var timeout = Timers.T1;

              function invite2xxRetransmission() {
                if (this._status !== C.STATUS_WAITING_FOR_ACK) {
                  return;
                }

                request.reply(200, null, ["Contact: ".concat(this._contact)], body);

                if (timeout < Timers.T2) {
                  timeout = timeout * 2;

                  if (timeout > Timers.T2) {
                    timeout = Timers.T2;
                  }
                }

                this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);
              }

              this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);
            }
            /**
             * RFC3261 14.2
             * If a UAS generates a 2xx response and never receives an ACK,
             *  it SHOULD generate a BYE to terminate the dialog.
             */

          }, {
            key: "_setACKTimer",
            value: function _setACKTimer() {
              var _this11 = this;

              this._timers.ackTimer = setTimeout(function () {
                if (_this11._status === C.STATUS_WAITING_FOR_ACK) {
                  logger.debug('no ACK received, terminating the session');
                  clearTimeout(_this11._timers.invite2xxTimer);

                  _this11.sendRequest(JsSIP_C.BYE);

                  _this11._ended('remote', null, JsSIP_C.causes.NO_ACK);
                }
              }, Timers.TIMER_H);
            }
          }, {
            key: "_createRTCConnection",
            value: function _createRTCConnection(pcConfig, rtcConstraints) {
              var _this12 = this;

              this._connection = new RTCPeerConnection(pcConfig, rtcConstraints);

              this._connection.addEventListener('iceconnectionstatechange', function () {
                var state = _this12._connection.iceConnectionState; // TODO: Do more with different states.

                if (state === 'failed') {
                  _this12.terminate({
                    cause: JsSIP_C.causes.RTP_TIMEOUT,
                    status_code: 408,
                    reason_phrase: JsSIP_C.causes.RTP_TIMEOUT
                  });
                }
              });

              logger.debug('emit "peerconnection"');
              this.emit('peerconnection', {
                peerconnection: this._connection
              });
            }
          }, {
            key: "_createLocalDescription",
            value: function _createLocalDescription(type, constraints) {
              var _this13 = this;

              logger.debug('createLocalDescription()');
              if (type !== 'offer' && type !== 'answer') throw new Error("createLocalDescription() | invalid type \"".concat(type, "\""));
              var connection = this._connection;
              this._rtcReady = false;
              return Promise.resolve() // Create Offer or Answer.
                .then(function () {
                  if (type === 'offer') {
                    return connection.createOffer(constraints)["catch"](function (error) {
                      logger.warn('emit "peerconnection:createofferfailed" [error:%o]', error);

                      _this13.emit('peerconnection:createofferfailed', error);

                      return Promise.reject(error);
                    });
                  } else {
                    return connection.createAnswer(constraints)["catch"](function (error) {
                      logger.warn('emit "peerconnection:createanswerfailed" [error:%o]', error);

                      _this13.emit('peerconnection:createanswerfailed', error);

                      return Promise.reject(error);
                    });
                  }
                }) // Set local description.
                .then(function (desc) {
                  return connection.setLocalDescription(desc)["catch"](function (error) {
                    _this13._rtcReady = true;
                    logger.warn('emit "peerconnection:setlocaldescriptionfailed" [error:%o]', error);

                    _this13.emit('peerconnection:setlocaldescriptionfailed', error);

                    return Promise.reject(error);
                  });
                }).then(function () {
                  // Resolve right away if 'pc.iceGatheringState' is 'complete'.

                  /**
                   * Resolve right away if:
                   * - 'connection.iceGatheringState' is 'complete' and no 'iceRestart' constraint is set.
                   * - 'connection.iceGatheringState' is 'gathering' and 'iceReady' is true.
                   */
                  var iceRestart = constraints && constraints.iceRestart;

                  if (connection.iceGatheringState === 'complete' && !iceRestart || connection.iceGatheringState === 'gathering' && _this13._iceReady) {
                    _this13._rtcReady = true;
                    var e = {
                      originator: 'local',
                      type: type,
                      sdp: connection.localDescription.sdp
                    };
                    logger.debug('emit "sdp"');

                    _this13.emit('sdp', e);

                    return Promise.resolve(e.sdp);
                  } // Add 'pc.onicencandidate' event handler to resolve on last candidate.


                  return new Promise(function (resolve) {
                    var finished = false;
                    var iceCandidateListener;
                    var iceGatheringStateListener;
                    _this13._iceReady = false;

                    var ready = function ready() {
                      connection.removeEventListener('icecandidate', iceCandidateListener);
                      connection.removeEventListener('icegatheringstatechange', iceGatheringStateListener);
                      finished = true;
                      _this13._rtcReady = true; // connection.iceGatheringState will still indicate 'gathering' and thus be blocking.

                      _this13._iceReady = true;
                      var e = {
                        originator: 'local',
                        type: type,
                        sdp: connection.localDescription.sdp
                      };
                      logger.debug('emit "sdp"');

                      _this13.emit('sdp', e);

                      resolve(e.sdp);
                    };

                    connection.addEventListener('icecandidate', iceCandidateListener = function iceCandidateListener(event) {
                      var candidate = event.candidate;

                      if (candidate) {
                        _this13.emit('icecandidate', {
                          candidate: candidate,
                          ready: ready
                        });
                      } else if (!finished) {
                        ready();
                      }
                    });
                    connection.addEventListener('icegatheringstatechange', iceGatheringStateListener = function iceGatheringStateListener() {
                      if (connection.iceGatheringState === 'complete' && !finished) {
                        ready();
                      }
                    });
                  });
                });
            }
            /**
             * Dialog Management
             */

          }, {
            key: "_createDialog",
            value: function _createDialog(message, type, early) {
              var local_tag = type === 'UAS' ? message.to_tag : message.from_tag;
              var remote_tag = type === 'UAS' ? message.from_tag : message.to_tag;
              var id = message.call_id + local_tag + remote_tag;
              var early_dialog = this._earlyDialogs[id]; // Early Dialog.

              if (early) {
                if (early_dialog) {
                  return true;
                } else {
                  early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY); // Dialog has been successfully created.

                  if (early_dialog.error) {
                    logger.debug(early_dialog.error);

                    this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);

                    return false;
                  } else {
                    this._earlyDialogs[id] = early_dialog;
                    return true;
                  }
                }
              } // Confirmed Dialog.
              else {
                this._from_tag = message.from_tag;
                this._to_tag = message.to_tag; // In case the dialog is in _early_ state, update it.

                if (early_dialog) {
                  early_dialog.update(message, type);
                  this._dialog = early_dialog;
                  delete this._earlyDialogs[id];
                  return true;
                } // Otherwise, create a _confirmed_ dialog.


                var dialog = new Dialog(this, message, type);

                if (dialog.error) {
                  logger.debug(dialog.error);

                  this._failed('remote', message, JsSIP_C.causes.INTERNAL_ERROR);

                  return false;
                } else {
                  this._dialog = dialog;
                  return true;
                }
              }
            }
            /**
             * In dialog INVITE Reception
             */

          }, {
            key: "_receiveReinvite",
            value: function _receiveReinvite(request) {
              var _this14 = this;

              logger.debug('receiveReinvite()');
              var contentType = request.hasHeader('Content-Type') ? request.getHeader('Content-Type').toLowerCase() : undefined;
              var data = {
                request: request,
                callback: undefined,
                reject: reject.bind(this)
              };
              var rejected = false;

              function reject() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                rejected = true;
                var status_code = options.status_code || 403;
                var reason_phrase = options.reason_phrase || '';
                var extraHeaders = Utils.cloneArray(options.extraHeaders);

                if (this._status !== C.STATUS_CONFIRMED) {
                  return false;
                }

                if (status_code < 300 || status_code >= 700) {
                  throw new TypeError("Invalid status_code: ".concat(status_code));
                }

                request.reply(status_code, reason_phrase, extraHeaders);
              } // Emit 'reinvite'.


              this.emit('reinvite', data);

              if (rejected) {
                return;
              }

              this._late_sdp = false; // Request without SDP.

              if (!request.body) {
                this._late_sdp = true;

                if (this._remoteHold) {
                  this._remoteHold = false;

                  this._onunhold('remote');
                }

                this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                  return _this14._createLocalDescription('offer', _this14._rtcOfferConstraints);
                }).then(function (sdp) {
                  sendAnswer.call(_this14, sdp);
                })["catch"](function () {
                  request.reply(500);
                });
                return;
              } // Request with SDP.


              if (contentType !== 'application/sdp') {
                logger.debug('invalid Content-Type');
                request.reply(415);
                return;
              }

              this._processInDialogSdpOffer(request) // Send answer.
                .then(function (desc) {
                  if (_this14._status === C.STATUS_TERMINATED) {
                    return;
                  }

                  sendAnswer.call(_this14, desc);
                })["catch"](function (error) {
                  logger.warn(error);
                });

              function sendAnswer(desc) {
                var _this15 = this;

                var extraHeaders = ["Contact: ".concat(this._contact)];

                this._handleSessionTimersInIncomingRequest(request, extraHeaders);

                if (this._late_sdp) {
                  desc = this._mangleOffer(desc);
                }

                request.reply(200, null, extraHeaders, desc, function () {
                  _this15._status = C.STATUS_WAITING_FOR_ACK;

                  _this15._setInvite2xxTimer(request, desc);

                  _this15._setACKTimer();
                }); // If callback is given execute it.

                if (typeof data.callback === 'function') {
                  data.callback();
                }
              }
            }
            /**
             * In dialog UPDATE Reception
             */

          }, {
            key: "_receiveUpdate",
            value: function _receiveUpdate(request) {
              var _this16 = this;

              logger.debug('receiveUpdate()');
              var contentType = request.hasHeader('Content-Type') ? request.getHeader('Content-Type').toLowerCase() : undefined;
              var data = {
                request: request,
                callback: undefined,
                reject: reject.bind(this)
              };
              var rejected = false;

              function reject() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                rejected = true;
                var status_code = options.status_code || 403;
                var reason_phrase = options.reason_phrase || '';
                var extraHeaders = Utils.cloneArray(options.extraHeaders);

                if (this._status !== C.STATUS_CONFIRMED) {
                  return false;
                }

                if (status_code < 300 || status_code >= 700) {
                  throw new TypeError("Invalid status_code: ".concat(status_code));
                }

                request.reply(status_code, reason_phrase, extraHeaders);
              } // Emit 'update'.


              this.emit('update', data);

              if (rejected) {
                return;
              }

              if (!request.body) {
                sendAnswer.call(this, null);
                return;
              }

              if (contentType !== 'application/sdp') {
                logger.debug('invalid Content-Type');
                request.reply(415);
                return;
              }

              this._processInDialogSdpOffer(request) // Send answer.
                .then(function (desc) {
                  if (_this16._status === C.STATUS_TERMINATED) {
                    return;
                  }

                  sendAnswer.call(_this16, desc);
                })["catch"](function (error) {
                  logger.warn(error);
                });

              function sendAnswer(desc) {
                var extraHeaders = ["Contact: ".concat(this._contact)];

                this._handleSessionTimersInIncomingRequest(request, extraHeaders);

                request.reply(200, null, extraHeaders, desc); // If callback is given execute it.

                if (typeof data.callback === 'function') {
                  data.callback();
                }
              }
            }
          }, {
            key: "_processInDialogSdpOffer",
            value: function _processInDialogSdpOffer(request) {
              var _this17 = this;

              logger.debug('_processInDialogSdpOffer()');
              var sdp = request.parseSDP();
              var hold = false;

              var _iterator4 = _createForOfIteratorHelper(sdp.media),
                _step4;

              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var m = _step4.value;

                  if (holdMediaTypes.indexOf(m.type) === -1) {
                    continue;
                  }

                  var direction = m.direction || sdp.direction || 'sendrecv';

                  if (direction === 'sendonly' || direction === 'inactive') {
                    hold = true;
                  } // If at least one of the streams is active don't emit 'hold'.
                  else {
                    hold = false;
                    break;
                  }
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }

              var e = {
                originator: 'remote',
                type: 'offer',
                sdp: request.body
              };
              logger.debug('emit "sdp"');
              this.emit('sdp', e);
              var offer = new RTCSessionDescription({
                type: 'offer',
                sdp: e.sdp
              });
              this._connectionPromiseQueue = this._connectionPromiseQueue // Set remote description.
                .then(function () {
                  if (_this17._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  return _this17._connection.setRemoteDescription(offer)["catch"](function (error) {
                    request.reply(488);
                    logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                    _this17.emit('peerconnection:setremotedescriptionfailed', error);

                    throw error;
                  });
                }).then(function () {
                  if (_this17._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  if (_this17._remoteHold === true && hold === false) {
                    _this17._remoteHold = false;

                    _this17._onunhold('remote');
                  } else if (_this17._remoteHold === false && hold === true) {
                    _this17._remoteHold = true;

                    _this17._onhold('remote');
                  }
                }) // Create local description.
                .then(function () {
                  if (_this17._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  return _this17._createLocalDescription('answer', _this17._rtcAnswerConstraints)["catch"](function (error) {
                    request.reply(500);
                    logger.warn('emit "peerconnection:createtelocaldescriptionfailed" [error:%o]', error);
                    throw error;
                  });
                })["catch"](function (error) {
                  logger.warn('_processInDialogSdpOffer() failed [error: %o]', error);
                });
              return this._connectionPromiseQueue;
            }
            /**
             * In dialog Refer Reception
             */

          }, {
            key: "_receiveRefer",
            value: function _receiveRefer(request) {
              var _this18 = this;

              logger.debug('receiveRefer()');

              if (!request.refer_to) {
                logger.debug('no Refer-To header field present in REFER');
                request.reply(400);
                return;
              }

              if (request.refer_to.uri.scheme !== JsSIP_C.SIP) {
                logger.debug('Refer-To header field points to a non-SIP URI scheme');
                request.reply(416);
                return;
              } // Reply before the transaction timer expires.


              request.reply(202);
              var notifier = new RTCSession_ReferNotifier(this, request.cseq);
              logger.debug('emit "refer"'); // Emit 'refer'.

              this.emit('refer', {
                request: request,
                accept: function accept(initCallback, options) {
                  _accept.call(_this18, initCallback, options);
                },
                reject: function reject() {
                  _reject.call(_this18);
                }
              });

              function _accept(initCallback) {
                var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                initCallback = typeof initCallback === 'function' ? initCallback : null;

                if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {
                  return false;
                }

                var session = new RTCSession(this._ua);
                session.on('progress', function (_ref2) {
                  var response = _ref2.response;
                  notifier.notify(response.status_code, response.reason_phrase);
                });
                session.on('accepted', function (_ref3) {
                  var response = _ref3.response;
                  notifier.notify(response.status_code, response.reason_phrase);
                });
                session.on('_failed', function (_ref4) {
                  var message = _ref4.message,
                    cause = _ref4.cause;

                  if (message) {
                    notifier.notify(message.status_code, message.reason_phrase);
                  } else {
                    notifier.notify(487, cause);
                  }
                }); // Consider the Replaces header present in the Refer-To URI.

                if (request.refer_to.uri.hasHeader('replaces')) {
                  var replaces = decodeURIComponent(request.refer_to.uri.getHeader('replaces'));
                  options.extraHeaders = Utils.cloneArray(options.extraHeaders);
                  options.extraHeaders.push("Replaces: ".concat(replaces));
                }

                session.connect(request.refer_to.uri.toAor(), options, initCallback);
              }

              function _reject() {
                notifier.notify(603);
              }
            }
            /**
             * In dialog Notify Reception
             */

          }, {
            key: "_receiveNotify",
            value: function _receiveNotify(request) {
              logger.debug('receiveNotify()');

              if (!request.event) {
                request.reply(400);
              }

              switch (request.event.event) {
                case 'refer':
                  {
                    var id;
                    var referSubscriber;

                    if (request.event.params && request.event.params.id) {
                      id = request.event.params.id;
                      referSubscriber = this._referSubscribers[id];
                    } else if (Object.keys(this._referSubscribers).length === 1) {
                      referSubscriber = this._referSubscribers[Object.keys(this._referSubscribers)[0]];
                    } else {
                      request.reply(400, 'Missing event id parameter');
                      return;
                    }

                    if (!referSubscriber) {
                      request.reply(481, 'Subscription does not exist');
                      return;
                    }

                    referSubscriber.receiveNotify(request);
                    request.reply(200);
                    break;
                  }

                default:
                  {
                    request.reply(489);
                  }
              }
            }
            /**
             * INVITE with Replaces Reception
             */

          }, {
            key: "_receiveReplaces",
            value: function _receiveReplaces(request) {
              var _this20 = this;

              logger.debug('receiveReplaces()');

              function _accept2(initCallback) {
                var _this19 = this;

                if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {
                  return false;
                }

                var session = new RTCSession(this._ua); // Terminate the current session when the new one is confirmed.

                session.on('confirmed', function () {
                  _this19.terminate();
                });
                session.init_incoming(request, initCallback);
              }

              function _reject2() {
                logger.debug('Replaced INVITE rejected by the user');
                request.reply(486);
              } // Emit 'replace'.


              this.emit('replaces', {
                request: request,
                accept: function accept(initCallback) {
                  _accept2.call(_this20, initCallback);
                },
                reject: function reject() {
                  _reject2.call(_this20);
                }
              });
            }
            /**
             * Initial Request Sender
             */

          }, {
            key: "_sendInitialRequest",
            value: function _sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream) {
              var _this21 = this;

              var request_sender = new RequestSender(this._ua, this._request, {
                onRequestTimeout: function onRequestTimeout() {
                  _this21.onRequestTimeout();
                },
                onTransportError: function onTransportError() {
                  _this21.onTransportError();
                },
                // Update the request on authentication.
                onAuthenticated: function onAuthenticated(request) {
                  _this21._request = request;
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  _this21._receiveInviteResponse(response);
                }
              }); // This Promise is resolved within the next iteration, so the app has now
              // a chance to set events such as 'peerconnection' and 'connecting'.

              Promise.resolve() // Get a stream if required.
                .then(function () {
                  // A stream is given, let the app set events such as 'peerconnection' and 'connecting'.
                  if (mediaStream) {
                    return mediaStream;
                  } // Request for user media access.
                  else if (mediaConstraints.audio || mediaConstraints.video) {
                    _this21._localMediaStreamLocallyGenerated = true;
                    return navigator.mediaDevices.getUserMedia(mediaConstraints)["catch"](function (error) {
                      if (_this21._status === C.STATUS_TERMINATED) {
                        throw new Error('terminated');
                      }

                      _this21._failed('local', null, JsSIP_C.causes.USER_DENIED_MEDIA_ACCESS);

                      logger.warn('emit "getusermediafailed" [error:%o]', error);

                      _this21.emit('getusermediafailed', error);

                      throw error;
                    });
                  }
                }).then(function (stream) {
                  if (_this21._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  _this21._localMediaStream = stream;

                  if (stream) {
                    stream.getTracks().forEach(function (track) {
                      _this21._connection.addTrack(track, stream);
                    });
                  } // TODO: should this be triggered here?


                  _this21._connecting(_this21._request);

                  return _this21._createLocalDescription('offer', rtcOfferConstraints)["catch"](function (error) {
                    _this21._failed('local', null, JsSIP_C.causes.WEBRTC_ERROR);

                    throw error;
                  });
                }).then(function (desc) {
                  if (_this21._is_canceled || _this21._status === C.STATUS_TERMINATED) {
                    throw new Error('terminated');
                  }

                  _this21._request.body = desc;
                  _this21._status = C.STATUS_INVITE_SENT;
                  logger.debug('emit "sending" [request:%o]', _this21._request); // Emit 'sending' so the app can mangle the body before the request is sent.

                  _this21.emit('sending', {
                    request: _this21._request
                  });

                  request_sender.send();
                })["catch"](function (error) {
                  if (_this21._status === C.STATUS_TERMINATED) {
                    return;
                  }

                  logger.warn(error);
                });
            }
            /**
             * Get DTMF RTCRtpSender.
             */

          }, {
            key: "_getDTMFRTPSender",
            value: function _getDTMFRTPSender() {
              var sender = this._connection.getSenders().find(function (rtpSender) {
                return rtpSender.track && rtpSender.track.kind === 'audio';
              });

              if (!(sender && sender.dtmf)) {
                logger.warn('sendDTMF() | no local audio track to send DTMF with');
                return;
              }

              return sender.dtmf;
            }
            /**
             * Reception of Response for Initial INVITE
             */

          }, {
            key: "_receiveInviteResponse",
            value: function _receiveInviteResponse(response) {
              var _this22 = this;

              logger.debug('receiveInviteResponse()'); // Handle 2XX retransmissions and responses from forked requests.

              if (this._dialog && response.status_code >= 200 && response.status_code <= 299) {
                /*
                 * If it is a retransmission from the endpoint that established
                 * the dialog, send an ACK
                 */
                if (this._dialog.id.call_id === response.call_id && this._dialog.id.local_tag === response.from_tag && this._dialog.id.remote_tag === response.to_tag) {
                  this.sendRequest(JsSIP_C.ACK);
                  return;
                } // If not, send an ACK  and terminate.
                else {
                  var dialog = new Dialog(this, response, 'UAC');

                  if (dialog.error !== undefined) {
                    logger.debug(dialog.error);
                    return;
                  }

                  this.sendRequest(JsSIP_C.ACK);
                  this.sendRequest(JsSIP_C.BYE);
                  return;
                }
              } // Proceed to cancellation if the user requested.


              if (this._is_canceled) {
                if (response.status_code >= 100 && response.status_code < 200) {
                  this._request.cancel(this._cancel_reason);
                } else if (response.status_code >= 200 && response.status_code < 299) {
                  this._acceptAndTerminate(response);
                }

                return;
              }

              if (this._status !== C.STATUS_INVITE_SENT && this._status !== C.STATUS_1XX_RECEIVED) {
                return;
              }

              switch (true) {
                case /^100$/.test(response.status_code):
                  this._status = C.STATUS_1XX_RECEIVED;
                  break;

                case /^1[0-9]{2}$/.test(response.status_code):
                  {
                    // Do nothing with 1xx responses without To tag.
                    if (!response.to_tag) {
                      logger.debug('1xx response received without to tag');
                      break;
                    } // Create Early Dialog if 1XX comes with contact.


                    if (response.hasHeader('contact')) {
                      // An error on dialog creation will fire 'failed' event.
                      if (!this._createDialog(response, 'UAC', true)) {
                        break;
                      }
                    }

                    this._status = C.STATUS_1XX_RECEIVED;

                    if (!response.body) {
                      this._progress('remote', response);

                      break;
                    }

                    var e = {
                      originator: 'remote',
                      type: 'answer',
                      sdp: response.body
                    };
                    logger.debug('emit "sdp"');
                    this.emit('sdp', e);
                    var answer = new RTCSessionDescription({
                      type: 'answer',
                      sdp: e.sdp
                    });
                    this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                      return _this22._connection.setRemoteDescription(answer);
                    }).then(function () {
                      return _this22._progress('remote', response);
                    })["catch"](function (error) {
                      logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                      _this22.emit('peerconnection:setremotedescriptionfailed', error);
                    });
                    break;
                  }

                case /^2[0-9]{2}$/.test(response.status_code):
                  {
                    this._status = C.STATUS_CONFIRMED;

                    if (!response.body) {
                      this._acceptAndTerminate(response, 400, JsSIP_C.causes.MISSING_SDP);

                      this._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);

                      break;
                    } // An error on dialog creation will fire 'failed' event.


                    if (!this._createDialog(response, 'UAC')) {
                      break;
                    }

                    var _e = {
                      originator: 'remote',
                      type: 'answer',
                      sdp: response.body
                    };
                    logger.debug('emit "sdp"');
                    this.emit('sdp', _e);

                    var _answer = new RTCSessionDescription({
                      type: 'answer',
                      sdp: _e.sdp
                    });

                    this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                      // Be ready for 200 with SDP after a 180/183 with SDP.
                      // We created a SDP 'answer' for it, so check the current signaling state.
                      if (_this22._connection.signalingState === 'stable') {
                        return _this22._connection.createOffer(_this22._rtcOfferConstraints).then(function (offer) {
                          return _this22._connection.setLocalDescription(offer);
                        })["catch"](function (error) {
                          _this22._acceptAndTerminate(response, 500, error.toString());

                          _this22._failed('local', response, JsSIP_C.causes.WEBRTC_ERROR);
                        });
                      }
                    }).then(function () {
                      _this22._connection.setRemoteDescription(_answer).then(function () {
                        // Handle Session Timers.
                        _this22._handleSessionTimersInIncomingResponse(response);

                        _this22._accepted('remote', response);

                        _this22.sendRequest(JsSIP_C.ACK);

                        _this22._confirmed('local', null);
                      })["catch"](function (error) {
                        _this22._acceptAndTerminate(response, 488, 'Not Acceptable Here');

                        _this22._failed('remote', response, JsSIP_C.causes.BAD_MEDIA_DESCRIPTION);

                        logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                        _this22.emit('peerconnection:setremotedescriptionfailed', error);
                      });
                    });
                    break;
                  }

                default:
                  {
                    var cause = Utils.sipErrorCause(response.status_code);

                    this._failed('remote', response, cause);
                  }
              }
            }
            /**
             * Send Re-INVITE
             */

          }, {
            key: "_sendReinvite",
            value: function _sendReinvite() {
              var _this23 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              logger.debug('sendReinvite()');
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var eventHandlers = Utils.cloneObject(options.eventHandlers);
              var rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;
              var succeeded = false;
              extraHeaders.push("Contact: ".concat(this._contact));
              extraHeaders.push('Content-Type: application/sdp'); // Session Timers.

              if (this._sessionTimers.running) {
                extraHeaders.push("Session-Expires: ".concat(this._sessionTimers.currentExpires, ";refresher=").concat(this._sessionTimers.refresher ? 'uac' : 'uas'));
              }

              this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                return _this23._createLocalDescription('offer', rtcOfferConstraints);
              }).then(function (sdp) {
                sdp = _this23._mangleOffer(sdp);
                var e = {
                  originator: 'local',
                  type: 'offer',
                  sdp: sdp
                };
                logger.debug('emit "sdp"');

                _this23.emit('sdp', e);

                _this23.sendRequest(JsSIP_C.INVITE, {
                  extraHeaders: extraHeaders,
                  body: sdp,
                  eventHandlers: {
                    onSuccessResponse: function onSuccessResponse(response) {
                      onSucceeded.call(_this23, response);
                      succeeded = true;
                    },
                    onErrorResponse: function onErrorResponse(response) {
                      onFailed.call(_this23, response);
                    },
                    onTransportError: function onTransportError() {
                      _this23.onTransportError(); // Do nothing because session ends.

                    },
                    onRequestTimeout: function onRequestTimeout() {
                      _this23.onRequestTimeout(); // Do nothing because session ends.

                    },
                    onDialogError: function onDialogError() {
                      _this23.onDialogError(); // Do nothing because session ends.

                    }
                  }
                });
              })["catch"](function () {
                onFailed();
              });

              function onSucceeded(response) {
                var _this24 = this;

                if (this._status === C.STATUS_TERMINATED) {
                  return;
                }

                this.sendRequest(JsSIP_C.ACK); // If it is a 2XX retransmission exit now.

                if (succeeded) {
                  return;
                } // Handle Session Timers.


                this._handleSessionTimersInIncomingResponse(response); // Must have SDP answer.


                if (!response.body) {
                  onFailed.call(this);
                  return;
                } else if (!response.hasHeader('Content-Type') || response.getHeader('Content-Type').toLowerCase() !== 'application/sdp') {
                  onFailed.call(this);
                  return;
                }

                var e = {
                  originator: 'remote',
                  type: 'answer',
                  sdp: response.body
                };
                logger.debug('emit "sdp"');
                this.emit('sdp', e);
                var answer = new RTCSessionDescription({
                  type: 'answer',
                  sdp: e.sdp
                });
                this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                  return _this24._connection.setRemoteDescription(answer);
                }).then(function () {
                  if (eventHandlers.succeeded) {
                    eventHandlers.succeeded(response);
                  }
                })["catch"](function (error) {
                  onFailed.call(_this24);
                  logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                  _this24.emit('peerconnection:setremotedescriptionfailed', error);
                });
              }

              function onFailed(response) {
                if (eventHandlers.failed) {
                  eventHandlers.failed(response);
                }
              }
            }
            /**
             * Send UPDATE
             */

          }, {
            key: "_sendUpdate",
            value: function _sendUpdate() {
              var _this25 = this;

              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              logger.debug('sendUpdate()');
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var eventHandlers = Utils.cloneObject(options.eventHandlers);
              var rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;
              var sdpOffer = options.sdpOffer || false;
              var succeeded = false;
              extraHeaders.push("Contact: ".concat(this._contact)); // Session Timers.

              if (this._sessionTimers.running) {
                extraHeaders.push("Session-Expires: ".concat(this._sessionTimers.currentExpires, ";refresher=").concat(this._sessionTimers.refresher ? 'uac' : 'uas'));
              }

              if (sdpOffer) {
                extraHeaders.push('Content-Type: application/sdp');
                this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                  return _this25._createLocalDescription('offer', rtcOfferConstraints);
                }).then(function (sdp) {
                  sdp = _this25._mangleOffer(sdp);
                  var e = {
                    originator: 'local',
                    type: 'offer',
                    sdp: sdp
                  };
                  logger.debug('emit "sdp"');

                  _this25.emit('sdp', e);

                  _this25.sendRequest(JsSIP_C.UPDATE, {
                    extraHeaders: extraHeaders,
                    body: sdp,
                    eventHandlers: {
                      onSuccessResponse: function onSuccessResponse(response) {
                        onSucceeded.call(_this25, response);
                        succeeded = true;
                      },
                      onErrorResponse: function onErrorResponse(response) {
                        onFailed.call(_this25, response);
                      },
                      onTransportError: function onTransportError() {
                        _this25.onTransportError(); // Do nothing because session ends.

                      },
                      onRequestTimeout: function onRequestTimeout() {
                        _this25.onRequestTimeout(); // Do nothing because session ends.

                      },
                      onDialogError: function onDialogError() {
                        _this25.onDialogError(); // Do nothing because session ends.

                      }
                    }
                  });
                })["catch"](function () {
                  onFailed.call(_this25);
                });
              } // No SDP.
              else {
                this.sendRequest(JsSIP_C.UPDATE, {
                  extraHeaders: extraHeaders,
                  eventHandlers: {
                    onSuccessResponse: function onSuccessResponse(response) {
                      onSucceeded.call(_this25, response);
                    },
                    onErrorResponse: function onErrorResponse(response) {
                      onFailed.call(_this25, response);
                    },
                    onTransportError: function onTransportError() {
                      _this25.onTransportError(); // Do nothing because session ends.

                    },
                    onRequestTimeout: function onRequestTimeout() {
                      _this25.onRequestTimeout(); // Do nothing because session ends.

                    },
                    onDialogError: function onDialogError() {
                      _this25.onDialogError(); // Do nothing because session ends.

                    }
                  }
                });
              }

              function onSucceeded(response) {
                var _this26 = this;

                if (this._status === C.STATUS_TERMINATED) {
                  return;
                } // If it is a 2XX retransmission exit now.


                if (succeeded) {
                  return;
                } // Handle Session Timers.


                this._handleSessionTimersInIncomingResponse(response); // Must have SDP answer.


                if (sdpOffer) {
                  if (!response.body) {
                    onFailed.call(this);
                    return;
                  } else if (!response.hasHeader('Content-Type') || response.getHeader('Content-Type').toLowerCase() !== 'application/sdp') {
                    onFailed.call(this);
                    return;
                  }

                  var e = {
                    originator: 'remote',
                    type: 'answer',
                    sdp: response.body
                  };
                  logger.debug('emit "sdp"');
                  this.emit('sdp', e);
                  var answer = new RTCSessionDescription({
                    type: 'answer',
                    sdp: e.sdp
                  });
                  this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {
                    return _this26._connection.setRemoteDescription(answer);
                  }).then(function () {
                    if (eventHandlers.succeeded) {
                      eventHandlers.succeeded(response);
                    }
                  })["catch"](function (error) {
                    onFailed.call(_this26);
                    logger.warn('emit "peerconnection:setremotedescriptionfailed" [error:%o]', error);

                    _this26.emit('peerconnection:setremotedescriptionfailed', error);
                  });
                } // No SDP answer.
                else if (eventHandlers.succeeded) {
                  eventHandlers.succeeded(response);
                }
              }

              function onFailed(response) {
                if (eventHandlers.failed) {
                  eventHandlers.failed(response);
                }
              }
            }
          }, {
            key: "_acceptAndTerminate",
            value: function _acceptAndTerminate(response, status_code, reason_phrase) {
              logger.debug('acceptAndTerminate()');
              var extraHeaders = [];

              if (status_code) {
                reason_phrase = reason_phrase || JsSIP_C.REASON_PHRASE[status_code] || '';
                extraHeaders.push("Reason: SIP ;cause=".concat(status_code, "; text=\"").concat(reason_phrase, "\""));
              } // An error on dialog creation will fire 'failed' event.


              if (this._dialog || this._createDialog(response, 'UAC')) {
                this.sendRequest(JsSIP_C.ACK);
                this.sendRequest(JsSIP_C.BYE, {
                  extraHeaders: extraHeaders
                });
              } // Update session status.


              this._status = C.STATUS_TERMINATED;
            }
            /**
             * Correctly set the SDP direction attributes if the call is on local hold
             */

          }, {
            key: "_mangleOffer",
            value: function _mangleOffer(sdp) {
              if (!this._localHold && !this._remoteHold) {
                return sdp;
              }

              sdp = sdp_transform.parse(sdp); // Local hold.

              if (this._localHold && !this._remoteHold) {
                logger.debug('mangleOffer() | me on hold, mangling offer');

                var _iterator5 = _createForOfIteratorHelper(sdp.media),
                  _step5;

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    var m = _step5.value;

                    if (holdMediaTypes.indexOf(m.type) === -1) {
                      continue;
                    }

                    if (!m.direction) {
                      m.direction = 'sendonly';
                    } else if (m.direction === 'sendrecv') {
                      m.direction = 'sendonly';
                    } else if (m.direction === 'recvonly') {
                      m.direction = 'inactive';
                    }
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
              } // Local and remote hold.
              else if (this._localHold && this._remoteHold) {
                logger.debug('mangleOffer() | both on hold, mangling offer');

                var _iterator6 = _createForOfIteratorHelper(sdp.media),
                  _step6;

                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    var _m = _step6.value;

                    if (holdMediaTypes.indexOf(_m.type) === -1) {
                      continue;
                    }

                    _m.direction = 'inactive';
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }
              } // Remote hold.
              else if (this._remoteHold) {
                logger.debug('mangleOffer() | remote on hold, mangling offer');

                var _iterator7 = _createForOfIteratorHelper(sdp.media),
                  _step7;

                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    var _m2 = _step7.value;

                    if (holdMediaTypes.indexOf(_m2.type) === -1) {
                      continue;
                    }

                    if (!_m2.direction) {
                      _m2.direction = 'recvonly';
                    } else if (_m2.direction === 'sendrecv') {
                      _m2.direction = 'recvonly';
                    } else if (_m2.direction === 'recvonly') {
                      _m2.direction = 'inactive';
                    }
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }
              }

              return sdp_transform.write(sdp);
            }
          }, {
            key: "_setLocalMediaStatus",
            value: function _setLocalMediaStatus() {
              var enableAudio = true,
                enableVideo = true;

              if (this._localHold || this._remoteHold) {
                enableAudio = false;
                enableVideo = false;
              }

              if (this._audioMuted) {
                enableAudio = false;
              }

              if (this._videoMuted) {
                enableVideo = false;
              }

              this._toggleMuteAudio(!enableAudio);

              this._toggleMuteVideo(!enableVideo);
            }
            /**
             * Handle SessionTimers for an incoming INVITE or UPDATE.
             * @param  {IncomingRequest} request
             * @param  {Array} responseExtraHeaders  Extra headers for the 200 response.
             */

          }, {
            key: "_handleSessionTimersInIncomingRequest",
            value: function _handleSessionTimersInIncomingRequest(request, responseExtraHeaders) {
              if (!this._sessionTimers.enabled) {
                return;
              }

              var session_expires_refresher;

              if (request.session_expires && request.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES) {
                this._sessionTimers.currentExpires = request.session_expires;
                session_expires_refresher = request.session_expires_refresher || 'uas';
              } else {
                this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;
                session_expires_refresher = 'uas';
              }

              responseExtraHeaders.push("Session-Expires: ".concat(this._sessionTimers.currentExpires, ";refresher=").concat(session_expires_refresher));
              this._sessionTimers.refresher = session_expires_refresher === 'uas';

              this._runSessionTimer();
            }
            /**
             * Handle SessionTimers for an incoming response to INVITE or UPDATE.
             * @param  {IncomingResponse} response
             */

          }, {
            key: "_handleSessionTimersInIncomingResponse",
            value: function _handleSessionTimersInIncomingResponse(response) {
              if (!this._sessionTimers.enabled) {
                return;
              }

              var session_expires_refresher;

              if (response.session_expires && response.session_expires >= JsSIP_C.MIN_SESSION_EXPIRES) {
                this._sessionTimers.currentExpires = response.session_expires;
                session_expires_refresher = response.session_expires_refresher || 'uac';
              } else {
                this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;
                session_expires_refresher = 'uac';
              }

              this._sessionTimers.refresher = session_expires_refresher === 'uac';

              this._runSessionTimer();
            }
          }, {
            key: "_runSessionTimer",
            value: function _runSessionTimer() {
              var _this27 = this;

              var expires = this._sessionTimers.currentExpires;
              this._sessionTimers.running = true;
              clearTimeout(this._sessionTimers.timer); // I'm the refresher.

              if (this._sessionTimers.refresher) {
                this._sessionTimers.timer = setTimeout(function () {
                  if (_this27._status === C.STATUS_TERMINATED) {
                    return;
                  }

                  if (!_this27._isReadyToReOffer()) {
                    return;
                  }

                  logger.debug('runSessionTimer() | sending session refresh request');

                  if (_this27._sessionTimers.refreshMethod === JsSIP_C.UPDATE) {
                    _this27._sendUpdate();
                  } else {
                    _this27._sendReinvite();
                  }
                }, expires * 500); // Half the given interval (as the RFC states).
              } // I'm not the refresher.
              else {
                this._sessionTimers.timer = setTimeout(function () {
                  if (_this27._status === C.STATUS_TERMINATED) {
                    return;
                  }

                  logger.warn('runSessionTimer() | timer expired, terminating the session');

                  _this27.terminate({
                    cause: JsSIP_C.causes.REQUEST_TIMEOUT,
                    status_code: 408,
                    reason_phrase: 'Session Timer Expired'
                  });
                }, expires * 1100);
              }
            }
          }, {
            key: "_toggleMuteAudio",
            value: function _toggleMuteAudio(mute) {
              var senders = this._connection.getSenders().filter(function (sender) {
                return sender.track && sender.track.kind === 'audio';
              });

              var _iterator8 = _createForOfIteratorHelper(senders),
                _step8;

              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var sender = _step8.value;
                  sender.track.enabled = !mute;
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
            }
          }, {
            key: "_toggleMuteVideo",
            value: function _toggleMuteVideo(mute) {
              var senders = this._connection.getSenders().filter(function (sender) {
                return sender.track && sender.track.kind === 'video';
              });

              var _iterator9 = _createForOfIteratorHelper(senders),
                _step9;

              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var sender = _step9.value;
                  sender.track.enabled = !mute;
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
            }
          }, {
            key: "_newRTCSession",
            value: function _newRTCSession(originator, request) {
              logger.debug('newRTCSession()');

              this._ua.newRTCSession(this, {
                originator: originator,
                session: this,
                request: request
              });
            }
          }, {
            key: "_connecting",
            value: function _connecting(request) {
              logger.debug('session connecting');
              logger.debug('emit "connecting"');
              this.emit('connecting', {
                request: request
              });
            }
          }, {
            key: "_progress",
            value: function _progress(originator, response) {
              logger.debug('session progress');
              logger.debug('emit "progress"');
              this.emit('progress', {
                originator: originator,
                response: response || null
              });
            }
          }, {
            key: "_accepted",
            value: function _accepted(originator, message) {
              logger.debug('session accepted');
              this._start_time = new Date();
              logger.debug('emit "accepted"');
              this.emit('accepted', {
                originator: originator,
                response: message || null
              });
            }
          }, {
            key: "_confirmed",
            value: function _confirmed(originator, ack) {
              logger.debug('session confirmed');
              this._is_confirmed = true;
              logger.debug('emit "confirmed"');
              this.emit('confirmed', {
                originator: originator,
                ack: ack || null
              });
            }
          }, {
            key: "_ended",
            value: function _ended(originator, message, cause) {
              logger.debug('session ended');
              this._end_time = new Date();

              this._close();

              logger.debug('emit "ended"');
              this.emit('ended', {
                originator: originator,
                message: message || null,
                cause: cause
              });
            }
          }, {
            key: "_failed",
            value: function _failed(originator, message, cause) {
              logger.debug('session failed'); // Emit private '_failed' event first.

              logger.debug('emit "_failed"');
              this.emit('_failed', {
                originator: originator,
                message: message || null,
                cause: cause
              });

              this._close();

              logger.debug('emit "failed"');
              this.emit('failed', {
                originator: originator,
                message: message || null,
                cause: cause
              });
            }
          }, {
            key: "_onhold",
            value: function _onhold(originator) {
              logger.debug('session onhold');

              this._setLocalMediaStatus();

              logger.debug('emit "hold"');
              this.emit('hold', {
                originator: originator
              });
            }
          }, {
            key: "_onunhold",
            value: function _onunhold(originator) {
              logger.debug('session onunhold');

              this._setLocalMediaStatus();

              logger.debug('emit "unhold"');
              this.emit('unhold', {
                originator: originator
              });
            }
          }, {
            key: "_onmute",
            value: function _onmute(_ref5) {
              var audio = _ref5.audio,
                video = _ref5.video;
              logger.debug('session onmute');

              this._setLocalMediaStatus();

              logger.debug('emit "muted"');
              this.emit('muted', {
                audio: audio,
                video: video
              });
            }
          }, {
            key: "_onunmute",
            value: function _onunmute(_ref6) {
              var audio = _ref6.audio,
                video = _ref6.video;
              logger.debug('session onunmute');

              this._setLocalMediaStatus();

              logger.debug('emit "unmuted"');
              this.emit('unmuted', {
                audio: audio,
                video: video
              });
            }
          }, {
            key: "C",
            get: function get() {
              return C;
            } // Expose session failed/ended causes as a property of the RTCSession instance.

          }, {
            key: "causes",
            get: function get() {
              return JsSIP_C.causes;
            }
          }, {
            key: "id",
            get: function get() {
              return this._id;
            }
          }, {
            key: "connection",
            get: function get() {
              return this._connection;
            }
          }, {
            key: "contact",
            get: function get() {
              return this._contact;
            }
          }, {
            key: "direction",
            get: function get() {
              return this._direction;
            }
          }, {
            key: "local_identity",
            get: function get() {
              return this._local_identity;
            }
          }, {
            key: "remote_identity",
            get: function get() {
              return this._remote_identity;
            }
          }, {
            key: "start_time",
            get: function get() {
              return this._start_time;
            }
          }, {
            key: "end_time",
            get: function get() {
              return this._end_time;
            }
          }, {
            key: "data",
            get: function get() {
              return this._data;
            },
            set: function set(_data) {
              this._data = _data;
            }
          }, {
            key: "status",
            get: function get() {
              return this._status;
            }
          }]);

          return RTCSession;
        }(EventEmitter);

        /***/
      }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var SIPMessage = __webpack_require__(19);

        var JsSIP_C = __webpack_require__(6);

        var Transactions = __webpack_require__(26);

        var Dialog_RequestSender = __webpack_require__(30);

        var Utils = __webpack_require__(8);

        var logger = new Logger('Dialog');
        var C = {
          // Dialog states.
          STATUS_EARLY: 1,
          STATUS_CONFIRMED: 2
        }; // RFC 3261 12.1.

        module.exports = /*#__PURE__*/function () {
          _createClass(Dialog, null, [{
            key: "C",
            // Expose C object.
            get: function get() {
              return C;
            }
          }]);

          function Dialog(owner, message, type) {
            var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : C.STATUS_CONFIRMED;

            _classCallCheck(this, Dialog);

            this._owner = owner;
            this._ua = owner._ua;
            this._uac_pending_reply = false;
            this._uas_pending_reply = false;

            if (!message.hasHeader('contact')) {
              return {
                error: 'unable to create a Dialog without Contact header field'
              };
            }

            if (message instanceof SIPMessage.IncomingResponse) {
              state = message.status_code < 200 ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
            }

            var contact = message.parseHeader('contact'); // RFC 3261 12.1.1.

            if (type === 'UAS') {
              this._id = {
                call_id: message.call_id,
                local_tag: message.to_tag,
                remote_tag: message.from_tag,
                toString: function toString() {
                  return this.call_id + this.local_tag + this.remote_tag;
                }
              };
              this._state = state;
              this._remote_seqnum = message.cseq;
              this._local_uri = message.parseHeader('to').uri;
              this._remote_uri = message.parseHeader('from').uri;
              this._remote_target = contact.uri;
              this._route_set = message.getHeaders('record-route');
              this._ack_seqnum = this._remote_seqnum;
            } // RFC 3261 12.1.2.
            else if (type === 'UAC') {
              this._id = {
                call_id: message.call_id,
                local_tag: message.from_tag,
                remote_tag: message.to_tag,
                toString: function toString() {
                  return this.call_id + this.local_tag + this.remote_tag;
                }
              };
              this._state = state;
              this._local_seqnum = message.cseq;
              this._local_uri = message.parseHeader('from').uri;
              this._remote_uri = message.parseHeader('to').uri;
              this._remote_target = contact.uri;
              this._route_set = message.getHeaders('record-route').reverse();
              this._ack_seqnum = null;
            }

            this._ua.newDialog(this);

            logger.debug("new ".concat(type, " dialog created with status ").concat(this._state === C.STATUS_EARLY ? 'EARLY' : 'CONFIRMED'));
          }

          _createClass(Dialog, [{
            key: "update",
            value: function update(message, type) {
              this._state = C.STATUS_CONFIRMED;
              logger.debug("dialog ".concat(this._id.toString(), "  changed to CONFIRMED state"));

              if (type === 'UAC') {
                // RFC 3261 13.2.2.4.
                this._route_set = message.getHeaders('record-route').reverse();
              }
            }
          }, {
            key: "terminate",
            value: function terminate() {
              logger.debug("dialog ".concat(this._id.toString(), " deleted"));

              this._ua.destroyDialog(this);
            }
          }, {
            key: "sendRequest",
            value: function sendRequest(method) {
              var _this = this;

              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var eventHandlers = Utils.cloneObject(options.eventHandlers);
              var body = options.body || null;

              var request = this._createRequest(method, extraHeaders, body); // Increase the local CSeq on authentication.


              eventHandlers.onAuthenticated = function () {
                _this._local_seqnum += 1;
              };

              var request_sender = new Dialog_RequestSender(this, request, eventHandlers);
              request_sender.send(); // Return the instance of OutgoingRequest.

              return request;
            }
          }, {
            key: "receiveRequest",
            value: function receiveRequest(request) {
              // Check in-dialog request.
              if (!this._checkInDialogRequest(request)) {
                return;
              } // ACK received. Cleanup this._ack_seqnum.


              if (request.method === JsSIP_C.ACK && this._ack_seqnum !== null) {
                this._ack_seqnum = null;
              } // INVITE received. Set this._ack_seqnum.
              else if (request.method === JsSIP_C.INVITE) {
                this._ack_seqnum = request.cseq;
              }

              this._owner.receiveRequest(request);
            } // RFC 3261 12.2.1.1.

          }, {
            key: "_createRequest",
            value: function _createRequest(method, extraHeaders, body) {
              extraHeaders = Utils.cloneArray(extraHeaders);

              if (!this._local_seqnum) {
                this._local_seqnum = Math.floor(Math.random() * 10000);
              }

              var cseq = method === JsSIP_C.CANCEL || method === JsSIP_C.ACK ? this._local_seqnum : this._local_seqnum += 1;
              var request = new SIPMessage.OutgoingRequest(method, this._remote_target, this._ua, {
                'cseq': cseq,
                'call_id': this._id.call_id,
                'from_uri': this._local_uri,
                'from_tag': this._id.local_tag,
                'to_uri': this._remote_uri,
                'to_tag': this._id.remote_tag,
                'route_set': this._route_set
              }, extraHeaders, body);
              return request;
            } // RFC 3261 12.2.2.

          }, {
            key: "_checkInDialogRequest",
            value: function _checkInDialogRequest(request) {
              var _this2 = this;

              if (!this._remote_seqnum) {
                this._remote_seqnum = request.cseq;
              } else if (request.cseq < this._remote_seqnum) {
                if (request.method === JsSIP_C.ACK) {
                  // We are not expecting any ACK with lower seqnum than the current one.
                  // Or this is not the ACK we are waiting for.
                  if (this._ack_seqnum === null || request.cseq !== this._ack_seqnum) {
                    return false;
                  }
                } else {
                  request.reply(500);
                  return false;
                }
              } else if (request.cseq > this._remote_seqnum) {
                this._remote_seqnum = request.cseq;
              } // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-.


              if (request.method === JsSIP_C.INVITE || request.method === JsSIP_C.UPDATE && request.body) {
                if (this._uac_pending_reply === true) {
                  request.reply(491);
                } else if (this._uas_pending_reply === true) {
                  var retryAfter = (Math.random() * 10 | 0) + 1;
                  request.reply(500, null, ["Retry-After:".concat(retryAfter)]);
                  return false;
                } else {
                  this._uas_pending_reply = true;

                  var stateChanged = function stateChanged() {
                    if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED || request.server_transaction.state === Transactions.C.STATUS_COMPLETED || request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {
                      request.server_transaction.removeListener('stateChanged', stateChanged);
                      _this2._uas_pending_reply = false;
                    }
                  };

                  request.server_transaction.on('stateChanged', stateChanged);
                } // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted.


                if (request.hasHeader('contact')) {
                  request.server_transaction.on('stateChanged', function () {
                    if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED) {
                      _this2._remote_target = request.parseHeader('contact').uri;
                    }
                  });
                }
              } else if (request.method === JsSIP_C.NOTIFY) {
                // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted.
                if (request.hasHeader('contact')) {
                  request.server_transaction.on('stateChanged', function () {
                    if (request.server_transaction.state === Transactions.C.STATUS_COMPLETED) {
                      _this2._remote_target = request.parseHeader('contact').uri;
                    }
                  });
                }
              }

              return true;
            }
          }, {
            key: "id",
            get: function get() {
              return this._id;
            }
          }, {
            key: "local_seqnum",
            get: function get() {
              return this._local_seqnum;
            },
            set: function set(num) {
              this._local_seqnum = num;
            }
          }, {
            key: "owner",
            get: function get() {
              return this._owner;
            }
          }, {
            key: "uac_pending_reply",
            get: function get() {
              return this._uac_pending_reply;
            },
            set: function set(pending) {
              this._uac_pending_reply = pending;
            }
          }, {
            key: "uas_pending_reply",
            get: function get() {
              return this._uas_pending_reply;
            }
          }]);

          return Dialog;
        }();

        /***/
      }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var JsSIP_C = __webpack_require__(6);

        var Transactions = __webpack_require__(26);

        var RTCSession = __webpack_require__(28);

        var RequestSender = __webpack_require__(24); // Default event handlers.


        var EventHandlers = {
          onRequestTimeout: function onRequestTimeout() { },
          onTransportError: function onTransportError() { },
          onSuccessResponse: function onSuccessResponse() { },
          onErrorResponse: function onErrorResponse() { },
          onAuthenticated: function onAuthenticated() { },
          onDialogError: function onDialogError() { }
        };

        module.exports = /*#__PURE__*/function () {
          function DialogRequestSender(dialog, request, eventHandlers) {
            _classCallCheck(this, DialogRequestSender);

            this._dialog = dialog;
            this._ua = dialog._ua;
            this._request = request;
            this._eventHandlers = eventHandlers; // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.

            this._reattempt = false;
            this._reattemptTimer = null; // Define the undefined handlers.

            for (var handler in EventHandlers) {
              if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {
                if (!this._eventHandlers[handler]) {
                  this._eventHandlers[handler] = EventHandlers[handler];
                }
              }
            }
          }

          _createClass(DialogRequestSender, [{
            key: "send",
            value: function send() {
              var _this = this;

              var request_sender = new RequestSender(this._ua, this._request, {
                onRequestTimeout: function onRequestTimeout() {
                  _this._eventHandlers.onRequestTimeout();
                },
                onTransportError: function onTransportError() {
                  _this._eventHandlers.onTransportError();
                },
                onAuthenticated: function onAuthenticated(request) {
                  _this._eventHandlers.onAuthenticated(request);
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  _this._receiveResponse(response);
                }
              });
              request_sender.send(); // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-.

              if ((this._request.method === JsSIP_C.INVITE || this._request.method === JsSIP_C.UPDATE && this._request.body) && request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED) {
                this._dialog.uac_pending_reply = true;

                var stateChanged = function stateChanged() {
                  if (request_sender.clientTransaction.state === Transactions.C.STATUS_ACCEPTED || request_sender.clientTransaction.state === Transactions.C.STATUS_COMPLETED || request_sender.clientTransaction.state === Transactions.C.STATUS_TERMINATED) {
                    request_sender.clientTransaction.removeListener('stateChanged', stateChanged);
                    _this._dialog.uac_pending_reply = false;
                  }
                };

                request_sender.clientTransaction.on('stateChanged', stateChanged);
              }
            }
          }, {
            key: "_receiveResponse",
            value: function _receiveResponse(response) {
              var _this2 = this;

              // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
              if (response.status_code === 408 || response.status_code === 481) {
                this._eventHandlers.onDialogError(response);
              } else if (response.method === JsSIP_C.INVITE && response.status_code === 491) {
                if (this._reattempt) {
                  if (response.status_code >= 200 && response.status_code < 300) {
                    this._eventHandlers.onSuccessResponse(response);
                  } else if (response.status_code >= 300) {
                    this._eventHandlers.onErrorResponse(response);
                  }
                } else {
                  this._request.cseq = this._dialog.local_seqnum += 1;
                  this._reattemptTimer = setTimeout(function () {
                    // TODO: look at dialog state instead.
                    if (_this2._dialog.owner.status !== RTCSession.C.STATUS_TERMINATED) {
                      _this2._reattempt = true;

                      _this2._request_sender.send();
                    }
                  }, 1000);
                }
              } else if (response.status_code >= 200 && response.status_code < 300) {
                this._eventHandlers.onSuccessResponse(response);
              } else if (response.status_code >= 300) {
                this._eventHandlers.onErrorResponse(response);
              }
            }
          }, {
            key: "request",
            get: function get() {
              return this._request;
            }
          }]);

          return DialogRequestSender;
        }();

        /***/
      }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var Exceptions = __webpack_require__(7);

        var Utils = __webpack_require__(8);

        var logger = new Logger('RTCSession:DTMF');
        var C = {
          MIN_DURATION: 70,
          MAX_DURATION: 6000,
          DEFAULT_DURATION: 100,
          MIN_INTER_TONE_GAP: 50,
          DEFAULT_INTER_TONE_GAP: 500
        };

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(DTMF, _EventEmitter);

          var _super = _createSuper(DTMF);

          function DTMF(session) {
            var _this;

            _classCallCheck(this, DTMF);

            _this = _super.call(this);
            _this._session = session;
            _this._direction = null;
            _this._tone = null;
            _this._duration = null;
            _this._request = null;
            return _this;
          }

          _createClass(DTMF, [{
            key: "send",
            value: function send(tone) {
              var _this2 = this;

              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              if (tone === undefined) {
                throw new TypeError('Not enough arguments');
              }

              this._direction = 'outgoing'; // Check RTCSession Status.

              if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {
                throw new Exceptions.InvalidStateError(this._session.status);
              }

              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              this.eventHandlers = Utils.cloneObject(options.eventHandlers); // Check tone type.

              if (typeof tone === 'string') {
                tone = tone.toUpperCase();
              } else if (typeof tone === 'number') {
                tone = tone.toString();
              } else {
                throw new TypeError("Invalid tone: ".concat(tone));
              } // Check tone value.


              if (!tone.match(/^[0-9A-DR#*]$/)) {
                throw new TypeError("Invalid tone: ".concat(tone));
              } else {
                this._tone = tone;
              } // Duration is checked/corrected in RTCSession.


              this._duration = options.duration;
              extraHeaders.push('Content-Type: application/dtmf-relay');
              var body = "Signal=".concat(this._tone, "\r\n");
              body += "Duration=".concat(this._duration);

              this._session.newDTMF({
                originator: 'local',
                dtmf: this,
                request: this._request
              });

              this._session.sendRequest(JsSIP_C.INFO, {
                extraHeaders: extraHeaders,
                eventHandlers: {
                  onSuccessResponse: function onSuccessResponse(response) {
                    _this2.emit('succeeded', {
                      originator: 'remote',
                      response: response
                    });
                  },
                  onErrorResponse: function onErrorResponse(response) {
                    if (_this2.eventHandlers.onFailed) {
                      _this2.eventHandlers.onFailed();
                    }

                    _this2.emit('failed', {
                      originator: 'remote',
                      response: response
                    });
                  },
                  onRequestTimeout: function onRequestTimeout() {
                    _this2._session.onRequestTimeout();
                  },
                  onTransportError: function onTransportError() {
                    _this2._session.onTransportError();
                  },
                  onDialogError: function onDialogError() {
                    _this2._session.onDialogError();
                  }
                },
                body: body
              });
            }
          }, {
            key: "init_incoming",
            value: function init_incoming(request) {
              var reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;
              var reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
              this._direction = 'incoming';
              this._request = request;
              request.reply(200);

              if (request.body) {
                var body = request.body.split('\n');

                if (body.length >= 1) {
                  if (reg_tone.test(body[0])) {
                    this._tone = body[0].replace(reg_tone, '$2');
                  }
                }

                if (body.length >= 2) {
                  if (reg_duration.test(body[1])) {
                    this._duration = parseInt(body[1].replace(reg_duration, '$2'), 10);
                  }
                }
              }

              if (!this._duration) {
                this._duration = C.DEFAULT_DURATION;
              }

              if (!this._tone) {
                logger.debug('invalid INFO DTMF received, discarded');
              } else {
                this._session.newDTMF({
                  originator: 'remote',
                  dtmf: this,
                  request: request
                });
              }
            }
          }, {
            key: "tone",
            get: function get() {
              return this._tone;
            }
          }, {
            key: "duration",
            get: function get() {
              return this._duration;
            }
          }]);

          return DTMF;
        }(EventEmitter);
        /**
         * Expose C object.
         */


        module.exports.C = C;

        /***/
      }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var JsSIP_C = __webpack_require__(6);

        var Exceptions = __webpack_require__(7);

        var Utils = __webpack_require__(8);

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(Info, _EventEmitter);

          var _super = _createSuper(Info);

          function Info(session) {
            var _this;

            _classCallCheck(this, Info);

            _this = _super.call(this);
            _this._session = session;
            _this._direction = null;
            _this._contentType = null;
            _this._body = null;
            return _this;
          }

          _createClass(Info, [{
            key: "send",
            value: function send(contentType, body) {
              var _this2 = this;

              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              this._direction = 'outgoing';

              if (contentType === undefined) {
                throw new TypeError('Not enough arguments');
              } // Check RTCSession Status.


              if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {
                throw new Exceptions.InvalidStateError(this._session.status);
              }

              this._contentType = contentType;
              this._body = body;
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              extraHeaders.push("Content-Type: ".concat(contentType));

              this._session.newInfo({
                originator: 'local',
                info: this,
                request: this.request
              });

              this._session.sendRequest(JsSIP_C.INFO, {
                extraHeaders: extraHeaders,
                eventHandlers: {
                  onSuccessResponse: function onSuccessResponse(response) {
                    _this2.emit('succeeded', {
                      originator: 'remote',
                      response: response
                    });
                  },
                  onErrorResponse: function onErrorResponse(response) {
                    _this2.emit('failed', {
                      originator: 'remote',
                      response: response
                    });
                  },
                  onTransportError: function onTransportError() {
                    _this2._session.onTransportError();
                  },
                  onRequestTimeout: function onRequestTimeout() {
                    _this2._session.onRequestTimeout();
                  },
                  onDialogError: function onDialogError() {
                    _this2._session.onDialogError();
                  }
                },
                body: body
              });
            }
          }, {
            key: "init_incoming",
            value: function init_incoming(request) {
              this._direction = 'incoming';
              this.request = request;
              request.reply(200);
              this._contentType = request.hasHeader('Content-Type') ? request.getHeader('Content-Type').toLowerCase() : undefined;
              this._body = request.body;

              this._session.newInfo({
                originator: 'remote',
                info: this,
                request: request
              });
            }
          }, {
            key: "contentType",
            get: function get() {
              return this._contentType;
            }
          }, {
            key: "body",
            get: function get() {
              return this._body;
            }
          }]);

          return Info;
        }(EventEmitter);

        /***/
      }),
/* 33 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var logger = new Logger('RTCSession:ReferNotifier');
        var C = {
          event_type: 'refer',
          body_type: 'message/sipfrag;version=2.0',
          expires: 300
        };

        module.exports = /*#__PURE__*/function () {
          function ReferNotifier(session, id, expires) {
            _classCallCheck(this, ReferNotifier);

            this._session = session;
            this._id = id;
            this._expires = expires || C.expires;
            this._active = true; // The creation of a Notifier results in an immediate NOTIFY.

            this.notify(100);
          }

          _createClass(ReferNotifier, [{
            key: "notify",
            value: function notify(code, reason) {
              logger.debug('notify()');

              if (this._active === false) {
                return;
              }

              reason = reason || JsSIP_C.REASON_PHRASE[code] || '';
              var state;

              if (code >= 200) {
                state = 'terminated;reason=noresource';
              } else {
                state = "active;expires=".concat(this._expires);
              } // Put this in a try/catch block.


              this._session.sendRequest(JsSIP_C.NOTIFY, {
                extraHeaders: ["Event: ".concat(C.event_type, ";id=").concat(this._id), "Subscription-State: ".concat(state), "Content-Type: ".concat(C.body_type)],
                body: "SIP/2.0 ".concat(code, " ").concat(reason),
                eventHandlers: {
                  // If a negative response is received, subscription is canceled.
                  onErrorResponse: function onErrorResponse() {
                    this._active = false;
                  }
                }
              });
            }
          }]);

          return ReferNotifier;
        }();

        /***/
      }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var Grammar = __webpack_require__(10);

        var Utils = __webpack_require__(8);

        var logger = new Logger('RTCSession:ReferSubscriber');

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(ReferSubscriber, _EventEmitter);

          var _super = _createSuper(ReferSubscriber);

          function ReferSubscriber(session) {
            var _this;

            _classCallCheck(this, ReferSubscriber);

            _this = _super.call(this);
            _this._id = null;
            _this._session = session;
            return _this;
          }

          _createClass(ReferSubscriber, [{
            key: "sendRefer",
            value: function sendRefer(target) {
              var _this2 = this;

              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
              logger.debug('sendRefer()');
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var eventHandlers = Utils.cloneObject(options.eventHandlers); // Set event handlers.

              for (var event in eventHandlers) {
                if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {
                  this.on(event, eventHandlers[event]);
                }
              } // Replaces URI header field.


              var replaces = null;

              if (options.replaces) {
                replaces = options.replaces._request.call_id;
                replaces += ";to-tag=".concat(options.replaces._to_tag);
                replaces += ";from-tag=".concat(options.replaces._from_tag);
                replaces = encodeURIComponent(replaces);
              } // Refer-To header field.


              var referTo = "Refer-To: <".concat(target).concat(replaces ? "?Replaces=".concat(replaces) : '', ">");
              extraHeaders.push(referTo); // Referred-By header field (if not already present).

              if (!extraHeaders.some(function (header) {
                return header.toLowerCase().startsWith('referred-by:');
              })) {
                var referredBy = "Referred-By: <".concat(this._session._ua._configuration.uri._scheme, ":").concat(this._session._ua._configuration.uri._user, "@").concat(this._session._ua._configuration.uri._host, ">");
                extraHeaders.push(referredBy);
              }

              extraHeaders.push("Contact: ".concat(this._session.contact));

              var request = this._session.sendRequest(JsSIP_C.REFER, {
                extraHeaders: extraHeaders,
                eventHandlers: {
                  onSuccessResponse: function onSuccessResponse(response) {
                    _this2._requestSucceeded(response);
                  },
                  onErrorResponse: function onErrorResponse(response) {
                    _this2._requestFailed(response, JsSIP_C.causes.REJECTED);
                  },
                  onTransportError: function onTransportError() {
                    _this2._requestFailed(null, JsSIP_C.causes.CONNECTION_ERROR);
                  },
                  onRequestTimeout: function onRequestTimeout() {
                    _this2._requestFailed(null, JsSIP_C.causes.REQUEST_TIMEOUT);
                  },
                  onDialogError: function onDialogError() {
                    _this2._requestFailed(null, JsSIP_C.causes.DIALOG_ERROR);
                  }
                }
              });

              this._id = request.cseq;
            }
          }, {
            key: "receiveNotify",
            value: function receiveNotify(request) {
              logger.debug('receiveNotify()');

              if (!request.body) {
                return;
              }

              var status_line = Grammar.parse(request.body.trim(), 'Status_Line');

              if (status_line === -1) {
                logger.debug("receiveNotify() | error parsing NOTIFY body: \"".concat(request.body, "\""));
                return;
              }

              switch (true) {
                case /^100$/.test(status_line.status_code):
                  this.emit('trying', {
                    request: request,
                    status_line: status_line
                  });
                  break;

                case /^1[0-9]{2}$/.test(status_line.status_code):
                  this.emit('progress', {
                    request: request,
                    status_line: status_line
                  });
                  break;

                case /^2[0-9]{2}$/.test(status_line.status_code):
                  this.emit('accepted', {
                    request: request,
                    status_line: status_line
                  });
                  break;

                default:
                  this.emit('failed', {
                    request: request,
                    status_line: status_line
                  });
                  break;
              }
            }
          }, {
            key: "_requestSucceeded",
            value: function _requestSucceeded(response) {
              logger.debug('REFER succeeded');
              logger.debug('emit "requestSucceeded"');
              this.emit('requestSucceeded', {
                response: response
              });
            }
          }, {
            key: "_requestFailed",
            value: function _requestFailed(response, cause) {
              logger.debug('REFER failed');
              logger.debug('emit "requestFailed"');
              this.emit('requestFailed', {
                response: response || null,
                cause: cause
              });
            }
          }, {
            key: "id",
            get: function get() {
              return this._id;
            }
          }]);

          return ReferSubscriber;
        }(EventEmitter);

        /***/
      }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var SIPMessage = __webpack_require__(19);

        var Utils = __webpack_require__(8);

        var RequestSender = __webpack_require__(24);

        var Exceptions = __webpack_require__(7);

        var URI = __webpack_require__(9);

        var logger = new Logger('Message');

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(Message, _EventEmitter);

          var _super = _createSuper(Message);

          function Message(ua) {
            var _this;

            _classCallCheck(this, Message);

            _this = _super.call(this);
            _this._ua = ua;
            _this._request = null;
            _this._closed = false;
            _this._direction = null;
            _this._local_identity = null;
            _this._remote_identity = null; // Whether an incoming message has been replied.

            _this._is_replied = false; // Custom message empty object for high level use.

            _this._data = {};
            return _this;
          }

          _createClass(Message, [{
            key: "send",
            value: function send(target, body) {
              var _this2 = this;

              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var originalTarget = target;

              if (target === undefined || body === undefined) {
                throw new TypeError('Not enough arguments');
              } // Check target validity.


              target = this._ua.normalizeTarget(target);

              if (!target) {
                throw new TypeError("Invalid target: ".concat(originalTarget));
              } // Get call options.


              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var eventHandlers = Utils.cloneObject(options.eventHandlers);
              var contentType = options.contentType || 'text/plain';
              var requestParams = {};

              if (options.fromUserName) {
                requestParams.from_uri = new URI('sip', options.fromUserName, this._ua.configuration.uri.host);
                extraHeaders.push("P-Preferred-Identity: ".concat(this._ua.configuration.uri.toString()));
              }

              if (options.fromDisplayName) {
                requestParams.from_display_name = options.fromDisplayName;
              } // Set event handlers.


              for (var event in eventHandlers) {
                if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {
                  this.on(event, eventHandlers[event]);
                }
              }

              extraHeaders.push("Content-Type: ".concat(contentType));
              this._request = new SIPMessage.OutgoingRequest(JsSIP_C.MESSAGE, target, this._ua, requestParams, extraHeaders);

              if (body) {
                this._request.body = body;
              }

              var request_sender = new RequestSender(this._ua, this._request, {
                onRequestTimeout: function onRequestTimeout() {
                  _this2._onRequestTimeout();
                },
                onTransportError: function onTransportError() {
                  _this2._onTransportError();
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  _this2._receiveResponse(response);
                }
              });

              this._newMessage('local', this._request);

              request_sender.send();
            }
          }, {
            key: "init_incoming",
            value: function init_incoming(request) {
              this._request = request;

              this._newMessage('remote', request); // Reply with a 200 OK if the user didn't reply.


              if (!this._is_replied) {
                this._is_replied = true;
                request.reply(200);
              }

              this._close();
            }
            /**
             * Accept the incoming Message
             * Only valid for incoming Messages
             */

          }, {
            key: "accept",
            value: function accept() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var body = options.body;

              if (this._direction !== 'incoming') {
                throw new Exceptions.NotSupportedError('"accept" not supported for outgoing Message');
              }

              if (this._is_replied) {
                throw new Error('incoming Message already replied');
              }

              this._is_replied = true;

              this._request.reply(200, null, extraHeaders, body);
            }
            /**
             * Reject the incoming Message
             * Only valid for incoming Messages
             */

          }, {
            key: "reject",
            value: function reject() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var status_code = options.status_code || 480;
              var reason_phrase = options.reason_phrase;
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var body = options.body;

              if (this._direction !== 'incoming') {
                throw new Exceptions.NotSupportedError('"reject" not supported for outgoing Message');
              }

              if (this._is_replied) {
                throw new Error('incoming Message already replied');
              }

              if (status_code < 300 || status_code >= 700) {
                throw new TypeError("Invalid status_code: ".concat(status_code));
              }

              this._is_replied = true;

              this._request.reply(status_code, reason_phrase, extraHeaders, body);
            }
          }, {
            key: "_receiveResponse",
            value: function _receiveResponse(response) {
              if (this._closed) {
                return;
              }

              switch (true) {
                case /^1[0-9]{2}$/.test(response.status_code):
                  // Ignore provisional responses.
                  break;

                case /^2[0-9]{2}$/.test(response.status_code):
                  this._succeeded('remote', response);

                  break;

                default:
                  {
                    var cause = Utils.sipErrorCause(response.status_code);

                    this._failed('remote', response, cause);

                    break;
                  }
              }
            }
          }, {
            key: "_onRequestTimeout",
            value: function _onRequestTimeout() {
              if (this._closed) {
                return;
              }

              this._failed('system', null, JsSIP_C.causes.REQUEST_TIMEOUT);
            }
          }, {
            key: "_onTransportError",
            value: function _onTransportError() {
              if (this._closed) {
                return;
              }

              this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);
            }
          }, {
            key: "_close",
            value: function _close() {
              this._closed = true;

              this._ua.destroyMessage(this);
            }
            /**
             * Internal Callbacks
             */

          }, {
            key: "_newMessage",
            value: function _newMessage(originator, request) {
              if (originator === 'remote') {
                this._direction = 'incoming';
                this._local_identity = request.to;
                this._remote_identity = request.from;
              } else if (originator === 'local') {
                this._direction = 'outgoing';
                this._local_identity = request.from;
                this._remote_identity = request.to;
              }

              this._ua.newMessage(this, {
                originator: originator,
                message: this,
                request: request
              });
            }
          }, {
            key: "_failed",
            value: function _failed(originator, response, cause) {
              logger.debug('MESSAGE failed');

              this._close();

              logger.debug('emit "failed"');
              this.emit('failed', {
                originator: originator,
                response: response || null,
                cause: cause
              });
            }
          }, {
            key: "_succeeded",
            value: function _succeeded(originator, response) {
              logger.debug('MESSAGE succeeded');

              this._close();

              logger.debug('emit "succeeded"');
              this.emit('succeeded', {
                originator: originator,
                response: response
              });
            }
          }, {
            key: "direction",
            get: function get() {
              return this._direction;
            }
          }, {
            key: "local_identity",
            get: function get() {
              return this._local_identity;
            }
          }, {
            key: "remote_identity",
            get: function get() {
              return this._remote_identity;
            }
          }]);

          return Message;
        }(EventEmitter);

        /***/
      }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

        function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

        function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

        function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

        function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

        function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

        function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

        var EventEmitter = (__webpack_require__(13).EventEmitter);

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var SIPMessage = __webpack_require__(19);

        var Utils = __webpack_require__(8);

        var RequestSender = __webpack_require__(24);

        var Exceptions = __webpack_require__(7);

        var logger = new Logger('Options');

        module.exports = /*#__PURE__*/function (_EventEmitter) {
          _inherits(Options, _EventEmitter);

          var _super = _createSuper(Options);

          function Options(ua) {
            var _this;

            _classCallCheck(this, Options);

            _this = _super.call(this);
            _this._ua = ua;
            _this._request = null;
            _this._closed = false;
            _this._direction = null;
            _this._local_identity = null;
            _this._remote_identity = null; // Whether an incoming message has been replied.

            _this._is_replied = false; // Custom message empty object for high level use.

            _this._data = {};
            return _this;
          }

          _createClass(Options, [{
            key: "send",
            value: function send(target, body) {
              var _this2 = this;

              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
              var originalTarget = target;

              if (target === undefined) {
                throw new TypeError('A target is required for OPTIONS');
              } // Check target validity.


              target = this._ua.normalizeTarget(target);

              if (!target) {
                throw new TypeError("Invalid target: ".concat(originalTarget));
              } // Get call options.


              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var eventHandlers = Utils.cloneObject(options.eventHandlers);
              var contentType = options.contentType || 'application/sdp'; // Set event handlers.

              for (var event in eventHandlers) {
                if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {
                  this.on(event, eventHandlers[event]);
                }
              }

              extraHeaders.push("Content-Type: ".concat(contentType));
              this._request = new SIPMessage.OutgoingRequest(JsSIP_C.OPTIONS, target, this._ua, null, extraHeaders);

              if (body) {
                this._request.body = body;
              }

              var request_sender = new RequestSender(this._ua, this._request, {
                onRequestTimeout: function onRequestTimeout() {
                  _this2._onRequestTimeout();
                },
                onTransportError: function onTransportError() {
                  _this2._onTransportError();
                },
                onReceiveResponse: function onReceiveResponse(response) {
                  _this2._receiveResponse(response);
                }
              });

              this._newOptions('local', this._request);

              request_sender.send();
            }
          }, {
            key: "init_incoming",
            value: function init_incoming(request) {
              this._request = request;

              this._newOptions('remote', request); // Reply with a 200 OK if the user didn't reply.


              if (!this._is_replied) {
                this._is_replied = true;
                request.reply(200);
              }

              this._close();
            }
            /**
             * Accept the incoming Options
             * Only valid for incoming Options
             */

          }, {
            key: "accept",
            value: function accept() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var body = options.body;

              if (this._direction !== 'incoming') {
                throw new Exceptions.NotSupportedError('"accept" not supported for outgoing Options');
              }

              if (this._is_replied) {
                throw new Error('incoming Options already replied');
              }

              this._is_replied = true;

              this._request.reply(200, null, extraHeaders, body);
            }
            /**
             * Reject the incoming Options
             * Only valid for incoming Options
             */

          }, {
            key: "reject",
            value: function reject() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              var status_code = options.status_code || 480;
              var reason_phrase = options.reason_phrase;
              var extraHeaders = Utils.cloneArray(options.extraHeaders);
              var body = options.body;

              if (this._direction !== 'incoming') {
                throw new Exceptions.NotSupportedError('"reject" not supported for outgoing Options');
              }

              if (this._is_replied) {
                throw new Error('incoming Options already replied');
              }

              if (status_code < 300 || status_code >= 700) {
                throw new TypeError("Invalid status_code: ".concat(status_code));
              }

              this._is_replied = true;

              this._request.reply(status_code, reason_phrase, extraHeaders, body);
            }
          }, {
            key: "_receiveResponse",
            value: function _receiveResponse(response) {
              if (this._closed) {
                return;
              }

              switch (true) {
                case /^1[0-9]{2}$/.test(response.status_code):
                  // Ignore provisional responses.
                  break;

                case /^2[0-9]{2}$/.test(response.status_code):
                  this._succeeded('remote', response);

                  break;

                default:
                  {
                    var cause = Utils.sipErrorCause(response.status_code);

                    this._failed('remote', response, cause);

                    break;
                  }
              }
            }
          }, {
            key: "_onRequestTimeout",
            value: function _onRequestTimeout() {
              if (this._closed) {
                return;
              }

              this._failed('system', null, JsSIP_C.causes.REQUEST_TIMEOUT);
            }
          }, {
            key: "_onTransportError",
            value: function _onTransportError() {
              if (this._closed) {
                return;
              }

              this._failed('system', null, JsSIP_C.causes.CONNECTION_ERROR);
            }
          }, {
            key: "_close",
            value: function _close() {
              this._closed = true;

              this._ua.destroyMessage(this);
            }
            /**
             * Internal Callbacks
             */

          }, {
            key: "_newOptions",
            value: function _newOptions(originator, request) {
              if (originator === 'remote') {
                this._direction = 'incoming';
                this._local_identity = request.to;
                this._remote_identity = request.from;
              } else if (originator === 'local') {
                this._direction = 'outgoing';
                this._local_identity = request.from;
                this._remote_identity = request.to;
              }

              this._ua.newOptions(this, {
                originator: originator,
                message: this,
                request: request
              });
            }
          }, {
            key: "_failed",
            value: function _failed(originator, response, cause) {
              logger.debug('OPTIONS failed');

              this._close();

              logger.debug('emit "failed"');
              this.emit('failed', {
                originator: originator,
                response: response || null,
                cause: cause
              });
            }
          }, {
            key: "_succeeded",
            value: function _succeeded(originator, response) {
              logger.debug('OPTIONS succeeded');

              this._close();

              logger.debug('emit "succeeded"');
              this.emit('succeeded', {
                originator: originator,
                response: response
              });
            }
          }, {
            key: "direction",
            get: function get() {
              return this._direction;
            }
          }, {
            key: "local_identity",
            get: function get() {
              return this._local_identity;
            }
          }, {
            key: "remote_identity",
            get: function get() {
              return this._remote_identity;
            }
          }]);

          return Options;
        }(EventEmitter);

        /***/
      }),
/* 37 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var Socket = __webpack_require__(38);

        var JsSIP_C = __webpack_require__(6);

        var logger = new Logger('Transport');
        /**
         * Constants
         */

        var C = {
          // Transport status.
          STATUS_CONNECTED: 0,
          STATUS_CONNECTING: 1,
          STATUS_DISCONNECTED: 2,
          // Socket status.
          SOCKET_STATUS_READY: 0,
          SOCKET_STATUS_ERROR: 1,
          // Recovery options.
          recovery_options: {
            // minimum interval in seconds between recover attempts.
            min_interval: JsSIP_C.CONNECTION_RECOVERY_MIN_INTERVAL,
            // maximum interval in seconds between recover attempts.
            max_interval: JsSIP_C.CONNECTION_RECOVERY_MAX_INTERVAL
          }
        };
        /*
         * Manages one or multiple JsSIP.Socket instances.
         * Is reponsible for transport recovery logic among all socket instances.
         *
         * @socket JsSIP::Socket instance
         */

        module.exports = /*#__PURE__*/function () {
          function Transport(sockets) {
            var recovery_options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : C.recovery_options;

            _classCallCheck(this, Transport);

            logger.debug('new()');
            this.status = C.STATUS_DISCONNECTED; // Current socket.

            this.socket = null; // Socket collection.

            this.sockets = [];
            this.recovery_options = recovery_options;
            this.recover_attempts = 0;
            this.recovery_timer = null;
            this.close_requested = false; // It seems that TextDecoder is not available in some versions of React-Native.
            // See https://github.com/versatica/JsSIP/issues/695

            try {
              this.textDecoder = new TextDecoder('utf8');
            } catch (error) {
              logger.warn("cannot use TextDecoder: ".concat(error));
            }

            if (typeof sockets === 'undefined') {
              throw new TypeError('Invalid argument.' + ' undefined \'sockets\' argument');
            }

            if (!(sockets instanceof Array)) {
              sockets = [sockets];
            }

            sockets.forEach(function (socket) {
              if (!Socket.isSocket(socket.socket)) {
                throw new TypeError('Invalid argument.' + ' invalid \'JsSIP.Socket\' instance');
              }

              if (socket.weight && !Number(socket.weight)) {
                throw new TypeError('Invalid argument.' + ' \'weight\' attribute is not a number');
              }

              this.sockets.push({
                socket: socket.socket,
                weight: socket.weight || 0,
                status: C.SOCKET_STATUS_READY
              });
            }, this); // Get the socket with higher weight.

            this._getSocket();
          }
          /**
           * Instance Methods
           */


          _createClass(Transport, [{
            key: "connect",
            value: function connect() {
              logger.debug('connect()');

              if (this.isConnected()) {
                logger.debug('Transport is already connected');
                return;
              } else if (this.isConnecting()) {
                logger.debug('Transport is connecting');
                return;
              }

              this.close_requested = false;
              this.status = C.STATUS_CONNECTING;
              this.onconnecting({
                socket: this.socket,
                attempts: this.recover_attempts
              });

              if (!this.close_requested) {
                // Bind socket event callbacks.
                this.socket.onconnect = this._onConnect.bind(this);
                this.socket.ondisconnect = this._onDisconnect.bind(this);
                this.socket.ondata = this._onData.bind(this);
                this.socket.connect();
              }

              return;
            }
          }, {
            key: "disconnect",
            value: function disconnect() {
              logger.debug('close()');
              this.close_requested = true;
              this.recover_attempts = 0;
              this.status = C.STATUS_DISCONNECTED; // Clear recovery_timer.

              if (this.recovery_timer !== null) {
                clearTimeout(this.recovery_timer);
                this.recovery_timer = null;
              } // Unbind socket event callbacks.


              this.socket.onconnect = function () { };

              this.socket.ondisconnect = function () { };

              this.socket.ondata = function () { };

              this.socket.disconnect();
              this.ondisconnect({
                socket: this.socket,
                error: false
              });
            }
          }, {
            key: "send",
            value: function send(data) {
              logger.debug('send()');

              if (!this.isConnected()) {
                logger.warn('unable to send message, transport is not connected');
                return false;
              }

              var message = data.toString();
              logger.debug("sending message:\n\n".concat(message, "\n"));
              return this.socket.send(message);
            }
          }, {
            key: "isConnected",
            value: function isConnected() {
              return this.status === C.STATUS_CONNECTED;
            }
          }, {
            key: "isConnecting",
            value: function isConnecting() {
              return this.status === C.STATUS_CONNECTING;
            }
            /**
             * Private API.
             */

          }, {
            key: "_reconnect",
            value: function _reconnect() {
              var _this = this;

              this.recover_attempts += 1;
              var k = Math.floor(Math.random() * Math.pow(2, this.recover_attempts) + 1);

              if (k < this.recovery_options.min_interval) {
                k = this.recovery_options.min_interval;
              } else if (k > this.recovery_options.max_interval) {
                k = this.recovery_options.max_interval;
              }

              logger.debug("reconnection attempt: ".concat(this.recover_attempts, ". next connection attempt in ").concat(k, " seconds"));
              this.recovery_timer = setTimeout(function () {
                if (!_this.close_requested && !(_this.isConnected() || _this.isConnecting())) {
                  // Get the next available socket with higher weight.
                  _this._getSocket(); // Connect the socket.


                  _this.connect();
                }
              }, k * 1000);
            }
            /**
             * get the next available socket with higher weight
             */

          }, {
            key: "_getSocket",
            value: function _getSocket() {
              var candidates = [];
              this.sockets.forEach(function (socket) {
                if (socket.status === C.SOCKET_STATUS_ERROR) {
                  return; // continue the array iteration
                } else if (candidates.length === 0) {
                  candidates.push(socket);
                } else if (socket.weight > candidates[0].weight) {
                  candidates = [socket];
                } else if (socket.weight === candidates[0].weight) {
                  candidates.push(socket);
                }
              });

              if (candidates.length === 0) {
                // All sockets have failed. reset sockets status.
                this.sockets.forEach(function (socket) {
                  socket.status = C.SOCKET_STATUS_READY;
                }); // Get next available socket.

                this._getSocket();

                return;
              }

              var idx = Math.floor(Math.random() * candidates.length);
              this.socket = candidates[idx].socket;
            }
            /**
             * Socket Event Handlers
             */

          }, {
            key: "_onConnect",
            value: function _onConnect() {
              this.recover_attempts = 0;
              this.status = C.STATUS_CONNECTED; // Clear recovery_timer.

              if (this.recovery_timer !== null) {
                clearTimeout(this.recovery_timer);
                this.recovery_timer = null;
              }

              this.onconnect({
                socket: this
              });
            }
          }, {
            key: "_onDisconnect",
            value: function _onDisconnect(error, code, reason) {
              this.status = C.STATUS_DISCONNECTED;
              this.ondisconnect({
                socket: this.socket,
                error: error,
                code: code,
                reason: reason
              });

              if (this.close_requested) {
                return;
              } // Update socket status.
              else {
                this.sockets.forEach(function (socket) {
                  if (this.socket === socket.socket) {
                    socket.status = C.SOCKET_STATUS_ERROR;
                  }
                }, this);
              }

              this._reconnect(error);
            }
          }, {
            key: "_onData",
            value: function _onData(data) {
              // CRLF Keep Alive response from server. Ignore it.
              if (data === '\r\n') {
                logger.debug('received message with CRLF Keep Alive response');
                return;
              } // Binary message.
              else if (typeof data !== 'string') {
                try {
                  if (this.textDecoder) data = this.textDecoder.decode(data); else data = String.fromCharCode.apply(null, new Uint8Array(data));
                } catch (evt) {
                  logger.debug('received binary message failed to be converted into string,' + ' message discarded');
                  return;
                }

                logger.debug("received binary message:\n\n".concat(data, "\n"));
              } // Text message.
              else {
                logger.debug("received text message:\n\n".concat(data, "\n"));
              }

              this.ondata({
                transport: this,
                message: data
              });
            }
          }, {
            key: "via_transport",
            get: function get() {
              return this.socket.via_transport;
            }
          }, {
            key: "url",
            get: function get() {
              return this.socket.url;
            }
          }, {
            key: "sip_uri",
            get: function get() {
              return this.socket.sip_uri;
            }
          }]);

          return Transport;
        }();

        /***/
      }),
/* 38 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";


        var Logger = __webpack_require__(14);

        var Utils = __webpack_require__(8);

        var Grammar = __webpack_require__(10);

        var logger = new Logger('Socket');
        /**
         * Interface documentation: https://jssip.net/documentation/$last_version/api/socket/
         *
         * interface Socket {
         *  attribute String via_transport
         *  attribute String url
         *  attribute String sip_uri
         *
         *  method connect();
         *  method disconnect();
         *  method send(data);
         *
         *  attribute EventHandler onconnect
         *  attribute EventHandler ondisconnect
         *  attribute EventHandler ondata
         * }
         *
         */

        exports.isSocket = function (socket) {
          // Ignore if an array is given.
          if (Array.isArray(socket)) {
            return false;
          }

          if (typeof socket === 'undefined') {
            logger.warn('undefined JsSIP.Socket instance');
            return false;
          } // Check Properties.


          try {
            if (!Utils.isString(socket.url)) {
              logger.warn('missing or invalid JsSIP.Socket url property');
              throw new Error('Missing or invalid JsSIP.Socket url property');
            }

            if (!Utils.isString(socket.via_transport)) {
              logger.warn('missing or invalid JsSIP.Socket via_transport property');
              throw new Error('Missing or invalid JsSIP.Socket via_transport property');
            }

            if (Grammar.parse(socket.sip_uri, 'SIP_URI') === -1) {
              logger.warn('missing or invalid JsSIP.Socket sip_uri property');
              throw new Error('missing or invalid JsSIP.Socket sip_uri property');
            }
          } catch (e) {
            return false;
          } // Check Methods.


          try {
            ['connect', 'disconnect', 'send'].forEach(function (method) {
              if (!Utils.isFunction(socket[method])) {
                logger.warn("missing or invalid JsSIP.Socket method: ".concat(method));
                throw new Error("Missing or invalid JsSIP.Socket method: ".concat(method));
              }
            });
          } catch (e) {
            return false;
          }

          return true;
        };

        /***/
      }),
/* 39 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";


        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        var Logger = __webpack_require__(14);

        var Grammar = __webpack_require__(10);

        var SIPMessage = __webpack_require__(19);

        var logger = new Logger('Parser');
        /**
         * Parse SIP Message
         */

        exports.parseMessage = function (data, ua) {
          var message;
          var bodyStart;
          var headerEnd = data.indexOf('\r\n');

          if (headerEnd === -1) {
            logger.warn('parseMessage() | no CRLF found, not a SIP message');
            return;
          } // Parse first line. Check if it is a Request or a Reply.


          var firstLine = data.substring(0, headerEnd);
          var parsed = Grammar.parse(firstLine, 'Request_Response');

          if (parsed === -1) {
            logger.warn("parseMessage() | error parsing first line of SIP message: \"".concat(firstLine, "\""));
            return;
          } else if (!parsed.status_code) {
            message = new SIPMessage.IncomingRequest(ua);
            message.method = parsed.method;
            message.ruri = parsed.uri;
          } else {
            message = new SIPMessage.IncomingResponse();
            message.status_code = parsed.status_code;
            message.reason_phrase = parsed.reason_phrase;
          }

          message.data = data;
          var headerStart = headerEnd + 2;
          /* Loop over every line in data. Detect the end of each header and parse
          * it or simply add to the headers collection.
          */

          while (true) {
            headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.

            if (headerEnd === -2) {
              bodyStart = headerStart + 2;
              break;
            } // Data.indexOf returned -1 due to a malformed message.
            else if (headerEnd === -1) {
              logger.warn('parseMessage() | malformed message');
              return;
            }

            parsed = parseHeader(message, data, headerStart, headerEnd);

            if (parsed !== true) {
              logger.warn('parseMessage() |', parsed.error);
              return;
            }

            headerStart = headerEnd + 2;
          }
          /* RFC3261 18.3.
           * If there are additional bytes in the transport packet
           * beyond the end of the body, they MUST be discarded.
           */


          if (message.hasHeader('content-length')) {
            var contentLength = message.getHeader('content-length');
            message.body = data.substr(bodyStart, contentLength);
          } else {
            message.body = data.substring(bodyStart);
          }

          return message;
        };
        /**
         * Extract and parse every header of a SIP message.
         */


        function getHeader(data, headerStart) {
          // 'start' position of the header.
          var start = headerStart; // 'end' position of the header.

          var end = 0; // 'partial end' position of the header.

          var partialEnd = 0; // End of message.

          if (data.substring(start, start + 2).match(/(^\r\n)/)) {
            return -2;
          }

          while (end === 0) {
            // Partial End of Header.
            partialEnd = data.indexOf('\r\n', start); // 'indexOf' returns -1 if the value to be found never occurs.

            if (partialEnd === -1) {
              return partialEnd;
            }

            if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
              // Not the end of the message. Continue from the next position.
              start = partialEnd + 2;
            } else {
              end = partialEnd;
            }
          }

          return end;
        }

        function parseHeader(message, data, headerStart, headerEnd) {
          var parsed;
          var hcolonIndex = data.indexOf(':', headerStart);
          var headerName = data.substring(headerStart, hcolonIndex).trim();
          var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // If header-field is well-known, parse it.

          switch (headerName.toLowerCase()) {
            case 'via':
            case 'v':
              message.addHeader('via', headerValue);

              if (message.getHeaders('via').length === 1) {
                parsed = message.parseHeader('Via');

                if (parsed) {
                  message.via = parsed;
                  message.via_branch = parsed.branch;
                }
              } else {
                parsed = 0;
              }

              break;

            case 'from':
            case 'f':
              message.setHeader('from', headerValue);
              parsed = message.parseHeader('from');

              if (parsed) {
                message.from = parsed;
                message.from_tag = parsed.getParam('tag');
              }

              break;

            case 'to':
            case 't':
              message.setHeader('to', headerValue);
              parsed = message.parseHeader('to');

              if (parsed) {
                message.to = parsed;
                message.to_tag = parsed.getParam('tag');
              }

              break;

            case 'record-route':
              parsed = Grammar.parse(headerValue, 'Record_Route');

              if (parsed === -1) {
                parsed = undefined;
              } else {
                var _iterator = _createForOfIteratorHelper(parsed),
                  _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var header = _step.value;
                    message.addHeader('record-route', headerValue.substring(header.possition, header.offset));
                    message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              }

              break;

            case 'call-id':
            case 'i':
              message.setHeader('call-id', headerValue);
              parsed = message.parseHeader('call-id');

              if (parsed) {
                message.call_id = headerValue;
              }

              break;

            case 'contact':
            case 'm':
              parsed = Grammar.parse(headerValue, 'Contact');

              if (parsed === -1) {
                parsed = undefined;
              } else {
                var _iterator2 = _createForOfIteratorHelper(parsed),
                  _step2;

                try {
                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                    var _header = _step2.value;
                    message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));
                    message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;
                  }
                } catch (err) {
                  _iterator2.e(err);
                } finally {
                  _iterator2.f();
                }
              }

              break;

            case 'content-length':
            case 'l':
              message.setHeader('content-length', headerValue);
              parsed = message.parseHeader('content-length');
              break;

            case 'content-type':
            case 'c':
              message.setHeader('content-type', headerValue);
              parsed = message.parseHeader('content-type');
              break;

            case 'cseq':
              message.setHeader('cseq', headerValue);
              parsed = message.parseHeader('cseq');

              if (parsed) {
                message.cseq = parsed.value;
              }

              if (message instanceof SIPMessage.IncomingResponse) {
                message.method = parsed.method;
              }

              break;

            case 'max-forwards':
              message.setHeader('max-forwards', headerValue);
              parsed = message.parseHeader('max-forwards');
              break;

            case 'www-authenticate':
              message.setHeader('www-authenticate', headerValue);
              parsed = message.parseHeader('www-authenticate');
              break;

            case 'proxy-authenticate':
              message.setHeader('proxy-authenticate', headerValue);
              parsed = message.parseHeader('proxy-authenticate');
              break;

            case 'session-expires':
            case 'x':
              message.setHeader('session-expires', headerValue);
              parsed = message.parseHeader('session-expires');

              if (parsed) {
                message.session_expires = parsed.expires;
                message.session_expires_refresher = parsed.refresher;
              }

              break;

            case 'refer-to':
            case 'r':
              message.setHeader('refer-to', headerValue);
              parsed = message.parseHeader('refer-to');

              if (parsed) {
                message.refer_to = parsed;
              }

              break;

            case 'replaces':
              message.setHeader('replaces', headerValue);
              parsed = message.parseHeader('replaces');

              if (parsed) {
                message.replaces = parsed;
              }

              break;

            case 'event':
            case 'o':
              message.setHeader('event', headerValue);
              parsed = message.parseHeader('event');

              if (parsed) {
                message.event = parsed;
              }

              break;

            default:
              // Do not parse this header.
              message.addHeader(headerName, headerValue);
              parsed = 0;
          }

          if (parsed === undefined) {
            return {
              error: "error parsing header \"".concat(headerName, "\"")
            };
          } else {
            return true;
          }
        }

        /***/
      }),
/* 40 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        var Logger = __webpack_require__(14);

        var JsSIP_C = __webpack_require__(6);

        var SIPMessage = __webpack_require__(19);

        var Utils = __webpack_require__(8);

        var logger = new Logger('sanityCheck'); // Checks for requests and responses.

        var all = [minimumHeaders]; // Checks for requests.

        var requests = [rfc3261_8_2_2_1, rfc3261_16_3_4, rfc3261_18_3_request, rfc3261_8_2_2_2]; // Checks for responses.

        var responses = [rfc3261_8_1_3_3, rfc3261_18_3_response]; // local variables.

        var message;
        var ua;
        var transport;

        module.exports = function (m, u, t) {
          message = m;
          ua = u;
          transport = t;

          var _iterator = _createForOfIteratorHelper(all),
            _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _check2 = _step.value;

              if (_check2() === false) {
                return false;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (message instanceof SIPMessage.IncomingRequest) {
            var _iterator2 = _createForOfIteratorHelper(requests),
              _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var check = _step2.value;

                if (check() === false) {
                  return false;
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          } else if (message instanceof SIPMessage.IncomingResponse) {
            var _iterator3 = _createForOfIteratorHelper(responses),
              _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _check = _step3.value;

                if (_check() === false) {
                  return false;
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } // Everything is OK.


          return true;
        };
        /*
         * Sanity Check for incoming Messages
         *
         * Requests:
         *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
         *  - _rfc3261_16_3_4_ Receive a Request already sent by us
         *   Does not look at via sent-by but at jssip_id, which is inserted as
         *   a prefix in all initial requests generated by the ua
         *  - _rfc3261_18_3_request_ Body Content-Length
         *  - _rfc3261_8_2_2_2_ Merged Requests
         *
         * Responses:
         *  - _rfc3261_8_1_3_3_ Multiple Via headers
         *  - _rfc3261_18_3_response_ Body Content-Length
         *
         * All:
         *  - Minimum headers in a SIP message
         */
        // Sanity Check functions for requests.


        function rfc3261_8_2_2_1() {
          if (message.s('to').uri.scheme !== 'sip') {
            reply(416);
            return false;
          }
        }

        function rfc3261_16_3_4() {
          if (!message.to_tag) {
            if (message.call_id.substr(0, 5) === ua.configuration.jssip_id) {
              reply(482);
              return false;
            }
          }
        }

        function rfc3261_18_3_request() {
          var len = Utils.str_utf8_length(message.body);
          var contentLength = message.getHeader('content-length');

          if (len < contentLength) {
            reply(400);
            return false;
          }
        }

        function rfc3261_8_2_2_2() {
          var fromTag = message.from_tag;
          var call_id = message.call_id;
          var cseq = message.cseq;
          var tr; // Accept any in-dialog request.

          if (message.to_tag) {
            return;
          } // INVITE request.


          if (message.method === JsSIP_C.INVITE) {
            // If the branch matches the key of any IST then assume it is a retransmission
            // and ignore the INVITE.
            // TODO: we should reply the last response.
            if (ua._transactions.ist[message.via_branch]) {
              return false;
            } // Otherwise check whether it is a merged request.
            else {
              for (var transaction in ua._transactions.ist) {
                if (Object.prototype.hasOwnProperty.call(ua._transactions.ist, transaction)) {
                  tr = ua._transactions.ist[transaction];

                  if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
                    reply(482);
                    return false;
                  }
                }
              }
            }
          } // Non INVITE request.
          // If the branch matches the key of any NIST then assume it is a retransmission
          // and ignore the request.
          // TODO: we should reply the last response.
          else if (ua._transactions.nist[message.via_branch]) {
            return false;
          } // Otherwise check whether it is a merged request.
          else {
            for (var _transaction in ua._transactions.nist) {
              if (Object.prototype.hasOwnProperty.call(ua._transactions.nist, _transaction)) {
                tr = ua._transactions.nist[_transaction];

                if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
                  reply(482);
                  return false;
                }
              }
            }
          }
        } // Sanity Check functions for responses.


        function rfc3261_8_1_3_3() {
          if (message.getHeaders('via').length > 1) {
            logger.debug('more than one Via header field present in the response, dropping the response');
            return false;
          }
        }

        function rfc3261_18_3_response() {
          var len = Utils.str_utf8_length(message.body),
            contentLength = message.getHeader('content-length');

          if (len < contentLength) {
            logger.debug('message body length is lower than the value in Content-Length header field, dropping the response');
            return false;
          }
        } // Sanity Check functions for requests and responses.


        function minimumHeaders() {
          var mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'];

          for (var _i = 0, _mandatoryHeaders = mandatoryHeaders; _i < _mandatoryHeaders.length; _i++) {
            var header = _mandatoryHeaders[_i];

            if (!message.hasHeader(header)) {
              logger.debug("missing mandatory header field : ".concat(header, ", dropping the response"));
              return false;
            }
          }
        } // Reply.


        function reply(status_code) {
          var vias = message.getHeaders('via');
          var to;
          var response = "SIP/2.0 ".concat(status_code, " ").concat(JsSIP_C.REASON_PHRASE[status_code], "\r\n");

          var _iterator4 = _createForOfIteratorHelper(vias),
            _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var via = _step4.value;
              response += "Via: ".concat(via, "\r\n");
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          to = message.getHeader('To');

          if (!message.to_tag) {
            to += ";tag=".concat(Utils.newTag());
          }

          response += "To: ".concat(to, "\r\n");
          response += "From: ".concat(message.getHeader('From'), "\r\n");
          response += "Call-ID: ".concat(message.call_id, "\r\n");
          response += "CSeq: ".concat(message.cseq, " ").concat(message.method, "\r\n");
          response += '\r\n';
          transport.send(response);
        }

        /***/
      }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";


        function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

        function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

        function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

        var Utils = __webpack_require__(8);

        var JsSIP_C = __webpack_require__(6);

        var Grammar = __webpack_require__(10);

        var URI = __webpack_require__(9);

        var Socket = __webpack_require__(38);

        var Exceptions = __webpack_require__(7); // Default settings.


        exports.settings = {
          // SIP authentication.
          authorization_user: null,
          password: null,
          realm: null,
          ha1: null,
          authorization_jwt: null,
          // SIP account.
          display_name: null,
          uri: null,
          contact_uri: null,
          // SIP instance id (GRUU).
          instance_id: null,
          // Preloaded SIP Route header field.
          use_preloaded_route: false,
          // Session parameters.
          session_timers: true,
          session_timers_refresh_method: JsSIP_C.UPDATE,
          session_timers_force_refresher: false,
          no_answer_timeout: 60,
          // Registration parameters.
          register: true,
          register_expires: 600,
          registrar_server: null,
          // Connection options.
          sockets: null,
          connection_recovery_max_interval: JsSIP_C.CONNECTION_RECOVERY_MAX_INTERVAL,
          connection_recovery_min_interval: JsSIP_C.CONNECTION_RECOVERY_MIN_INTERVAL,

          /*
           * Host address.
           * Value to be set in Via sent_by and host part of Contact FQDN.
          */
          via_host: "".concat(Utils.createRandomToken(12), ".invalid")
        }; // Configuration checks.

        var checks = {
          mandatory: {
            sockets: function sockets(_sockets2) {
              /* Allow defining sockets parameter as:
               *  Socket: socket
               *  Array of Socket: [socket1, socket2]
               *  Array of Objects: [{socket: socket1, weight:1}, {socket: Socket2, weight:0}]
               *  Array of Objects and Socket: [{socket: socket1}, socket2]
               */
              var _sockets = [];

              if (Socket.isSocket(_sockets2)) {
                _sockets.push({
                  socket: _sockets2
                });
              } else if (Array.isArray(_sockets2) && _sockets2.length) {
                var _iterator = _createForOfIteratorHelper(_sockets2),
                  _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var socket = _step.value;

                    if (Object.prototype.hasOwnProperty.call(socket, 'socket') && Socket.isSocket(socket.socket)) {
                      _sockets.push(socket);
                    } else if (Socket.isSocket(socket)) {
                      _sockets.push({
                        socket: socket
                      });
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              } else {
                return;
              }

              return _sockets;
            },
            uri: function uri(_uri) {
              if (!/^sip:/i.test(_uri)) {
                _uri = "".concat(JsSIP_C.SIP, ":").concat(_uri);
              }

              var parsed = URI.parse(_uri);

              if (!parsed) {
                return;
              } else if (!parsed.user) {
                return;
              } else {
                return parsed;
              }
            }
          },
          optional: {
            authorization_user: function authorization_user(_authorization_user) {
              if (Grammar.parse("\"".concat(_authorization_user, "\""), 'quoted_string') === -1) {
                return;
              } else {
                return _authorization_user;
              }
            },
            authorization_jwt: function authorization_jwt(_authorization_jwt) {
              if (typeof _authorization_jwt === 'string') {
                return _authorization_jwt;
              }
            },
            user_agent: function user_agent(_user_agent) {
              if (typeof _user_agent === 'string') {
                return _user_agent;
              }
            },
            connection_recovery_max_interval: function connection_recovery_max_interval(_connection_recovery_max_interval) {
              if (Utils.isDecimal(_connection_recovery_max_interval)) {
                var value = Number(_connection_recovery_max_interval);

                if (value > 0) {
                  return value;
                }
              }
            },
            connection_recovery_min_interval: function connection_recovery_min_interval(_connection_recovery_min_interval) {
              if (Utils.isDecimal(_connection_recovery_min_interval)) {
                var value = Number(_connection_recovery_min_interval);

                if (value > 0) {
                  return value;
                }
              }
            },
            contact_uri: function contact_uri(_contact_uri) {
              if (typeof _contact_uri === 'string') {
                var uri = Grammar.parse(_contact_uri, 'SIP_URI');

                if (uri !== -1) {
                  return uri;
                }
              }
            },
            display_name: function display_name(_display_name) {
              return _display_name;
            },
            instance_id: function instance_id(_instance_id) {
              if (/^uuid:/i.test(_instance_id)) {
                _instance_id = _instance_id.substr(5);
              }

              if (Grammar.parse(_instance_id, 'uuid') === -1) {
                return;
              } else {
                return _instance_id;
              }
            },
            no_answer_timeout: function no_answer_timeout(_no_answer_timeout) {
              if (Utils.isDecimal(_no_answer_timeout)) {
                var value = Number(_no_answer_timeout);

                if (value > 0) {
                  return value;
                }
              }
            },
            session_timers: function session_timers(_session_timers) {
              if (typeof _session_timers === 'boolean') {
                return _session_timers;
              }
            },
            session_timers_refresh_method: function session_timers_refresh_method(method) {
              if (typeof method === 'string') {
                method = method.toUpperCase();

                if (method === JsSIP_C.INVITE || method === JsSIP_C.UPDATE) {
                  return method;
                }
              }
            },
            session_timers_force_refresher: function session_timers_force_refresher(_session_timers_force_refresher) {
              if (typeof _session_timers_force_refresher === 'boolean') {
                return _session_timers_force_refresher;
              }
            },
            password: function password(_password) {
              return String(_password);
            },
            realm: function realm(_realm) {
              return String(_realm);
            },
            ha1: function ha1(_ha) {
              return String(_ha);
            },
            register: function register(_register) {
              if (typeof _register === 'boolean') {
                return _register;
              }
            },
            register_expires: function register_expires(_register_expires) {
              if (Utils.isDecimal(_register_expires)) {
                var value = Number(_register_expires);

                if (value > 0) {
                  return value;
                }
              }
            },
            registrar_server: function registrar_server(_registrar_server) {
              if (!/^sip:/i.test(_registrar_server)) {
                _registrar_server = "".concat(JsSIP_C.SIP, ":").concat(_registrar_server);
              }

              var parsed = URI.parse(_registrar_server);

              if (!parsed) {
                return;
              } else if (parsed.user) {
                return;
              } else {
                return parsed;
              }
            },
            use_preloaded_route: function use_preloaded_route(_use_preloaded_route) {
              if (typeof _use_preloaded_route === 'boolean') {
                return _use_preloaded_route;
              }
            }
          }
        };

        exports.load = function (dst, src) {
          // Check Mandatory parameters.
          for (var parameter in checks.mandatory) {
            if (!src.hasOwnProperty(parameter)) {
              throw new Exceptions.ConfigurationError(parameter);
            } else {
              var value = src[parameter];
              var checked_value = checks.mandatory[parameter](value);

              if (checked_value !== undefined) {
                dst[parameter] = checked_value;
              } else {
                throw new Exceptions.ConfigurationError(parameter, value);
              }
            }
          } // Check Optional parameters.


          for (var _parameter in checks.optional) {
            if (src.hasOwnProperty(_parameter)) {
              var _value = src[_parameter];
              /* If the parameter value is null, empty string, undefined, empty array
               * or it's a number with NaN value, then apply its default value.
               */

              if (Utils.isEmpty(_value)) {
                continue;
              }

              var _checked_value = checks.optional[_parameter](_value);

              if (_checked_value !== undefined) {
                dst[_parameter] = _checked_value;
              } else {
                throw new Exceptions.ConfigurationError(_parameter, _value);
              }
            }
          }
        };

        /***/
      }),
/* 42 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";


        function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

        function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

        function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

        var Logger = __webpack_require__(14);

        var Grammar = __webpack_require__(10);

        var logger = new Logger('WebSocketInterface');

        module.exports = /*#__PURE__*/function () {
          function WebSocketInterface(url) {
            _classCallCheck(this, WebSocketInterface);

            logger.debug('new() [url:"%s"]', url);
            this._url = url;
            this._sip_uri = null;
            this._via_transport = null;
            this._ws = null;
            var parsed_url = Grammar.parse(url, 'absoluteURI');

            if (parsed_url === -1) {
              logger.warn("invalid WebSocket URI: ".concat(url));
              throw new TypeError("Invalid argument: ".concat(url));
            } else if (parsed_url.scheme !== 'wss' && parsed_url.scheme !== 'ws') {
              logger.warn("invalid WebSocket URI scheme: ".concat(parsed_url.scheme));
              throw new TypeError("Invalid argument: ".concat(url));
            } else {
              this._sip_uri = "sip:".concat(parsed_url.host).concat(parsed_url.port ? ":".concat(parsed_url.port) : '', ";transport=ws");
              this._via_transport = parsed_url.scheme.toUpperCase();
            }
          }

          _createClass(WebSocketInterface, [{
            key: "connect",
            value: function connect() {
              logger.debug('connect()');

              if (this.isConnected()) {
                logger.debug("WebSocket ".concat(this._url, " is already connected"));
                return;
              } else if (this.isConnecting()) {
                logger.debug("WebSocket ".concat(this._url, " is connecting"));
                return;
              }

              if (this._ws) {
                this.disconnect();
              }

              logger.debug("connecting to WebSocket ".concat(this._url));

              try {
                this._ws = new WebSocket(this._url, 'sip');
                this._ws.binaryType = 'arraybuffer';
                this._ws.onopen = this._onOpen.bind(this);
                this._ws.onclose = this._onClose.bind(this);
                this._ws.onmessage = this._onMessage.bind(this);
                this._ws.onerror = this._onError.bind(this);
              } catch (e) {
                this._onError(e);
              }
            }
          }, {
            key: "disconnect",
            value: function disconnect() {
              logger.debug('disconnect()');

              if (this._ws) {
                // Unbind websocket event callbacks.
                this._ws.onopen = function () { };

                this._ws.onclose = function () { };

                this._ws.onmessage = function () { };

                this._ws.onerror = function () { };

                this._ws.close();

                this._ws = null;
              }
            }
          }, {
            key: "send",
            value: function send(message) {
              logger.debug('send()');

              if (this.isConnected()) {
                this._ws.send(message);

                return true;
              } else {
                logger.warn('unable to send message, WebSocket is not open');
                return false;
              }
            }
          }, {
            key: "isConnected",
            value: function isConnected() {
              return this._ws && this._ws.readyState === this._ws.OPEN;
            }
          }, {
            key: "isConnecting",
            value: function isConnecting() {
              return this._ws && this._ws.readyState === this._ws.CONNECTING;
            }
            /**
             * WebSocket Event Handlers
             */

          }, {
            key: "_onOpen",
            value: function _onOpen() {
              logger.debug("WebSocket ".concat(this._url, " connected"));
              this.onconnect();
            }
          }, {
            key: "_onClose",
            value: function _onClose(_ref) {
              var wasClean = _ref.wasClean,
                code = _ref.code,
                reason = _ref.reason;
              logger.debug("WebSocket ".concat(this._url, " closed"));

              if (wasClean === false) {
                logger.debug('WebSocket abrupt disconnection');
              }

              this.ondisconnect(!wasClean, code, reason);
            }
          }, {
            key: "_onMessage",
            value: function _onMessage(_ref2) {
              var data = _ref2.data;
              logger.debug('received WebSocket message');
              this.ondata(data);
            }
          }, {
            key: "_onError",
            value: function _onError(e) {
              logger.warn("WebSocket ".concat(this._url, " error: "), e);
            }
          }, {
            key: "via_transport",
            get: function get() {
              return this._via_transport;
            },
            set: function set(value) {
              this._via_transport = value.toUpperCase();
            }
          }, {
            key: "sip_uri",
            get: function get() {
              return this._sip_uri;
            }
          }, {
            key: "url",
            get: function get() {
              return this._url;
            }
          }]);

          return WebSocketInterface;
        }();

        /***/
      }),
/* 43 */
/***/ ((__unused_webpack_module, exports) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.LIBRARY_VERSION = void 0;
        exports.LIBRARY_VERSION = '2.0.101247';


        /***/
      }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
          /* harmony export */
        });
/* harmony import */ var _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */





        const adapter =
          (0, _adapter_factory_js__WEBPACK_IMPORTED_MODULE_0__.adapterFactory)({ window: typeof window === 'undefined' ? undefined : window });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (adapter);


        /***/
      }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "adapterFactory": () => (/* binding */ adapterFactory)
          /* harmony export */
        });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);
/* harmony import */ var _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53);
/* harmony import */ var _common_shim__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54);
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(55);
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_5__);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */


        // Browser shims.






        // Shimming starts here.
        function adapterFactory({ window } = {}, options = {
          shimChrome: true,
          shimFirefox: true,
          shimSafari: true,
        }) {
          // Utils.
          const logging = _utils__WEBPACK_IMPORTED_MODULE_0__.log;
          const browserDetails = _utils__WEBPACK_IMPORTED_MODULE_0__.detectBrowser(window);

          const adapter = {
            browserDetails,
            commonShim: _common_shim__WEBPACK_IMPORTED_MODULE_4__,
            extractVersion: _utils__WEBPACK_IMPORTED_MODULE_0__.extractVersion,
            disableLog: _utils__WEBPACK_IMPORTED_MODULE_0__.disableLog,
            disableWarnings: _utils__WEBPACK_IMPORTED_MODULE_0__.disableWarnings,
            // Expose sdp as a convenience. For production apps include directly.
            sdp: sdp__WEBPACK_IMPORTED_MODULE_5__,
          };

          // Shim browser if found.
          switch (browserDetails.browser) {
            case 'chrome':
              if (!_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__ || !_chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection ||
                !options.shimChrome) {
                logging('Chrome shim is not included in this adapter release.');
                return adapter;
              }
              if (browserDetails.version === null) {
                logging('Chrome shim can not determine version, not shimming.');
                return adapter;
              }
              logging('adapter.js shimming chrome.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__;

              // Must be called before shimPeerConnection.
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimMediaStream(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimPeerConnection(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimOnTrack(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimAddTrackRemoveTrack(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetSendersWithDtmf(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimGetStats(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.shimSenderReceiverGetStats(window, browserDetails);
              _chrome_chrome_shim__WEBPACK_IMPORTED_MODULE_1__.fixNegotiationNeeded(window, browserDetails);

              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);
              break;
            case 'firefox':
              if (!_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__ || !_firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection ||
                !options.shimFirefox) {
                logging('Firefox shim is not included in this adapter release.');
                return adapter;
              }
              logging('adapter.js shimming firefox.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__;

              // Must be called before shimPeerConnection.
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetUserMedia(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimPeerConnection(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimOnTrack(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRemoveStream(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimSenderGetStats(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimReceiverGetStats(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimRTCDataChannel(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimAddTransceiver(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimGetParameters(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateOffer(window, browserDetails);
              _firefox_firefox_shim__WEBPACK_IMPORTED_MODULE_2__.shimCreateAnswer(window, browserDetails);

              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimConnectionState(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
              break;
            case 'safari':
              if (!_safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__ || !options.shimSafari) {
                logging('Safari shim is not included in this adapter release.');
                return adapter;
              }
              logging('adapter.js shimming safari.');
              // Export to the adapter global object visible in the browser.
              adapter.browserShim = _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__;

              // Must be called before shimCallbackAPI.
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimAddIceCandidateNullOrEmpty(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimParameterlessSetLocalDescription(window, browserDetails);

              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRTCIceServerUrls(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCreateOfferLegacy(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimCallbacksAPI(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimLocalStreamsAPI(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimRemoteStreamsAPI(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimTrackEventTransceiver(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimGetUserMedia(window, browserDetails);
              _safari_safari_shim__WEBPACK_IMPORTED_MODULE_3__.shimAudioContext(window, browserDetails);

              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimRTCIceCandidate(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimMaxMessageSize(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.shimSendThrowTypeError(window, browserDetails);
              _common_shim__WEBPACK_IMPORTED_MODULE_4__.removeExtmapAllowMixed(window, browserDetails);
              break;
            default:
              logging('Unsupported browser!');
              break;
          }

          return adapter;
        }


        /***/
      }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compactObject": () => (/* binding */ compactObject),
/* harmony export */   "deprecated": () => (/* binding */ deprecated),
/* harmony export */   "detectBrowser": () => (/* binding */ detectBrowser),
/* harmony export */   "disableLog": () => (/* binding */ disableLog),
/* harmony export */   "disableWarnings": () => (/* binding */ disableWarnings),
/* harmony export */   "extractVersion": () => (/* binding */ extractVersion),
/* harmony export */   "filterStats": () => (/* binding */ filterStats),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "walkStats": () => (/* binding */ walkStats),
/* harmony export */   "wrapPeerConnectionEvent": () => (/* binding */ wrapPeerConnectionEvent)
          /* harmony export */
        });
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        let logDisabled_ = true;
        let deprecationWarnings_ = true;

        /**
         * Extract browser version out of the provided user agent string.
         *
         * @param {!string} uastring userAgent string.
         * @param {!string} expr Regular expression used as match criteria.
         * @param {!number} pos position in the version string to be returned.
         * @return {!number} browser version.
         */
        function extractVersion(uastring, expr, pos) {
          const match = uastring.match(expr);
          return match && match.length >= pos && parseInt(match[pos], 10);
        }

        // Wraps the peerconnection event eventNameToWrap in a function
        // which returns the modified event object (or false to prevent
        // the event).
        function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
          if (!window.RTCPeerConnection) {
            return;
          }
          const proto = window.RTCPeerConnection.prototype;
          const nativeAddEventListener = proto.addEventListener;
          proto.addEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap) {
              return nativeAddEventListener.apply(this, arguments);
            }
            const wrappedCallback = (e) => {
              const modifiedEvent = wrapper(e);
              if (modifiedEvent) {
                if (cb.handleEvent) {
                  cb.handleEvent(modifiedEvent);
                } else {
                  cb(modifiedEvent);
                }
              }
            };
            this._eventMap = this._eventMap || {};
            if (!this._eventMap[eventNameToWrap]) {
              this._eventMap[eventNameToWrap] = new Map();
            }
            this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
            return nativeAddEventListener.apply(this, [nativeEventName,
              wrappedCallback]);
          };

          const nativeRemoveEventListener = proto.removeEventListener;
          proto.removeEventListener = function (nativeEventName, cb) {
            if (nativeEventName !== eventNameToWrap || !this._eventMap
              || !this._eventMap[eventNameToWrap]) {
              return nativeRemoveEventListener.apply(this, arguments);
            }
            if (!this._eventMap[eventNameToWrap].has(cb)) {
              return nativeRemoveEventListener.apply(this, arguments);
            }
            const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
            this._eventMap[eventNameToWrap].delete(cb);
            if (this._eventMap[eventNameToWrap].size === 0) {
              delete this._eventMap[eventNameToWrap];
            }
            if (Object.keys(this._eventMap).length === 0) {
              delete this._eventMap;
            }
            return nativeRemoveEventListener.apply(this, [nativeEventName,
              unwrappedCb]);
          };

          Object.defineProperty(proto, 'on' + eventNameToWrap, {
            get() {
              return this['_on' + eventNameToWrap];
            },
            set(cb) {
              if (this['_on' + eventNameToWrap]) {
                this.removeEventListener(eventNameToWrap,
                  this['_on' + eventNameToWrap]);
                delete this['_on' + eventNameToWrap];
              }
              if (cb) {
                this.addEventListener(eventNameToWrap,
                  this['_on' + eventNameToWrap] = cb);
              }
            },
            enumerable: true,
            configurable: true
          });
        }

        function disableLog(bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + typeof bool +
              '. Please use a boolean.');
          }
          logDisabled_ = bool;
          return (bool) ? 'adapter.js logging disabled' :
            'adapter.js logging enabled';
        }

        /**
         * Disable or enable deprecation warnings
         * @param {!boolean} bool set to true to disable warnings.
         */
        function disableWarnings(bool) {
          if (typeof bool !== 'boolean') {
            return new Error('Argument type: ' + typeof bool +
              '. Please use a boolean.');
          }
          deprecationWarnings_ = !bool;
          return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
        }

        function log() {
          if (typeof window === 'object') {
            if (logDisabled_) {
              return;
            }
            if (typeof console !== 'undefined' && typeof console.log === 'function') {
              console.log.apply(console, arguments);
            }
          }
        }

        /**
         * Shows a deprecation warning suggesting the modern and spec-compatible API.
         */
        function deprecated(oldMethod, newMethod) {
          if (!deprecationWarnings_) {
            return;
          }
          console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
            ' instead.');
        }

        /**
         * Browser detector.
         *
         * @return {object} result containing browser and version
         *     properties.
         */
        function detectBrowser(window) {
          // Returned result object.
          const result = { browser: null, version: null };

          // Fail early if it's not a browser
          if (typeof window === 'undefined' || !window.navigator) {
            result.browser = 'Not a browser.';
            return result;
          }

          const { navigator } = window;

          if (navigator.mozGetUserMedia) { // Firefox.
            result.browser = 'firefox';
            result.version = extractVersion(navigator.userAgent,
              /Firefox\/(\d+)\./, 1);
          } else if (navigator.webkitGetUserMedia ||
            (window.isSecureContext === false && window.webkitRTCPeerConnection &&
              !window.RTCIceGatherer)) {
            // Chrome, Chromium, Webview, Opera.
            // Version matches Chrome/WebRTC version.
            // Chrome 74 removed webkitGetUserMedia on http as well so we need the
            // more complicated fallback to webkitRTCPeerConnection.
            result.browser = 'chrome';
            result.version = extractVersion(navigator.userAgent,
              /Chrom(e|ium)\/(\d+)\./, 2);
          } else if (window.RTCPeerConnection &&
            navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
            result.browser = 'safari';
            result.version = extractVersion(navigator.userAgent,
              /AppleWebKit\/(\d+)\./, 1);
            result.supportsUnifiedPlan = window.RTCRtpTransceiver &&
              'currentDirection' in window.RTCRtpTransceiver.prototype;
          } else { // Default fallthrough: not supported.
            result.browser = 'Not a supported browser.';
            return result;
          }

          return result;
        }

        /**
         * Checks if something is an object.
         *
         * @param {*} val The something you want to check.
         * @return true if val is an object, false otherwise.
         */
        function isObject(val) {
          return Object.prototype.toString.call(val) === '[object Object]';
        }

        /**
         * Remove all empty objects and undefined values
         * from a nested object -- an enhanced and vanilla version
         * of Lodash's `compact`.
         */
        function compactObject(data) {
          if (!isObject(data)) {
            return data;
          }

          return Object.keys(data).reduce(function (accumulator, key) {
            const isObj = isObject(data[key]);
            const value = isObj ? compactObject(data[key]) : data[key];
            const isEmptyObject = isObj && !Object.keys(value).length;
            if (value === undefined || isEmptyObject) {
              return accumulator;
            }
            return Object.assign(accumulator, { [key]: value });
          }, {});
        }

        /* iterates the stats graph recursively. */
        function walkStats(stats, base, resultSet) {
          if (!base || resultSet.has(base.id)) {
            return;
          }
          resultSet.set(base.id, base);
          Object.keys(base).forEach(name => {
            if (name.endsWith('Id')) {
              walkStats(stats, stats.get(base[name]), resultSet);
            } else if (name.endsWith('Ids')) {
              base[name].forEach(id => {
                walkStats(stats, stats.get(id), resultSet);
              });
            }
          });
        }

        /* filter getStats for a sender/receiver track. */
        function filterStats(result, track, outbound) {
          const streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
          const filteredResult = new Map();
          if (track === null) {
            return filteredResult;
          }
          const trackStats = [];
          result.forEach(value => {
            if (value.type === 'track' &&
              value.trackIdentifier === track.id) {
              trackStats.push(value);
            }
          });
          trackStats.forEach(trackStat => {
            result.forEach(stats => {
              if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
                walkStats(result, stats, filteredResult);
              }
            });
          });
          return filteredResult;
        }



        /***/
      }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fixNegotiationNeeded": () => (/* binding */ fixNegotiationNeeded),
/* harmony export */   "shimAddTrackRemoveTrack": () => (/* binding */ shimAddTrackRemoveTrack),
/* harmony export */   "shimAddTrackRemoveTrackWithNative": () => (/* binding */ shimAddTrackRemoveTrackWithNative),
/* harmony export */   "shimGetDisplayMedia": () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),
/* harmony export */   "shimGetSendersWithDtmf": () => (/* binding */ shimGetSendersWithDtmf),
/* harmony export */   "shimGetStats": () => (/* binding */ shimGetStats),
/* harmony export */   "shimGetUserMedia": () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),
/* harmony export */   "shimMediaStream": () => (/* binding */ shimMediaStream),
/* harmony export */   "shimOnTrack": () => (/* binding */ shimOnTrack),
/* harmony export */   "shimPeerConnection": () => (/* binding */ shimPeerConnection),
/* harmony export */   "shimSenderReceiverGetStats": () => (/* binding */ shimSenderReceiverGetStats)
          /* harmony export */
        });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */






        function shimMediaStream(window) {
          window.MediaStream = window.MediaStream || window.webkitMediaStream;
        }

        function shimOnTrack(window) {
          if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
            window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
              get() {
                return this._ontrack;
              },
              set(f) {
                if (this._ontrack) {
                  this.removeEventListener('track', this._ontrack);
                }
                this.addEventListener('track', this._ontrack = f);
              },
              enumerable: true,
              configurable: true
            });
            const origSetRemoteDescription =
              window.RTCPeerConnection.prototype.setRemoteDescription;
            window.RTCPeerConnection.prototype.setRemoteDescription =
              function setRemoteDescription() {
                if (!this._ontrackpoly) {
                  this._ontrackpoly = (e) => {
                    // onaddstream does not fire when a track is added to an existing
                    // stream. But stream.onaddtrack is implemented so we use that.
                    e.stream.addEventListener('addtrack', te => {
                      let receiver;
                      if (window.RTCPeerConnection.prototype.getReceivers) {
                        receiver = this.getReceivers()
                          .find(r => r.track && r.track.id === te.track.id);
                      } else {
                        receiver = { track: te.track };
                      }

                      const event = new Event('track');
                      event.track = te.track;
                      event.receiver = receiver;
                      event.transceiver = { receiver };
                      event.streams = [e.stream];
                      this.dispatchEvent(event);
                    });
                    e.stream.getTracks().forEach(track => {
                      let receiver;
                      if (window.RTCPeerConnection.prototype.getReceivers) {
                        receiver = this.getReceivers()
                          .find(r => r.track && r.track.id === track.id);
                      } else {
                        receiver = { track };
                      }
                      const event = new Event('track');
                      event.track = track;
                      event.receiver = receiver;
                      event.transceiver = { receiver };
                      event.streams = [e.stream];
                      this.dispatchEvent(event);
                    });
                  };
                  this.addEventListener('addstream', this._ontrackpoly);
                }
                return origSetRemoteDescription.apply(this, arguments);
              };
          } else {
            // even if RTCRtpTransceiver is in window, it is only used and
            // emitted in unified-plan. Unfortunately this means we need
            // to unconditionally wrap the event.
            _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
              if (!e.transceiver) {
                Object.defineProperty(e, 'transceiver',
                  { value: { receiver: e.receiver } });
              }
              return e;
            });
          }
        }

        function shimGetSendersWithDtmf(window) {
          // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
          if (typeof window === 'object' && window.RTCPeerConnection &&
            !('getSenders' in window.RTCPeerConnection.prototype) &&
            'createDTMFSender' in window.RTCPeerConnection.prototype) {
            const shimSenderWithDtmf = function (pc, track) {
              return {
                track,
                get dtmf() {
                  if (this._dtmf === undefined) {
                    if (track.kind === 'audio') {
                      this._dtmf = pc.createDTMFSender(track);
                    } else {
                      this._dtmf = null;
                    }
                  }
                  return this._dtmf;
                },
                _pc: pc
              };
            };

            // augment addTrack when getSenders is not available.
            if (!window.RTCPeerConnection.prototype.getSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                this._senders = this._senders || [];
                return this._senders.slice(); // return a copy of the internal state.
              };
              const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
              window.RTCPeerConnection.prototype.addTrack =
                function addTrack(track, stream) {
                  let sender = origAddTrack.apply(this, arguments);
                  if (!sender) {
                    sender = shimSenderWithDtmf(this, track);
                    this._senders.push(sender);
                  }
                  return sender;
                };

              const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
              window.RTCPeerConnection.prototype.removeTrack =
                function removeTrack(sender) {
                  origRemoveTrack.apply(this, arguments);
                  const idx = this._senders.indexOf(sender);
                  if (idx !== -1) {
                    this._senders.splice(idx, 1);
                  }
                };
            }
            const origAddStream = window.RTCPeerConnection.prototype.addStream;
            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              this._senders = this._senders || [];
              origAddStream.apply(this, [stream]);
              stream.getTracks().forEach(track => {
                this._senders.push(shimSenderWithDtmf(this, track));
              });
            };

            const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
            window.RTCPeerConnection.prototype.removeStream =
              function removeStream(stream) {
                this._senders = this._senders || [];
                origRemoveStream.apply(this, [stream]);

                stream.getTracks().forEach(track => {
                  const sender = this._senders.find(s => s.track === track);
                  if (sender) { // remove sender
                    this._senders.splice(this._senders.indexOf(sender), 1);
                  }
                });
              };
          } else if (typeof window === 'object' && window.RTCPeerConnection &&
            'getSenders' in window.RTCPeerConnection.prototype &&
            'createDTMFSender' in window.RTCPeerConnection.prototype &&
            window.RTCRtpSender &&
            !('dtmf' in window.RTCRtpSender.prototype)) {
            const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              const senders = origGetSenders.apply(this, []);
              senders.forEach(sender => sender._pc = this);
              return senders;
            };

            Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
              get() {
                if (this._dtmf === undefined) {
                  if (this.track.kind === 'audio') {
                    this._dtmf = this._pc.createDTMFSender(this.track);
                  } else {
                    this._dtmf = null;
                  }
                }
                return this._dtmf;
              }
            });
          }
        }

        function shimGetStats(window) {
          if (!window.RTCPeerConnection) {
            return;
          }

          const origGetStats = window.RTCPeerConnection.prototype.getStats;
          window.RTCPeerConnection.prototype.getStats = function getStats() {
            const [selector, onSucc, onErr] = arguments;

            // If selector is a function then we are in the old style stats so just
            // pass back the original getStats format to avoid breaking old users.
            if (arguments.length > 0 && typeof selector === 'function') {
              return origGetStats.apply(this, arguments);
            }

            // When spec-style getStats is supported, return those when called with
            // either no arguments or the selector argument is null.
            if (origGetStats.length === 0 && (arguments.length === 0 ||
              typeof selector !== 'function')) {
              return origGetStats.apply(this, []);
            }

            const fixChromeStats_ = function (response) {
              const standardReport = {};
              const reports = response.result();
              reports.forEach(report => {
                const standardStats = {
                  id: report.id,
                  timestamp: report.timestamp,
                  type: {
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate'
                  }[report.type] || report.type
                };
                report.names().forEach(name => {
                  standardStats[name] = report.stat(name);
                });
                standardReport[standardStats.id] = standardStats;
              });

              return standardReport;
            };

            // shim getStats with maplike support
            const makeMapStats = function (stats) {
              return new Map(Object.keys(stats).map(key => [key, stats[key]]));
            };

            if (arguments.length >= 2) {
              const successCallbackWrapper_ = function (response) {
                onSucc(makeMapStats(fixChromeStats_(response)));
              };

              return origGetStats.apply(this, [successCallbackWrapper_,
                selector]);
            }

            // promise-support
            return new Promise((resolve, reject) => {
              origGetStats.apply(this, [
                function (response) {
                  resolve(makeMapStats(fixChromeStats_(response)));
                }, reject]);
            }).then(onSucc, onErr);
          };
        }

        function shimSenderReceiverGetStats(window) {
          if (!(typeof window === 'object' && window.RTCPeerConnection &&
            window.RTCRtpSender && window.RTCRtpReceiver)) {
            return;
          }

          // shim sender stats.
          if (!('getStats' in window.RTCRtpSender.prototype)) {
            const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
            if (origGetSenders) {
              window.RTCPeerConnection.prototype.getSenders = function getSenders() {
                const senders = origGetSenders.apply(this, []);
                senders.forEach(sender => sender._pc = this);
                return senders;
              };
            }

            const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
            if (origAddTrack) {
              window.RTCPeerConnection.prototype.addTrack = function addTrack() {
                const sender = origAddTrack.apply(this, arguments);
                sender._pc = this;
                return sender;
              };
            }
            window.RTCRtpSender.prototype.getStats = function getStats() {
              const sender = this;
              return this._pc.getStats().then(result =>
                /* Note: this will include stats of all senders that
                 *   send a track with the same id as sender.track as
                 *   it is not possible to identify the RTCRtpSender.
                 */
                _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, sender.track, true));
            };
          }

          // shim receiver stats.
          if (!('getStats' in window.RTCRtpReceiver.prototype)) {
            const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
            if (origGetReceivers) {
              window.RTCPeerConnection.prototype.getReceivers =
                function getReceivers() {
                  const receivers = origGetReceivers.apply(this, []);
                  receivers.forEach(receiver => receiver._pc = this);
                  return receivers;
                };
            }
            _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
              e.receiver._pc = e.srcElement;
              return e;
            });
            window.RTCRtpReceiver.prototype.getStats = function getStats() {
              const receiver = this;
              return this._pc.getStats().then(result =>
                _utils_js__WEBPACK_IMPORTED_MODULE_0__.filterStats(result, receiver.track, false));
            };
          }

          if (!('getStats' in window.RTCRtpSender.prototype &&
            'getStats' in window.RTCRtpReceiver.prototype)) {
            return;
          }

          // shim RTCPeerConnection.getStats(track).
          const origGetStats = window.RTCPeerConnection.prototype.getStats;
          window.RTCPeerConnection.prototype.getStats = function getStats() {
            if (arguments.length > 0 &&
              arguments[0] instanceof window.MediaStreamTrack) {
              const track = arguments[0];
              let sender;
              let receiver;
              let err;
              this.getSenders().forEach(s => {
                if (s.track === track) {
                  if (sender) {
                    err = true;
                  } else {
                    sender = s;
                  }
                }
              });
              this.getReceivers().forEach(r => {
                if (r.track === track) {
                  if (receiver) {
                    err = true;
                  } else {
                    receiver = r;
                  }
                }
                return r.track === track;
              });
              if (err || (sender && receiver)) {
                return Promise.reject(new DOMException(
                  'There are more than one sender or receiver for the track.',
                  'InvalidAccessError'));
              } else if (sender) {
                return sender.getStats();
              } else if (receiver) {
                return receiver.getStats();
              }
              return Promise.reject(new DOMException(
                'There is no sender or receiver for the track.',
                'InvalidAccessError'));
            }
            return origGetStats.apply(this, arguments);
          };
        }

        function shimAddTrackRemoveTrackWithNative(window) {
          // shim addTrack/removeTrack with native variants in order to make
          // the interactions with legacy getLocalStreams behave as in other browsers.
          // Keeps a mapping stream.id => [stream, rtpsenders...]
          window.RTCPeerConnection.prototype.getLocalStreams =
            function getLocalStreams() {
              this._shimmedLocalStreams = this._shimmedLocalStreams || {};
              return Object.keys(this._shimmedLocalStreams)
                .map(streamId => this._shimmedLocalStreams[streamId][0]);
            };

          const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          window.RTCPeerConnection.prototype.addTrack =
            function addTrack(track, stream) {
              if (!stream) {
                return origAddTrack.apply(this, arguments);
              }
              this._shimmedLocalStreams = this._shimmedLocalStreams || {};

              const sender = origAddTrack.apply(this, arguments);
              if (!this._shimmedLocalStreams[stream.id]) {
                this._shimmedLocalStreams[stream.id] = [stream, sender];
              } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
                this._shimmedLocalStreams[stream.id].push(sender);
              }
              return sender;
            };

          const origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            this._shimmedLocalStreams = this._shimmedLocalStreams || {};

            stream.getTracks().forEach(track => {
              const alreadyExists = this.getSenders().find(s => s.track === track);
              if (alreadyExists) {
                throw new DOMException('Track already exists.',
                  'InvalidAccessError');
              }
            });
            const existingSenders = this.getSenders();
            origAddStream.apply(this, arguments);
            const newSenders = this.getSenders()
              .filter(newSender => existingSenders.indexOf(newSender) === -1);
            this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
          };

          const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream =
            function removeStream(stream) {
              this._shimmedLocalStreams = this._shimmedLocalStreams || {};
              delete this._shimmedLocalStreams[stream.id];
              return origRemoveStream.apply(this, arguments);
            };

          const origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
          window.RTCPeerConnection.prototype.removeTrack =
            function removeTrack(sender) {
              this._shimmedLocalStreams = this._shimmedLocalStreams || {};
              if (sender) {
                Object.keys(this._shimmedLocalStreams).forEach(streamId => {
                  const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
                  if (idx !== -1) {
                    this._shimmedLocalStreams[streamId].splice(idx, 1);
                  }
                  if (this._shimmedLocalStreams[streamId].length === 1) {
                    delete this._shimmedLocalStreams[streamId];
                  }
                });
              }
              return origRemoveTrack.apply(this, arguments);
            };
        }

        function shimAddTrackRemoveTrack(window, browserDetails) {
          if (!window.RTCPeerConnection) {
            return;
          }
          // shim addTrack and removeTrack.
          if (window.RTCPeerConnection.prototype.addTrack &&
            browserDetails.version >= 65) {
            return shimAddTrackRemoveTrackWithNative(window);
          }

          // also shim pc.getLocalStreams when addTrack is shimmed
          // to return the original streams.
          const origGetLocalStreams = window.RTCPeerConnection.prototype
            .getLocalStreams;
          window.RTCPeerConnection.prototype.getLocalStreams =
            function getLocalStreams() {
              const nativeStreams = origGetLocalStreams.apply(this);
              this._reverseStreams = this._reverseStreams || {};
              return nativeStreams.map(stream => this._reverseStreams[stream.id]);
            };

          const origAddStream = window.RTCPeerConnection.prototype.addStream;
          window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
            this._streams = this._streams || {};
            this._reverseStreams = this._reverseStreams || {};

            stream.getTracks().forEach(track => {
              const alreadyExists = this.getSenders().find(s => s.track === track);
              if (alreadyExists) {
                throw new DOMException('Track already exists.',
                  'InvalidAccessError');
              }
            });
            // Add identity mapping for consistency with addTrack.
            // Unless this is being used with a stream from addTrack.
            if (!this._reverseStreams[stream.id]) {
              const newStream = new window.MediaStream(stream.getTracks());
              this._streams[stream.id] = newStream;
              this._reverseStreams[newStream.id] = stream;
              stream = newStream;
            }
            origAddStream.apply(this, [stream]);
          };

          const origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
          window.RTCPeerConnection.prototype.removeStream =
            function removeStream(stream) {
              this._streams = this._streams || {};
              this._reverseStreams = this._reverseStreams || {};

              origRemoveStream.apply(this, [(this._streams[stream.id] || stream)]);
              delete this._reverseStreams[(this._streams[stream.id] ?
                this._streams[stream.id].id : stream.id)];
              delete this._streams[stream.id];
            };

          window.RTCPeerConnection.prototype.addTrack =
            function addTrack(track, stream) {
              if (this.signalingState === 'closed') {
                throw new DOMException(
                  'The RTCPeerConnection\'s signalingState is \'closed\'.',
                  'InvalidStateError');
              }
              const streams = [].slice.call(arguments, 1);
              if (streams.length !== 1 ||
                !streams[0].getTracks().find(t => t === track)) {
                // this is not fully correct but all we can manage without
                // [[associated MediaStreams]] internal slot.
                throw new DOMException(
                  'The adapter.js addTrack polyfill only supports a single ' +
                  ' stream which is associated with the specified track.',
                  'NotSupportedError');
              }

              const alreadyExists = this.getSenders().find(s => s.track === track);
              if (alreadyExists) {
                throw new DOMException('Track already exists.',
                  'InvalidAccessError');
              }

              this._streams = this._streams || {};
              this._reverseStreams = this._reverseStreams || {};
              const oldStream = this._streams[stream.id];
              if (oldStream) {
                // this is using odd Chrome behaviour, use with caution:
                // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
                // Note: we rely on the high-level addTrack/dtmf shim to
                // create the sender with a dtmf sender.
                oldStream.addTrack(track);

                // Trigger ONN async.
                Promise.resolve().then(() => {
                  this.dispatchEvent(new Event('negotiationneeded'));
                });
              } else {
                const newStream = new window.MediaStream([track]);
                this._streams[stream.id] = newStream;
                this._reverseStreams[newStream.id] = stream;
                this.addStream(newStream);
              }
              return this.getSenders().find(s => s.track === track);
            };

          // replace the internal stream id with the external one and
          // vice versa.
          function replaceInternalStreamId(pc, description) {
            let sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(internalId => {
              const externalStream = pc._reverseStreams[internalId];
              const internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
                externalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp
            });
          }
          function replaceExternalStreamId(pc, description) {
            let sdp = description.sdp;
            Object.keys(pc._reverseStreams || []).forEach(internalId => {
              const externalStream = pc._reverseStreams[internalId];
              const internalStream = pc._streams[externalStream.id];
              sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
                internalStream.id);
            });
            return new RTCSessionDescription({
              type: description.type,
              sdp
            });
          }
          ['createOffer', 'createAnswer'].forEach(function (method) {
            const nativeMethod = window.RTCPeerConnection.prototype[method];
            const methodObj = {
              [method]() {
                const args = arguments;
                const isLegacyCall = arguments.length &&
                  typeof arguments[0] === 'function';
                if (isLegacyCall) {
                  return nativeMethod.apply(this, [
                    (description) => {
                      const desc = replaceInternalStreamId(this, description);
                      args[0].apply(null, [desc]);
                    },
                    (err) => {
                      if (args[1]) {
                        args[1].apply(null, err);
                      }
                    }, arguments[2]
                  ]);
                }
                return nativeMethod.apply(this, arguments)
                  .then(description => replaceInternalStreamId(this, description));
              }
            };
            window.RTCPeerConnection.prototype[method] = methodObj[method];
          });

          const origSetLocalDescription =
            window.RTCPeerConnection.prototype.setLocalDescription;
          window.RTCPeerConnection.prototype.setLocalDescription =
            function setLocalDescription() {
              if (!arguments.length || !arguments[0].type) {
                return origSetLocalDescription.apply(this, arguments);
              }
              arguments[0] = replaceExternalStreamId(this, arguments[0]);
              return origSetLocalDescription.apply(this, arguments);
            };

          // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

          const origLocalDescription = Object.getOwnPropertyDescriptor(
            window.RTCPeerConnection.prototype, 'localDescription');
          Object.defineProperty(window.RTCPeerConnection.prototype,
            'localDescription', {
            get() {
              const description = origLocalDescription.get.apply(this);
              if (description.type === '') {
                return description;
              }
              return replaceInternalStreamId(this, description);
            }
          });

          window.RTCPeerConnection.prototype.removeTrack =
            function removeTrack(sender) {
              if (this.signalingState === 'closed') {
                throw new DOMException(
                  'The RTCPeerConnection\'s signalingState is \'closed\'.',
                  'InvalidStateError');
              }
              // We can not yet check for sender instanceof RTCRtpSender
              // since we shim RTPSender. So we check if sender._pc is set.
              if (!sender._pc) {
                throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
                  'does not implement interface RTCRtpSender.', 'TypeError');
              }
              const isLocal = sender._pc === this;
              if (!isLocal) {
                throw new DOMException('Sender was not created by this connection.',
                  'InvalidAccessError');
              }

              // Search for the native stream the senders track belongs to.
              this._streams = this._streams || {};
              let stream;
              Object.keys(this._streams).forEach(streamid => {
                const hasTrack = this._streams[streamid].getTracks()
                  .find(track => sender.track === track);
                if (hasTrack) {
                  stream = this._streams[streamid];
                }
              });

              if (stream) {
                if (stream.getTracks().length === 1) {
                  // if this is the last track of the stream, remove the stream. This
                  // takes care of any shimmed _senders.
                  this.removeStream(this._reverseStreams[stream.id]);
                } else {
                  // relying on the same odd chrome behaviour as above.
                  stream.removeTrack(sender.track);
                }
                this.dispatchEvent(new Event('negotiationneeded'));
              }
            };
        }

        function shimPeerConnection(window, browserDetails) {
          if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.webkitRTCPeerConnection;
          }
          if (!window.RTCPeerConnection) {
            return;
          }

          // shim implicit creation of RTCSessionDescription/RTCIceCandidate
          if (browserDetails.version < 53) {
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
              .forEach(function (method) {
                const nativeMethod = window.RTCPeerConnection.prototype[method];
                const methodObj = {
                  [method]() {
                    arguments[0] = new ((method === 'addIceCandidate') ?
                      window.RTCIceCandidate :
                      window.RTCSessionDescription)(arguments[0]);
                    return nativeMethod.apply(this, arguments);
                  }
                };
                window.RTCPeerConnection.prototype[method] = methodObj[method];
              });
          }
        }

        // Attempt to fix ONN in plan-b mode.
        function fixNegotiationNeeded(window, browserDetails) {
          _utils_js__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'negotiationneeded', e => {
            const pc = e.target;
            if (browserDetails.version < 72 || (pc.getConfiguration &&
              pc.getConfiguration().sdpSemantics === 'plan-b')) {
              if (pc.signalingState !== 'stable') {
                return;
              }
            }
            return e;
          });
        }


        /***/
      }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetUserMedia": () => (/* binding */ shimGetUserMedia)
          /* harmony export */
        });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        const logging = _utils_js__WEBPACK_IMPORTED_MODULE_0__.log;

        function shimGetUserMedia(window, browserDetails) {
          const navigator = window && window.navigator;

          if (!navigator.mediaDevices) {
            return;
          }

          const constraintsToChrome_ = function (c) {
            if (typeof c !== 'object' || c.mandatory || c.optional) {
              return c;
            }
            const cc = {};
            Object.keys(c).forEach(key => {
              if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
                return;
              }
              const r = (typeof c[key] === 'object') ? c[key] : { ideal: c[key] };
              if (r.exact !== undefined && typeof r.exact === 'number') {
                r.min = r.max = r.exact;
              }
              const oldname_ = function (prefix, name) {
                if (prefix) {
                  return prefix + name.charAt(0).toUpperCase() + name.slice(1);
                }
                return (name === 'deviceId') ? 'sourceId' : name;
              };
              if (r.ideal !== undefined) {
                cc.optional = cc.optional || [];
                let oc = {};
                if (typeof r.ideal === 'number') {
                  oc[oldname_('min', key)] = r.ideal;
                  cc.optional.push(oc);
                  oc = {};
                  oc[oldname_('max', key)] = r.ideal;
                  cc.optional.push(oc);
                } else {
                  oc[oldname_('', key)] = r.ideal;
                  cc.optional.push(oc);
                }
              }
              if (r.exact !== undefined && typeof r.exact !== 'number') {
                cc.mandatory = cc.mandatory || {};
                cc.mandatory[oldname_('', key)] = r.exact;
              } else {
                ['min', 'max'].forEach(mix => {
                  if (r[mix] !== undefined) {
                    cc.mandatory = cc.mandatory || {};
                    cc.mandatory[oldname_(mix, key)] = r[mix];
                  }
                });
              }
            });
            if (c.advanced) {
              cc.optional = (cc.optional || []).concat(c.advanced);
            }
            return cc;
          };

          const shimConstraints_ = function (constraints, func) {
            if (browserDetails.version >= 61) {
              return func(constraints);
            }
            constraints = JSON.parse(JSON.stringify(constraints));
            if (constraints && typeof constraints.audio === 'object') {
              const remap = function (obj, a, b) {
                if (a in obj && !(b in obj)) {
                  obj[b] = obj[a];
                  delete obj[a];
                }
              };
              constraints = JSON.parse(JSON.stringify(constraints));
              remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
              remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
              constraints.audio = constraintsToChrome_(constraints.audio);
            }
            if (constraints && typeof constraints.video === 'object') {
              // Shim facingMode for mobile & surface pro.
              let face = constraints.video.facingMode;
              face = face && ((typeof face === 'object') ? face : { ideal: face });
              const getSupportedFacingModeLies = browserDetails.version < 66;

              if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                face.ideal === 'user' || face.ideal === 'environment')) &&
                !(navigator.mediaDevices.getSupportedConstraints &&
                  navigator.mediaDevices.getSupportedConstraints().facingMode &&
                  !getSupportedFacingModeLies)) {
                delete constraints.video.facingMode;
                let matches;
                if (face.exact === 'environment' || face.ideal === 'environment') {
                  matches = ['back', 'rear'];
                } else if (face.exact === 'user' || face.ideal === 'user') {
                  matches = ['front'];
                }
                if (matches) {
                  // Look for matches in label, or use last cam for back (typical).
                  return navigator.mediaDevices.enumerateDevices()
                    .then(devices => {
                      devices = devices.filter(d => d.kind === 'videoinput');
                      let dev = devices.find(d => matches.some(match =>
                        d.label.toLowerCase().includes(match)));
                      if (!dev && devices.length && matches.includes('back')) {
                        dev = devices[devices.length - 1]; // more likely the back cam
                      }
                      if (dev) {
                        constraints.video.deviceId = face.exact ? { exact: dev.deviceId } :
                          { ideal: dev.deviceId };
                      }
                      constraints.video = constraintsToChrome_(constraints.video);
                      logging('chrome: ' + JSON.stringify(constraints));
                      return func(constraints);
                    });
                }
              }
              constraints.video = constraintsToChrome_(constraints.video);
            }
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          };

          const shimError_ = function (e) {
            if (browserDetails.version >= 64) {
              return e;
            }
            return {
              name: {
                PermissionDeniedError: 'NotAllowedError',
                PermissionDismissedError: 'NotAllowedError',
                InvalidStateError: 'NotAllowedError',
                DevicesNotFoundError: 'NotFoundError',
                ConstraintNotSatisfiedError: 'OverconstrainedError',
                TrackStartError: 'NotReadableError',
                MediaDeviceFailedDueToShutdown: 'NotAllowedError',
                MediaDeviceKillSwitchOn: 'NotAllowedError',
                TabCaptureError: 'AbortError',
                ScreenCaptureError: 'AbortError',
                DeviceCaptureError: 'AbortError'
              }[e.name] || e.name,
              message: e.message,
              constraint: e.constraint || e.constraintName,
              toString() {
                return this.name + (this.message && ': ') + this.message;
              }
            };
          };

          const getUserMedia_ = function (constraints, onSuccess, onError) {
            shimConstraints_(constraints, c => {
              navigator.webkitGetUserMedia(c, onSuccess, e => {
                if (onError) {
                  onError(shimError_(e));
                }
              });
            });
          };
          navigator.getUserMedia = getUserMedia_.bind(navigator);

          // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
          // function which returns a Promise, it does not accept spec-style
          // constraints.
          if (navigator.mediaDevices.getUserMedia) {
            const origGetUserMedia = navigator.mediaDevices.getUserMedia.
              bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function (cs) {
              return shimConstraints_(cs, c => origGetUserMedia(c).then(stream => {
                if (c.audio && !stream.getAudioTracks().length ||
                  c.video && !stream.getVideoTracks().length) {
                  stream.getTracks().forEach(track => {
                    track.stop();
                  });
                  throw new DOMException('', 'NotFoundError');
                }
                return stream;
              }, e => Promise.reject(shimError_(e))));
            };
          }
        }


        /***/
      }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetDisplayMedia": () => (/* binding */ shimGetDisplayMedia)
          /* harmony export */
        });
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */

        function shimGetDisplayMedia(window, getSourceId) {
          if (window.navigator.mediaDevices &&
            'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }
          if (!(window.navigator.mediaDevices)) {
            return;
          }
          // getSourceId is a function that returns a promise resolving with
          // the sourceId of the screen/window/tab to be shared.
          if (typeof getSourceId !== 'function') {
            console.error('shimGetDisplayMedia: getSourceId argument is not ' +
              'a function');
            return;
          }
          window.navigator.mediaDevices.getDisplayMedia =
            function getDisplayMedia(constraints) {
              return getSourceId(constraints)
                .then(sourceId => {
                  const widthSpecified = constraints.video && constraints.video.width;
                  const heightSpecified = constraints.video &&
                    constraints.video.height;
                  const frameRateSpecified = constraints.video &&
                    constraints.video.frameRate;
                  constraints.video = {
                    mandatory: {
                      chromeMediaSource: 'desktop',
                      chromeMediaSourceId: sourceId,
                      maxFrameRate: frameRateSpecified || 3
                    }
                  };
                  if (widthSpecified) {
                    constraints.video.mandatory.maxWidth = widthSpecified;
                  }
                  if (heightSpecified) {
                    constraints.video.mandatory.maxHeight = heightSpecified;
                  }
                  return window.navigator.mediaDevices.getUserMedia(constraints);
                });
            };
        }


        /***/
      }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimAddTransceiver": () => (/* binding */ shimAddTransceiver),
/* harmony export */   "shimCreateAnswer": () => (/* binding */ shimCreateAnswer),
/* harmony export */   "shimCreateOffer": () => (/* binding */ shimCreateOffer),
/* harmony export */   "shimGetDisplayMedia": () => (/* reexport safe */ _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__.shimGetDisplayMedia),
/* harmony export */   "shimGetParameters": () => (/* binding */ shimGetParameters),
/* harmony export */   "shimGetUserMedia": () => (/* reexport safe */ _getusermedia__WEBPACK_IMPORTED_MODULE_1__.shimGetUserMedia),
/* harmony export */   "shimOnTrack": () => (/* binding */ shimOnTrack),
/* harmony export */   "shimPeerConnection": () => (/* binding */ shimPeerConnection),
/* harmony export */   "shimRTCDataChannel": () => (/* binding */ shimRTCDataChannel),
/* harmony export */   "shimReceiverGetStats": () => (/* binding */ shimReceiverGetStats),
/* harmony export */   "shimRemoveStream": () => (/* binding */ shimRemoveStream),
/* harmony export */   "shimSenderGetStats": () => (/* binding */ shimSenderGetStats)
          /* harmony export */
        });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _getusermedia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _getdisplaymedia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */






        function shimOnTrack(window) {
          if (typeof window === 'object' && window.RTCTrackEvent &&
            ('receiver' in window.RTCTrackEvent.prototype) &&
            !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get() {
                return { receiver: this.receiver };
              }
            });
          }
        }

        function shimPeerConnection(window, browserDetails) {
          if (typeof window !== 'object' ||
            !(window.RTCPeerConnection || window.mozRTCPeerConnection)) {
            return; // probably media.peerconnection.enabled=false in about:config
          }
          if (!window.RTCPeerConnection && window.mozRTCPeerConnection) {
            // very basic support for old versions.
            window.RTCPeerConnection = window.mozRTCPeerConnection;
          }

          if (browserDetails.version < 53) {
            // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
            ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
              .forEach(function (method) {
                const nativeMethod = window.RTCPeerConnection.prototype[method];
                const methodObj = {
                  [method]() {
                    arguments[0] = new ((method === 'addIceCandidate') ?
                      window.RTCIceCandidate :
                      window.RTCSessionDescription)(arguments[0]);
                    return nativeMethod.apply(this, arguments);
                  }
                };
                window.RTCPeerConnection.prototype[method] = methodObj[method];
              });
          }

          const modernStatsTypes = {
            inboundrtp: 'inbound-rtp',
            outboundrtp: 'outbound-rtp',
            candidatepair: 'candidate-pair',
            localcandidate: 'local-candidate',
            remotecandidate: 'remote-candidate'
          };

          const nativeGetStats = window.RTCPeerConnection.prototype.getStats;
          window.RTCPeerConnection.prototype.getStats = function getStats() {
            const [selector, onSucc, onErr] = arguments;
            return nativeGetStats.apply(this, [selector || null])
              .then(stats => {
                if (browserDetails.version < 53 && !onSucc) {
                  // Shim only promise getStats with spec-hyphens in type names
                  // Leave callback version alone; misc old uses of forEach before Map
                  try {
                    stats.forEach(stat => {
                      stat.type = modernStatsTypes[stat.type] || stat.type;
                    });
                  } catch (e) {
                    if (e.name !== 'TypeError') {
                      throw e;
                    }
                    // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
                    stats.forEach((stat, i) => {
                      stats.set(i, Object.assign({}, stat, {
                        type: modernStatsTypes[stat.type] || stat.type
                      }));
                    });
                  }
                }
                return stats;
              })
              .then(onSucc, onErr);
          };
        }

        function shimSenderGetStats(window) {
          if (!(typeof window === 'object' && window.RTCPeerConnection &&
            window.RTCRtpSender)) {
            return;
          }
          if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
            return;
          }
          const origGetSenders = window.RTCPeerConnection.prototype.getSenders;
          if (origGetSenders) {
            window.RTCPeerConnection.prototype.getSenders = function getSenders() {
              const senders = origGetSenders.apply(this, []);
              senders.forEach(sender => sender._pc = this);
              return senders;
            };
          }

          const origAddTrack = window.RTCPeerConnection.prototype.addTrack;
          if (origAddTrack) {
            window.RTCPeerConnection.prototype.addTrack = function addTrack() {
              const sender = origAddTrack.apply(this, arguments);
              sender._pc = this;
              return sender;
            };
          }
          window.RTCRtpSender.prototype.getStats = function getStats() {
            return this.track ? this._pc.getStats(this.track) :
              Promise.resolve(new Map());
          };
        }

        function shimReceiverGetStats(window) {
          if (!(typeof window === 'object' && window.RTCPeerConnection &&
            window.RTCRtpSender)) {
            return;
          }
          if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
            return;
          }
          const origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
          if (origGetReceivers) {
            window.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
              const receivers = origGetReceivers.apply(this, []);
              receivers.forEach(receiver => receiver._pc = this);
              return receivers;
            };
          }
          _utils__WEBPACK_IMPORTED_MODULE_0__.wrapPeerConnectionEvent(window, 'track', e => {
            e.receiver._pc = e.srcElement;
            return e;
          });
          window.RTCRtpReceiver.prototype.getStats = function getStats() {
            return this._pc.getStats(this.track);
          };
        }

        function shimRemoveStream(window) {
          if (!window.RTCPeerConnection ||
            'removeStream' in window.RTCPeerConnection.prototype) {
            return;
          }
          window.RTCPeerConnection.prototype.removeStream =
            function removeStream(stream) {
              _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('removeStream', 'removeTrack');
              this.getSenders().forEach(sender => {
                if (sender.track && stream.getTracks().includes(sender.track)) {
                  this.removeTrack(sender);
                }
              });
            };
        }

        function shimRTCDataChannel(window) {
          // rename DataChannel to RTCDataChannel (native fix in FF60):
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
          if (window.DataChannel && !window.RTCDataChannel) {
            window.RTCDataChannel = window.DataChannel;
          }
        }

        function shimAddTransceiver(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!(typeof window === 'object' && window.RTCPeerConnection)) {
            return;
          }
          const origAddTransceiver = window.RTCPeerConnection.prototype.addTransceiver;
          if (origAddTransceiver) {
            window.RTCPeerConnection.prototype.addTransceiver =
              function addTransceiver() {
                this.setParametersPromises = [];
                const initParameters = arguments[1];
                const shouldPerformCheck = initParameters &&
                  'sendEncodings' in initParameters;
                if (shouldPerformCheck) {
                  // If sendEncodings params are provided, validate grammar
                  initParameters.sendEncodings.forEach((encodingParam) => {
                    if ('rid' in encodingParam) {
                      const ridRegex = /^[a-z0-9]{0,16}$/i;
                      if (!ridRegex.test(encodingParam.rid)) {
                        throw new TypeError('Invalid RID value provided.');
                      }
                    }
                    if ('scaleResolutionDownBy' in encodingParam) {
                      if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {
                        throw new RangeError('scale_resolution_down_by must be >= 1.0');
                      }
                    }
                    if ('maxFramerate' in encodingParam) {
                      if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
                        throw new RangeError('max_framerate must be >= 0.0');
                      }
                    }
                  });
                }
                const transceiver = origAddTransceiver.apply(this, arguments);
                if (shouldPerformCheck) {
                  // Check if the init options were applied. If not we do this in an
                  // asynchronous way and save the promise reference in a global object.
                  // This is an ugly hack, but at the same time is way more robust than
                  // checking the sender parameters before and after the createOffer
                  // Also note that after the createoffer we are not 100% sure that
                  // the params were asynchronously applied so we might miss the
                  // opportunity to recreate offer.
                  const { sender } = transceiver;
                  const params = sender.getParameters();
                  if (!('encodings' in params) ||
                    // Avoid being fooled by patched getParameters() below.
                    (params.encodings.length === 1 &&
                      Object.keys(params.encodings[0]).length === 0)) {
                    params.encodings = initParameters.sendEncodings;
                    sender.sendEncodings = initParameters.sendEncodings;
                    this.setParametersPromises.push(sender.setParameters(params)
                      .then(() => {
                        delete sender.sendEncodings;
                      }).catch(() => {
                        delete sender.sendEncodings;
                      })
                    );
                  }
                }
                return transceiver;
              };
          }
        }

        function shimGetParameters(window) {
          if (!(typeof window === 'object' && window.RTCRtpSender)) {
            return;
          }
          const origGetParameters = window.RTCRtpSender.prototype.getParameters;
          if (origGetParameters) {
            window.RTCRtpSender.prototype.getParameters =
              function getParameters() {
                const params = origGetParameters.apply(this, arguments);
                if (!('encodings' in params)) {
                  params.encodings = [].concat(this.sendEncodings || [{}]);
                }
                return params;
              };
          }
        }

        function shimCreateOffer(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!(typeof window === 'object' && window.RTCPeerConnection)) {
            return;
          }
          const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
          window.RTCPeerConnection.prototype.createOffer = function createOffer() {
            if (this.setParametersPromises && this.setParametersPromises.length) {
              return Promise.all(this.setParametersPromises)
                .then(() => {
                  return origCreateOffer.apply(this, arguments);
                })
                .finally(() => {
                  this.setParametersPromises = [];
                });
            }
            return origCreateOffer.apply(this, arguments);
          };
        }

        function shimCreateAnswer(window) {
          // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647
          // Firefox ignores the init sendEncodings options passed to addTransceiver
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918
          if (!(typeof window === 'object' && window.RTCPeerConnection)) {
            return;
          }
          const origCreateAnswer = window.RTCPeerConnection.prototype.createAnswer;
          window.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
            if (this.setParametersPromises && this.setParametersPromises.length) {
              return Promise.all(this.setParametersPromises)
                .then(() => {
                  return origCreateAnswer.apply(this, arguments);
                })
                .finally(() => {
                  this.setParametersPromises = [];
                });
            }
            return origCreateAnswer.apply(this, arguments);
          };
        }


        /***/
      }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetUserMedia": () => (/* binding */ shimGetUserMedia)
          /* harmony export */
        });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */




        function shimGetUserMedia(window, browserDetails) {
          const navigator = window && window.navigator;
          const MediaStreamTrack = window && window.MediaStreamTrack;

          navigator.getUserMedia = function (constraints, onSuccess, onError) {
            // Replace Firefox 44+'s deprecation warning with unprefixed version.
            _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('navigator.getUserMedia',
              'navigator.mediaDevices.getUserMedia');
            navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
          };

          if (!(browserDetails.version > 55 &&
            'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
            const remap = function (obj, a, b) {
              if (a in obj && !(b in obj)) {
                obj[b] = obj[a];
                delete obj[a];
              }
            };

            const nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
              bind(navigator.mediaDevices);
            navigator.mediaDevices.getUserMedia = function (c) {
              if (typeof c === 'object' && typeof c.audio === 'object') {
                c = JSON.parse(JSON.stringify(c));
                remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
                remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
              }
              return nativeGetUserMedia(c);
            };

            if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
              const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
              MediaStreamTrack.prototype.getSettings = function () {
                const obj = nativeGetSettings.apply(this, arguments);
                remap(obj, 'mozAutoGainControl', 'autoGainControl');
                remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
                return obj;
              };
            }

            if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
              const nativeApplyConstraints =
                MediaStreamTrack.prototype.applyConstraints;
              MediaStreamTrack.prototype.applyConstraints = function (c) {
                if (this.kind === 'audio' && typeof c === 'object') {
                  c = JSON.parse(JSON.stringify(c));
                  remap(c, 'autoGainControl', 'mozAutoGainControl');
                  remap(c, 'noiseSuppression', 'mozNoiseSuppression');
                }
                return nativeApplyConstraints.apply(this, [c]);
              };
            }
          }
        }


        /***/
      }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimGetDisplayMedia": () => (/* binding */ shimGetDisplayMedia)
          /* harmony export */
        });
        /*
         *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */


        function shimGetDisplayMedia(window, preferredMediaSource) {
          if (window.navigator.mediaDevices &&
            'getDisplayMedia' in window.navigator.mediaDevices) {
            return;
          }
          if (!(window.navigator.mediaDevices)) {
            return;
          }
          window.navigator.mediaDevices.getDisplayMedia =
            function getDisplayMedia(constraints) {
              if (!(constraints && constraints.video)) {
                const err = new DOMException('getDisplayMedia without video ' +
                  'constraints is undefined');
                err.name = 'NotFoundError';
                // from https://heycam.github.io/webidl/#idl-DOMException-error-names
                err.code = 8;
                return Promise.reject(err);
              }
              if (constraints.video === true) {
                constraints.video = { mediaSource: preferredMediaSource };
              } else {
                constraints.video.mediaSource = preferredMediaSource;
              }
              return window.navigator.mediaDevices.getUserMedia(constraints);
            };
        }


        /***/
      }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shimAudioContext": () => (/* binding */ shimAudioContext),
/* harmony export */   "shimCallbacksAPI": () => (/* binding */ shimCallbacksAPI),
/* harmony export */   "shimConstraints": () => (/* binding */ shimConstraints),
/* harmony export */   "shimCreateOfferLegacy": () => (/* binding */ shimCreateOfferLegacy),
/* harmony export */   "shimGetUserMedia": () => (/* binding */ shimGetUserMedia),
/* harmony export */   "shimLocalStreamsAPI": () => (/* binding */ shimLocalStreamsAPI),
/* harmony export */   "shimRTCIceServerUrls": () => (/* binding */ shimRTCIceServerUrls),
/* harmony export */   "shimRemoteStreamsAPI": () => (/* binding */ shimRemoteStreamsAPI),
/* harmony export */   "shimTrackEventTransceiver": () => (/* binding */ shimTrackEventTransceiver)
          /* harmony export */
        });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
        /*
         *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */



        function shimLocalStreamsAPI(window) {
          if (typeof window !== 'object' || !window.RTCPeerConnection) {
            return;
          }
          if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getLocalStreams =
              function getLocalStreams() {
                if (!this._localStreams) {
                  this._localStreams = [];
                }
                return this._localStreams;
              };
          }
          if (!('addStream' in window.RTCPeerConnection.prototype)) {
            const _addTrack = window.RTCPeerConnection.prototype.addTrack;
            window.RTCPeerConnection.prototype.addStream = function addStream(stream) {
              if (!this._localStreams) {
                this._localStreams = [];
              }
              if (!this._localStreams.includes(stream)) {
                this._localStreams.push(stream);
              }
              // Try to emulate Chrome's behaviour of adding in audio-video order.
              // Safari orders by track id.
              stream.getAudioTracks().forEach(track => _addTrack.call(this, track,
                stream));
              stream.getVideoTracks().forEach(track => _addTrack.call(this, track,
                stream));
            };

            window.RTCPeerConnection.prototype.addTrack =
              function addTrack(track, ...streams) {
                if (streams) {
                  streams.forEach((stream) => {
                    if (!this._localStreams) {
                      this._localStreams = [stream];
                    } else if (!this._localStreams.includes(stream)) {
                      this._localStreams.push(stream);
                    }
                  });
                }
                return _addTrack.apply(this, arguments);
              };
          }
          if (!('removeStream' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.removeStream =
              function removeStream(stream) {
                if (!this._localStreams) {
                  this._localStreams = [];
                }
                const index = this._localStreams.indexOf(stream);
                if (index === -1) {
                  return;
                }
                this._localStreams.splice(index, 1);
                const tracks = stream.getTracks();
                this.getSenders().forEach(sender => {
                  if (tracks.includes(sender.track)) {
                    this.removeTrack(sender);
                  }
                });
              };
          }
        }

        function shimRemoteStreamsAPI(window) {
          if (typeof window !== 'object' || !window.RTCPeerConnection) {
            return;
          }
          if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
            window.RTCPeerConnection.prototype.getRemoteStreams =
              function getRemoteStreams() {
                return this._remoteStreams ? this._remoteStreams : [];
              };
          }
          if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
              get() {
                return this._onaddstream;
              },
              set(f) {
                if (this._onaddstream) {
                  this.removeEventListener('addstream', this._onaddstream);
                  this.removeEventListener('track', this._onaddstreampoly);
                }
                this.addEventListener('addstream', this._onaddstream = f);
                this.addEventListener('track', this._onaddstreampoly = (e) => {
                  e.streams.forEach(stream => {
                    if (!this._remoteStreams) {
                      this._remoteStreams = [];
                    }
                    if (this._remoteStreams.includes(stream)) {
                      return;
                    }
                    this._remoteStreams.push(stream);
                    const event = new Event('addstream');
                    event.stream = stream;
                    this.dispatchEvent(event);
                  });
                });
              }
            });
            const origSetRemoteDescription =
              window.RTCPeerConnection.prototype.setRemoteDescription;
            window.RTCPeerConnection.prototype.setRemoteDescription =
              function setRemoteDescription() {
                const pc = this;
                if (!this._onaddstreampoly) {
                  this.addEventListener('track', this._onaddstreampoly = function (e) {
                    e.streams.forEach(stream => {
                      if (!pc._remoteStreams) {
                        pc._remoteStreams = [];
                      }
                      if (pc._remoteStreams.indexOf(stream) >= 0) {
                        return;
                      }
                      pc._remoteStreams.push(stream);
                      const event = new Event('addstream');
                      event.stream = stream;
                      pc.dispatchEvent(event);
                    });
                  });
                }
                return origSetRemoteDescription.apply(pc, arguments);
              };
          }
        }

        function shimCallbacksAPI(window) {
          if (typeof window !== 'object' || !window.RTCPeerConnection) {
            return;
          }
          const prototype = window.RTCPeerConnection.prototype;
          const origCreateOffer = prototype.createOffer;
          const origCreateAnswer = prototype.createAnswer;
          const setLocalDescription = prototype.setLocalDescription;
          const setRemoteDescription = prototype.setRemoteDescription;
          const addIceCandidate = prototype.addIceCandidate;

          prototype.createOffer =
            function createOffer(successCallback, failureCallback) {
              const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
              const promise = origCreateOffer.apply(this, [options]);
              if (!failureCallback) {
                return promise;
              }
              promise.then(successCallback, failureCallback);
              return Promise.resolve();
            };

          prototype.createAnswer =
            function createAnswer(successCallback, failureCallback) {
              const options = (arguments.length >= 2) ? arguments[2] : arguments[0];
              const promise = origCreateAnswer.apply(this, [options]);
              if (!failureCallback) {
                return promise;
              }
              promise.then(successCallback, failureCallback);
              return Promise.resolve();
            };

          let withCallback = function (description, successCallback, failureCallback) {
            const promise = setLocalDescription.apply(this, [description]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };
          prototype.setLocalDescription = withCallback;

          withCallback = function (description, successCallback, failureCallback) {
            const promise = setRemoteDescription.apply(this, [description]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };
          prototype.setRemoteDescription = withCallback;

          withCallback = function (candidate, successCallback, failureCallback) {
            const promise = addIceCandidate.apply(this, [candidate]);
            if (!failureCallback) {
              return promise;
            }
            promise.then(successCallback, failureCallback);
            return Promise.resolve();
          };
          prototype.addIceCandidate = withCallback;
        }

        function shimGetUserMedia(window) {
          const navigator = window && window.navigator;

          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            // shim not needed in Safari 12.1
            const mediaDevices = navigator.mediaDevices;
            const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
            navigator.mediaDevices.getUserMedia = (constraints) => {
              return _getUserMedia(shimConstraints(constraints));
            };
          }

          if (!navigator.getUserMedia && navigator.mediaDevices &&
            navigator.mediaDevices.getUserMedia) {
            navigator.getUserMedia = function getUserMedia(constraints, cb, errcb) {
              navigator.mediaDevices.getUserMedia(constraints)
                .then(cb, errcb);
            }.bind(navigator);
          }
        }

        function shimConstraints(constraints) {
          if (constraints && constraints.video !== undefined) {
            return Object.assign({},
              constraints,
              { video: _utils__WEBPACK_IMPORTED_MODULE_0__.compactObject(constraints.video) }
            );
          }

          return constraints;
        }

        function shimRTCIceServerUrls(window) {
          if (!window.RTCPeerConnection) {
            return;
          }
          // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
          const OrigPeerConnection = window.RTCPeerConnection;
          window.RTCPeerConnection =
            function RTCPeerConnection(pcConfig, pcConstraints) {
              if (pcConfig && pcConfig.iceServers) {
                const newIceServers = [];
                for (let i = 0; i < pcConfig.iceServers.length; i++) {
                  let server = pcConfig.iceServers[i];
                  if (!server.hasOwnProperty('urls') &&
                    server.hasOwnProperty('url')) {
                    _utils__WEBPACK_IMPORTED_MODULE_0__.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
                    server = JSON.parse(JSON.stringify(server));
                    server.urls = server.url;
                    delete server.url;
                    newIceServers.push(server);
                  } else {
                    newIceServers.push(pcConfig.iceServers[i]);
                  }
                }
                pcConfig.iceServers = newIceServers;
              }
              return new OrigPeerConnection(pcConfig, pcConstraints);
            };
          window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
          // wrap static methods. Currently just generateCertificate.
          if ('generateCertificate' in OrigPeerConnection) {
            Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
              get() {
                return OrigPeerConnection.generateCertificate;
              }
            });
          }
        }

        function shimTrackEventTransceiver(window) {
          // Add event.transceiver member over deprecated event.receiver
          if (typeof window === 'object' && window.RTCTrackEvent &&
            'receiver' in window.RTCTrackEvent.prototype &&
            !('transceiver' in window.RTCTrackEvent.prototype)) {
            Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
              get() {
                return { receiver: this.receiver };
              }
            });
          }
        }

        function shimCreateOfferLegacy(window) {
          const origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
          window.RTCPeerConnection.prototype.createOffer =
            function createOffer(offerOptions) {
              if (offerOptions) {
                if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
                  // support bit values
                  offerOptions.offerToReceiveAudio =
                    !!offerOptions.offerToReceiveAudio;
                }
                const audioTransceiver = this.getTransceivers().find(transceiver =>
                  transceiver.receiver.track.kind === 'audio');
                if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
                  if (audioTransceiver.direction === 'sendrecv') {
                    if (audioTransceiver.setDirection) {
                      audioTransceiver.setDirection('sendonly');
                    } else {
                      audioTransceiver.direction = 'sendonly';
                    }
                  } else if (audioTransceiver.direction === 'recvonly') {
                    if (audioTransceiver.setDirection) {
                      audioTransceiver.setDirection('inactive');
                    } else {
                      audioTransceiver.direction = 'inactive';
                    }
                  }
                } else if (offerOptions.offerToReceiveAudio === true &&
                  !audioTransceiver) {
                  this.addTransceiver('audio', { direction: 'recvonly' });
                }

                if (typeof offerOptions.offerToReceiveVideo !== 'undefined') {
                  // support bit values
                  offerOptions.offerToReceiveVideo =
                    !!offerOptions.offerToReceiveVideo;
                }
                const videoTransceiver = this.getTransceivers().find(transceiver =>
                  transceiver.receiver.track.kind === 'video');
                if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
                  if (videoTransceiver.direction === 'sendrecv') {
                    if (videoTransceiver.setDirection) {
                      videoTransceiver.setDirection('sendonly');
                    } else {
                      videoTransceiver.direction = 'sendonly';
                    }
                  } else if (videoTransceiver.direction === 'recvonly') {
                    if (videoTransceiver.setDirection) {
                      videoTransceiver.setDirection('inactive');
                    } else {
                      videoTransceiver.direction = 'inactive';
                    }
                  }
                } else if (offerOptions.offerToReceiveVideo === true &&
                  !videoTransceiver) {
                  this.addTransceiver('video', { direction: 'recvonly' });
                }
              }
              return origCreateOffer.apply(this, arguments);
            };
        }

        function shimAudioContext(window) {
          if (typeof window !== 'object' || window.AudioContext) {
            return;
          }
          window.AudioContext = window.webkitAudioContext;
        }



        /***/
      }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "removeExtmapAllowMixed": () => (/* binding */ removeExtmapAllowMixed),
/* harmony export */   "shimAddIceCandidateNullOrEmpty": () => (/* binding */ shimAddIceCandidateNullOrEmpty),
/* harmony export */   "shimConnectionState": () => (/* binding */ shimConnectionState),
/* harmony export */   "shimMaxMessageSize": () => (/* binding */ shimMaxMessageSize),
/* harmony export */   "shimParameterlessSetLocalDescription": () => (/* binding */ shimParameterlessSetLocalDescription),
/* harmony export */   "shimRTCIceCandidate": () => (/* binding */ shimRTCIceCandidate),
/* harmony export */   "shimSendThrowTypeError": () => (/* binding */ shimSendThrowTypeError)
          /* harmony export */
        });
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony import */ var sdp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sdp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
        /*
         *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
         *
         *  Use of this source code is governed by a BSD-style license
         *  that can be found in the LICENSE file in the root of the source
         *  tree.
         */
        /* eslint-env node */





        function shimRTCIceCandidate(window) {
          // foundation is arbitrarily chosen as an indicator for full support for
          // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
          if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
            window.RTCIceCandidate.prototype)) {
            return;
          }

          const NativeRTCIceCandidate = window.RTCIceCandidate;
          window.RTCIceCandidate = function RTCIceCandidate(args) {
            // Remove the a= which shouldn't be part of the candidate string.
            if (typeof args === 'object' && args.candidate &&
              args.candidate.indexOf('a=') === 0) {
              args = JSON.parse(JSON.stringify(args));
              args.candidate = args.candidate.substr(2);
            }

            if (args.candidate && args.candidate.length) {
              // Augment the native candidate with the parsed fields.
              const nativeCandidate = new NativeRTCIceCandidate(args);
              const parsedCandidate = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseCandidate(args.candidate);
              const augmentedCandidate = Object.assign(nativeCandidate,
                parsedCandidate);

              // Add a serializer that does not serialize the extra attributes.
              augmentedCandidate.toJSON = function toJSON() {
                return {
                  candidate: augmentedCandidate.candidate,
                  sdpMid: augmentedCandidate.sdpMid,
                  sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
                  usernameFragment: augmentedCandidate.usernameFragment,
                };
              };
              return augmentedCandidate;
            }
            return new NativeRTCIceCandidate(args);
          };
          window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

          // Hook up the augmented candidate in onicecandidate and
          // addEventListener('icecandidate', ...)
          _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'icecandidate', e => {
            if (e.candidate) {
              Object.defineProperty(e, 'candidate', {
                value: new window.RTCIceCandidate(e.candidate),
                writable: 'false'
              });
            }
            return e;
          });
        }

        function shimMaxMessageSize(window, browserDetails) {
          if (!window.RTCPeerConnection) {
            return;
          }

          if (!('sctp' in window.RTCPeerConnection.prototype)) {
            Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
              get() {
                return typeof this._sctp === 'undefined' ? null : this._sctp;
              }
            });
          }

          const sctpInDescription = function (description) {
            if (!description || !description.sdp) {
              return false;
            }
            const sections = sdp__WEBPACK_IMPORTED_MODULE_0___default().splitSections(description.sdp);
            sections.shift();
            return sections.some(mediaSection => {
              const mLine = sdp__WEBPACK_IMPORTED_MODULE_0___default().parseMLine(mediaSection);
              return mLine && mLine.kind === 'application'
                && mLine.protocol.indexOf('SCTP') !== -1;
            });
          };

          const getRemoteFirefoxVersion = function (description) {
            // TODO: Is there a better solution for detecting Firefox?
            const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
            if (match === null || match.length < 2) {
              return -1;
            }
            const version = parseInt(match[1], 10);
            // Test for NaN (yes, this is ugly)
            return version !== version ? -1 : version;
          };

          const getCanSendMaxMessageSize = function (remoteIsFirefox) {
            // Every implementation we know can send at least 64 KiB.
            // Note: Although Chrome is technically able to send up to 256 KiB, the
            //       data does not reach the other peer reliably.
            //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
            let canSendMaxMessageSize = 65536;
            if (browserDetails.browser === 'firefox') {
              if (browserDetails.version < 57) {
                if (remoteIsFirefox === -1) {
                  // FF < 57 will send in 16 KiB chunks using the deprecated PPID
                  // fragmentation.
                  canSendMaxMessageSize = 16384;
                } else {
                  // However, other FF (and RAWRTC) can reassemble PPID-fragmented
                  // messages. Thus, supporting ~2 GiB when sending.
                  canSendMaxMessageSize = 2147483637;
                }
              } else if (browserDetails.version < 60) {
                // Currently, all FF >= 57 will reset the remote maximum message size
                // to the default value when a data channel is created at a later
                // stage. :(
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
                canSendMaxMessageSize =
                  browserDetails.version === 57 ? 65535 : 65536;
              } else {
                // FF >= 60 supports sending ~2 GiB
                canSendMaxMessageSize = 2147483637;
              }
            }
            return canSendMaxMessageSize;
          };

          const getMaxMessageSize = function (description, remoteIsFirefox) {
            // Note: 65536 bytes is the default value from the SDP spec. Also,
            //       every implementation we know supports receiving 65536 bytes.
            let maxMessageSize = 65536;

            // FF 57 has a slightly incorrect default remote max message size, so
            // we need to adjust it here to avoid a failure when sending.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
            if (browserDetails.browser === 'firefox'
              && browserDetails.version === 57) {
              maxMessageSize = 65535;
            }

            const match = sdp__WEBPACK_IMPORTED_MODULE_0___default().matchPrefix(description.sdp,
              'a=max-message-size:');
            if (match.length > 0) {
              maxMessageSize = parseInt(match[0].substr(19), 10);
            } else if (browserDetails.browser === 'firefox' &&
              remoteIsFirefox !== -1) {
              // If the maximum message size is not present in the remote SDP and
              // both local and remote are Firefox, the remote peer can receive
              // ~2 GiB.
              maxMessageSize = 2147483637;
            }
            return maxMessageSize;
          };

          const origSetRemoteDescription =
            window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription =
            function setRemoteDescription() {
              this._sctp = null;
              // Chrome decided to not expose .sctp in plan-b mode.
              // As usual, adapter.js has to do an 'ugly worakaround'
              // to cover up the mess.
              if (browserDetails.browser === 'chrome' && browserDetails.version >= 76) {
                const { sdpSemantics } = this.getConfiguration();
                if (sdpSemantics === 'plan-b') {
                  Object.defineProperty(this, 'sctp', {
                    get() {
                      return typeof this._sctp === 'undefined' ? null : this._sctp;
                    },
                    enumerable: true,
                    configurable: true,
                  });
                }
              }

              if (sctpInDescription(arguments[0])) {
                // Check if the remote is FF.
                const isFirefox = getRemoteFirefoxVersion(arguments[0]);

                // Get the maximum message size the local peer is capable of sending
                const canSendMMS = getCanSendMaxMessageSize(isFirefox);

                // Get the maximum message size of the remote peer.
                const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

                // Determine final maximum message size
                let maxMessageSize;
                if (canSendMMS === 0 && remoteMMS === 0) {
                  maxMessageSize = Number.POSITIVE_INFINITY;
                } else if (canSendMMS === 0 || remoteMMS === 0) {
                  maxMessageSize = Math.max(canSendMMS, remoteMMS);
                } else {
                  maxMessageSize = Math.min(canSendMMS, remoteMMS);
                }

                // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
                // attribute.
                const sctp = {};
                Object.defineProperty(sctp, 'maxMessageSize', {
                  get() {
                    return maxMessageSize;
                  }
                });
                this._sctp = sctp;
              }

              return origSetRemoteDescription.apply(this, arguments);
            };
        }

        function shimSendThrowTypeError(window) {
          if (!(window.RTCPeerConnection &&
            'createDataChannel' in window.RTCPeerConnection.prototype)) {
            return;
          }

          // Note: Although Firefox >= 57 has a native implementation, the maximum
          //       message size can be reset for all data channels at a later stage.
          //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

          function wrapDcSend(dc, pc) {
            const origDataChannelSend = dc.send;
            dc.send = function send() {
              const data = arguments[0];
              const length = data.length || data.size || data.byteLength;
              if (dc.readyState === 'open' &&
                pc.sctp && length > pc.sctp.maxMessageSize) {
                throw new TypeError('Message too large (can send a maximum of ' +
                  pc.sctp.maxMessageSize + ' bytes)');
              }
              return origDataChannelSend.apply(dc, arguments);
            };
          }
          const origCreateDataChannel =
            window.RTCPeerConnection.prototype.createDataChannel;
          window.RTCPeerConnection.prototype.createDataChannel =
            function createDataChannel() {
              const dataChannel = origCreateDataChannel.apply(this, arguments);
              wrapDcSend(dataChannel, this);
              return dataChannel;
            };
          _utils__WEBPACK_IMPORTED_MODULE_1__.wrapPeerConnectionEvent(window, 'datachannel', e => {
            wrapDcSend(e.channel, e.target);
            return e;
          });
        }


        /* shims RTCConnectionState by pretending it is the same as iceConnectionState.
         * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12
         * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect
         * since DTLS failures would be hidden. See
         * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827
         * for the Firefox tracking bug.
         */
        function shimConnectionState(window) {
          if (!window.RTCPeerConnection ||
            'connectionState' in window.RTCPeerConnection.prototype) {
            return;
          }
          const proto = window.RTCPeerConnection.prototype;
          Object.defineProperty(proto, 'connectionState', {
            get() {
              return {
                completed: 'connected',
                checking: 'connecting'
              }[this.iceConnectionState] || this.iceConnectionState;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(proto, 'onconnectionstatechange', {
            get() {
              return this._onconnectionstatechange || null;
            },
            set(cb) {
              if (this._onconnectionstatechange) {
                this.removeEventListener('connectionstatechange',
                  this._onconnectionstatechange);
                delete this._onconnectionstatechange;
              }
              if (cb) {
                this.addEventListener('connectionstatechange',
                  this._onconnectionstatechange = cb);
              }
            },
            enumerable: true,
            configurable: true
          });

          ['setLocalDescription', 'setRemoteDescription'].forEach((method) => {
            const origMethod = proto[method];
            proto[method] = function () {
              if (!this._connectionstatechangepoly) {
                this._connectionstatechangepoly = e => {
                  const pc = e.target;
                  if (pc._lastConnectionState !== pc.connectionState) {
                    pc._lastConnectionState = pc.connectionState;
                    const newEvent = new Event('connectionstatechange', e);
                    pc.dispatchEvent(newEvent);
                  }
                  return e;
                };
                this.addEventListener('iceconnectionstatechange',
                  this._connectionstatechangepoly);
              }
              return origMethod.apply(this, arguments);
            };
          });
        }

        function removeExtmapAllowMixed(window, browserDetails) {
          /* remove a=extmap-allow-mixed for webrtc.org < M71 */
          if (!window.RTCPeerConnection) {
            return;
          }
          if (browserDetails.browser === 'chrome' && browserDetails.version >= 71) {
            return;
          }
          if (browserDetails.browser === 'safari' && browserDetails.version >= 605) {
            return;
          }
          const nativeSRD = window.RTCPeerConnection.prototype.setRemoteDescription;
          window.RTCPeerConnection.prototype.setRemoteDescription =
            function setRemoteDescription(desc) {
              if (desc && desc.sdp && desc.sdp.indexOf('\na=extmap-allow-mixed') !== -1) {
                const sdp = desc.sdp.split('\n').filter((line) => {
                  return line.trim() !== 'a=extmap-allow-mixed';
                }).join('\n');
                // Safari enforces read-only-ness of RTCSessionDescription fields.
                if (window.RTCSessionDescription &&
                  desc instanceof window.RTCSessionDescription) {
                  arguments[0] = new window.RTCSessionDescription({
                    type: desc.type,
                    sdp,
                  });
                } else {
                  desc.sdp = sdp;
                }
              }
              return nativeSRD.apply(this, arguments);
            };
        }

        function shimAddIceCandidateNullOrEmpty(window, browserDetails) {
          // Support for addIceCandidate(null or undefined)
          // as well as addIceCandidate({candidate: "", ...})
          // https://bugs.chromium.org/p/chromium/issues/detail?id=978582
          // Note: must be called before other polyfills which change the signature.
          if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
            return;
          }
          const nativeAddIceCandidate =
            window.RTCPeerConnection.prototype.addIceCandidate;
          if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
            return;
          }
          window.RTCPeerConnection.prototype.addIceCandidate =
            function addIceCandidate() {
              if (!arguments[0]) {
                if (arguments[1]) {
                  arguments[1].apply(null);
                }
                return Promise.resolve();
              }
              // Firefox 68+ emits and processes {candidate: "", ...}, ignore
              // in older versions.
              // Native support for ignoring exists for Chrome M77+.
              // Safari ignores as well, exact version unknown but works in the same
              // version that also ignores addIceCandidate(null).
              if (((browserDetails.browser === 'chrome' && browserDetails.version < 78)
                || (browserDetails.browser === 'firefox'
                  && browserDetails.version < 68)
                || (browserDetails.browser === 'safari'))
                && arguments[0] && arguments[0].candidate === '') {
                return Promise.resolve();
              }
              return nativeAddIceCandidate.apply(this, arguments);
            };
        }

        // Note: Make sure to call this ahead of APIs that modify
        // setLocalDescription.length
        function shimParameterlessSetLocalDescription(window, browserDetails) {
          if (!(window.RTCPeerConnection && window.RTCPeerConnection.prototype)) {
            return;
          }
          const nativeSetLocalDescription =
            window.RTCPeerConnection.prototype.setLocalDescription;
          if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
            return;
          }
          window.RTCPeerConnection.prototype.setLocalDescription =
            function setLocalDescription() {
              let desc = arguments[0] || {};
              if (typeof desc !== 'object' || (desc.type && desc.sdp)) {
                return nativeSetLocalDescription.apply(this, arguments);
              }
              // The remaining steps should technically happen when SLD comes off the
              // RTCPeerConnection's operations chain (not ahead of going on it), but
              // this is too difficult to shim. Instead, this shim only covers the
              // common case where the operations chain is empty. This is imperfect, but
              // should cover many cases. Rationale: Even if we can't reduce the glare
              // window to zero on imperfect implementations, there's value in tapping
              // into the perfect negotiation pattern that several browsers support.
              desc = { type: desc.type, sdp: desc.sdp };
              if (!desc.type) {
                switch (this.signalingState) {
                  case 'stable':
                  case 'have-local-offer':
                  case 'have-remote-pranswer':
                    desc.type = 'offer';
                    break;
                  default:
                    desc.type = 'answer';
                    break;
                }
              }
              if (desc.sdp || (desc.type !== 'offer' && desc.type !== 'answer')) {
                return nativeSetLocalDescription.apply(this, [desc]);
              }
              const func = desc.type === 'offer' ? this.createOffer : this.createAnswer;
              return func.apply(this)
                .then(d => nativeSetLocalDescription.apply(this, [d]));
            };
        }


        /***/
      }),
/* 55 */
/***/ ((module) => {

        "use strict";
        /* eslint-env node */


        // SDP helpers.
        const SDPUtils = {};

        // Generate an alphanumeric identifier for cname or mids.
        // TODO: use UUIDs instead? https://gist.github.com/jed/982883
        SDPUtils.generateIdentifier = function () {
          return Math.random().toString(36).substr(2, 10);
        };

        // The RTCP CNAME used by all peerconnections from the same JS.
        SDPUtils.localCName = SDPUtils.generateIdentifier();

        // Splits SDP into lines, dealing with both CRLF and LF.
        SDPUtils.splitLines = function (blob) {
          return blob.trim().split('\n').map(line => line.trim());
        };
        // Splits SDP into sessionpart and mediasections. Ensures CRLF.
        SDPUtils.splitSections = function (blob) {
          const parts = blob.split('\nm=');
          return parts.map((part, index) => (index > 0 ?
            'm=' + part : part).trim() + '\r\n');
        };

        // Returns the session description.
        SDPUtils.getDescription = function (blob) {
          const sections = SDPUtils.splitSections(blob);
          return sections && sections[0];
        };

        // Returns the individual media sections.
        SDPUtils.getMediaSections = function (blob) {
          const sections = SDPUtils.splitSections(blob);
          sections.shift();
          return sections;
        };

        // Returns lines that start with a certain prefix.
        SDPUtils.matchPrefix = function (blob, prefix) {
          return SDPUtils.splitLines(blob).filter(line => line.indexOf(prefix) === 0);
        };

        // Parses an ICE candidate line. Sample input:
        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
        // rport 55996"
        // Input can be prefixed with a=.
        SDPUtils.parseCandidate = function (line) {
          let parts;
          // Parse both variants.
          if (line.indexOf('a=candidate:') === 0) {
            parts = line.substring(12).split(' ');
          } else {
            parts = line.substring(10).split(' ');
          }

          const candidate = {
            foundation: parts[0],
            component: { 1: 'rtp', 2: 'rtcp' }[parts[1]] || parts[1],
            protocol: parts[2].toLowerCase(),
            priority: parseInt(parts[3], 10),
            ip: parts[4],
            address: parts[4], // address is an alias for ip.
            port: parseInt(parts[5], 10),
            // skip parts[6] == 'typ'
            type: parts[7],
          };

          for (let i = 8; i < parts.length; i += 2) {
            switch (parts[i]) {
              case 'raddr':
                candidate.relatedAddress = parts[i + 1];
                break;
              case 'rport':
                candidate.relatedPort = parseInt(parts[i + 1], 10);
                break;
              case 'tcptype':
                candidate.tcpType = parts[i + 1];
                break;
              case 'ufrag':
                candidate.ufrag = parts[i + 1]; // for backward compatibility.
                candidate.usernameFragment = parts[i + 1];
                break;
              default: // extension handling, in particular ufrag. Don't overwrite.
                if (candidate[parts[i]] === undefined) {
                  candidate[parts[i]] = parts[i + 1];
                }
                break;
            }
          }
          return candidate;
        };

        // Translates a candidate object into SDP candidate attribute.
        // This does not include the a= prefix!
        SDPUtils.writeCandidate = function (candidate) {
          const sdp = [];
          sdp.push(candidate.foundation);

          const component = candidate.component;
          if (component === 'rtp') {
            sdp.push(1);
          } else if (component === 'rtcp') {
            sdp.push(2);
          } else {
            sdp.push(component);
          }
          sdp.push(candidate.protocol.toUpperCase());
          sdp.push(candidate.priority);
          sdp.push(candidate.address || candidate.ip);
          sdp.push(candidate.port);

          const type = candidate.type;
          sdp.push('typ');
          sdp.push(type);
          if (type !== 'host' && candidate.relatedAddress &&
            candidate.relatedPort) {
            sdp.push('raddr');
            sdp.push(candidate.relatedAddress);
            sdp.push('rport');
            sdp.push(candidate.relatedPort);
          }
          if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
            sdp.push('tcptype');
            sdp.push(candidate.tcpType);
          }
          if (candidate.usernameFragment || candidate.ufrag) {
            sdp.push('ufrag');
            sdp.push(candidate.usernameFragment || candidate.ufrag);
          }
          return 'candidate:' + sdp.join(' ');
        };

        // Parses an ice-options line, returns an array of option tags.
        // Sample input:
        // a=ice-options:foo bar
        SDPUtils.parseIceOptions = function (line) {
          return line.substr(14).split(' ');
        };

        // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:
        // a=rtpmap:111 opus/48000/2
        SDPUtils.parseRtpMap = function (line) {
          let parts = line.substr(9).split(' ');
          const parsed = {
            payloadType: parseInt(parts.shift(), 10), // was: id
          };

          parts = parts[0].split('/');

          parsed.name = parts[0];
          parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
          parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
          // legacy alias, got renamed back to channels in ORTC.
          parsed.numChannels = parsed.channels;
          return parsed;
        };

        // Generates a rtpmap line from RTCRtpCodecCapability or
        // RTCRtpCodecParameters.
        SDPUtils.writeRtpMap = function (codec) {
          let pt = codec.payloadType;
          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }
          const channels = codec.channels || codec.numChannels || 1;
          return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
            (channels !== 1 ? '/' + channels : '') + '\r\n';
        };

        // Parses a extmap line (headerextension from RFC 5285). Sample input:
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
        SDPUtils.parseExtmap = function (line) {
          const parts = line.substr(9).split(' ');
          return {
            id: parseInt(parts[0], 10),
            direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
            uri: parts[1],
          };
        };

        // Generates an extmap line from RTCRtpHeaderExtensionParameters or
        // RTCRtpHeaderExtension.
        SDPUtils.writeExtmap = function (headerExtension) {
          return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
            (headerExtension.direction && headerExtension.direction !== 'sendrecv'
              ? '/' + headerExtension.direction
              : '') +
            ' ' + headerExtension.uri + '\r\n';
        };

        // Parses a fmtp line, returns dictionary. Sample input:
        // a=fmtp:96 vbr=on;cng=on
        // Also deals with vbr=on; cng=on
        SDPUtils.parseFmtp = function (line) {
          const parsed = {};
          let kv;
          const parts = line.substr(line.indexOf(' ') + 1).split(';');
          for (let j = 0; j < parts.length; j++) {
            kv = parts[j].trim().split('=');
            parsed[kv[0].trim()] = kv[1];
          }
          return parsed;
        };

        // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
        SDPUtils.writeFmtp = function (codec) {
          let line = '';
          let pt = codec.payloadType;
          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }
          if (codec.parameters && Object.keys(codec.parameters).length) {
            const params = [];
            Object.keys(codec.parameters).forEach(param => {
              if (codec.parameters[param] !== undefined) {
                params.push(param + '=' + codec.parameters[param]);
              } else {
                params.push(param);
              }
            });
            line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
          }
          return line;
        };

        // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
        // a=rtcp-fb:98 nack rpsi
        SDPUtils.parseRtcpFb = function (line) {
          const parts = line.substr(line.indexOf(' ') + 1).split(' ');
          return {
            type: parts.shift(),
            parameter: parts.join(' '),
          };
        };

        // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
        SDPUtils.writeRtcpFb = function (codec) {
          let lines = '';
          let pt = codec.payloadType;
          if (codec.preferredPayloadType !== undefined) {
            pt = codec.preferredPayloadType;
          }
          if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
            // FIXME: special handling for trr-int?
            codec.rtcpFeedback.forEach(fb => {
              lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
                (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
                '\r\n';
            });
          }
          return lines;
        };

        // Parses a RFC 5576 ssrc media attribute. Sample input:
        // a=ssrc:3735928559 cname:something
        SDPUtils.parseSsrcMedia = function (line) {
          const sp = line.indexOf(' ');
          const parts = {
            ssrc: parseInt(line.substr(7, sp - 7), 10),
          };
          const colon = line.indexOf(':', sp);
          if (colon > -1) {
            parts.attribute = line.substr(sp + 1, colon - sp - 1);
            parts.value = line.substr(colon + 1);
          } else {
            parts.attribute = line.substr(sp + 1);
          }
          return parts;
        };

        // Parse a ssrc-group line (see RFC 5576). Sample input:
        // a=ssrc-group:semantics 12 34
        SDPUtils.parseSsrcGroup = function (line) {
          const parts = line.substr(13).split(' ');
          return {
            semantics: parts.shift(),
            ssrcs: parts.map(ssrc => parseInt(ssrc, 10)),
          };
        };

        // Extracts the MID (RFC 5888) from a media section.
        // Returns the MID or undefined if no mid line was found.
        SDPUtils.getMid = function (mediaSection) {
          const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
          if (mid) {
            return mid.substr(6);
          }
        };

        // Parses a fingerprint line for DTLS-SRTP.
        SDPUtils.parseFingerprint = function (line) {
          const parts = line.substr(14).split(' ');
          return {
            algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
            value: parts[1].toUpperCase(), // the definition is upper-case in RFC 4572.
          };
        };

        // Extracts DTLS parameters from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the fingerprint line as input. See also getIceParameters.
        SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
          const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
            'a=fingerprint:');
          // Note: a=setup line is ignored since we use the 'auto' role in Edge.
          return {
            role: 'auto',
            fingerprints: lines.map(SDPUtils.parseFingerprint),
          };
        };

        // Serializes DTLS parameters to SDP.
        SDPUtils.writeDtlsParameters = function (params, setupType) {
          let sdp = 'a=setup:' + setupType + '\r\n';
          params.fingerprints.forEach(fp => {
            sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
          });
          return sdp;
        };

        // Parses a=crypto lines into
        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members
        SDPUtils.parseCryptoLine = function (line) {
          const parts = line.substr(9).split(' ');
          return {
            tag: parseInt(parts[0], 10),
            cryptoSuite: parts[1],
            keyParams: parts[2],
            sessionParams: parts.slice(3),
          };
        };

        SDPUtils.writeCryptoLine = function (parameters) {
          return 'a=crypto:' + parameters.tag + ' ' +
            parameters.cryptoSuite + ' ' +
            (typeof parameters.keyParams === 'object'
              ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
              : parameters.keyParams) +
            (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +
            '\r\n';
        };

        // Parses the crypto key parameters into
        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*
        SDPUtils.parseCryptoKeyParams = function (keyParams) {
          if (keyParams.indexOf('inline:') !== 0) {
            return null;
          }
          const parts = keyParams.substr(7).split('|');
          return {
            keyMethod: 'inline',
            keySalt: parts[0],
            lifeTime: parts[1],
            mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
            mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
          };
        };

        SDPUtils.writeCryptoKeyParams = function (keyParams) {
          return keyParams.keyMethod + ':'
            + keyParams.keySalt +
            (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +
            (keyParams.mkiValue && keyParams.mkiLength
              ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength
              : '');
        };

        // Extracts all SDES parameters.
        SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {
          const lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
            'a=crypto:');
          return lines.map(SDPUtils.parseCryptoLine);
        };

        // Parses ICE information from SDP media section or sessionpart.
        // FIXME: for consistency with other functions this should only
        //   get the ice-ufrag and ice-pwd lines as input.
        SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
          const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,
            'a=ice-ufrag:')[0];
          const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,
            'a=ice-pwd:')[0];
          if (!(ufrag && pwd)) {
            return null;
          }
          return {
            usernameFragment: ufrag.substr(12),
            password: pwd.substr(10),
          };
        };

        // Serializes ICE parameters to SDP.
        SDPUtils.writeIceParameters = function (params) {
          let sdp = 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
            'a=ice-pwd:' + params.password + '\r\n';
          if (params.iceLite) {
            sdp += 'a=ice-lite\r\n';
          }
          return sdp;
        };

        // Parses the SDP media section and returns RTCRtpParameters.
        SDPUtils.parseRtpParameters = function (mediaSection) {
          const description = {
            codecs: [],
            headerExtensions: [],
            fecMechanisms: [],
            rtcp: [],
          };
          const lines = SDPUtils.splitLines(mediaSection);
          const mline = lines[0].split(' ');
          for (let i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
            const pt = mline[i];
            const rtpmapline = SDPUtils.matchPrefix(
              mediaSection, 'a=rtpmap:' + pt + ' ')[0];
            if (rtpmapline) {
              const codec = SDPUtils.parseRtpMap(rtpmapline);
              const fmtps = SDPUtils.matchPrefix(
                mediaSection, 'a=fmtp:' + pt + ' ');
              // Only the first a=fmtp:<pt> is considered.
              codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
              codec.rtcpFeedback = SDPUtils.matchPrefix(
                mediaSection, 'a=rtcp-fb:' + pt + ' ')
                .map(SDPUtils.parseRtcpFb);
              description.codecs.push(codec);
              // parse FEC mechanisms from rtpmap lines.
              switch (codec.name.toUpperCase()) {
                case 'RED':
                case 'ULPFEC':
                  description.fecMechanisms.push(codec.name.toUpperCase());
                  break;
                default: // only RED and ULPFEC are recognized as FEC mechanisms.
                  break;
              }
            }
          }
          SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(line => {
            description.headerExtensions.push(SDPUtils.parseExtmap(line));
          });
          // FIXME: parse rtcp.
          return description;
        };

        // Generates parts of the SDP media section describing the capabilities /
        // parameters.
        SDPUtils.writeRtpDescription = function (kind, caps) {
          let sdp = '';

          // Build the mline.
          sdp += 'm=' + kind + ' ';
          sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
          sdp += ' UDP/TLS/RTP/SAVPF ';
          sdp += caps.codecs.map(codec => {
            if (codec.preferredPayloadType !== undefined) {
              return codec.preferredPayloadType;
            }
            return codec.payloadType;
          }).join(' ') + '\r\n';

          sdp += 'c=IN IP4 0.0.0.0\r\n';
          sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

          // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
          caps.codecs.forEach(codec => {
            sdp += SDPUtils.writeRtpMap(codec);
            sdp += SDPUtils.writeFmtp(codec);
            sdp += SDPUtils.writeRtcpFb(codec);
          });
          let maxptime = 0;
          caps.codecs.forEach(codec => {
            if (codec.maxptime > maxptime) {
              maxptime = codec.maxptime;
            }
          });
          if (maxptime > 0) {
            sdp += 'a=maxptime:' + maxptime + '\r\n';
          }

          if (caps.headerExtensions) {
            caps.headerExtensions.forEach(extension => {
              sdp += SDPUtils.writeExtmap(extension);
            });
          }
          // FIXME: write fecMechanisms.
          return sdp;
        };

        // Parses the SDP media section and returns an array of
        // RTCRtpEncodingParameters.
        SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
          const encodingParameters = [];
          const description = SDPUtils.parseRtpParameters(mediaSection);
          const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
          const hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

          // filter a=ssrc:... cname:, ignore PlanB-msid
          const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
            .map(line => SDPUtils.parseSsrcMedia(line))
            .filter(parts => parts.attribute === 'cname');
          const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
          let secondarySsrc;

          const flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
            .map(line => {
              const parts = line.substr(17).split(' ');
              return parts.map(part => parseInt(part, 10));
            });
          if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
            secondarySsrc = flows[0][1];
          }

          description.codecs.forEach(codec => {
            if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
              let encParam = {
                ssrc: primarySsrc,
                codecPayloadType: parseInt(codec.parameters.apt, 10),
              };
              if (primarySsrc && secondarySsrc) {
                encParam.rtx = { ssrc: secondarySsrc };
              }
              encodingParameters.push(encParam);
              if (hasRed) {
                encParam = JSON.parse(JSON.stringify(encParam));
                encParam.fec = {
                  ssrc: primarySsrc,
                  mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
                };
                encodingParameters.push(encParam);
              }
            }
          });
          if (encodingParameters.length === 0 && primarySsrc) {
            encodingParameters.push({
              ssrc: primarySsrc,
            });
          }

          // we support both b=AS and b=TIAS but interpret AS as TIAS.
          let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
          if (bandwidth.length) {
            if (bandwidth[0].indexOf('b=TIAS:') === 0) {
              bandwidth = parseInt(bandwidth[0].substr(7), 10);
            } else if (bandwidth[0].indexOf('b=AS:') === 0) {
              // use formula from JSEP to convert b=AS to TIAS value.
              bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
                - (50 * 40 * 8);
            } else {
              bandwidth = undefined;
            }
            encodingParameters.forEach(params => {
              params.maxBitrate = bandwidth;
            });
          }
          return encodingParameters;
        };

        // parses http://draft.ortc.org/#rtcrtcpparameters*
        SDPUtils.parseRtcpParameters = function (mediaSection) {
          const rtcpParameters = {};

          // Gets the first SSRC. Note that with RTX there might be multiple
          // SSRCs.
          const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
            .map(line => SDPUtils.parseSsrcMedia(line))
            .filter(obj => obj.attribute === 'cname')[0];
          if (remoteSsrc) {
            rtcpParameters.cname = remoteSsrc.value;
            rtcpParameters.ssrc = remoteSsrc.ssrc;
          }

          // Edge uses the compound attribute instead of reducedSize
          // compound is !reducedSize
          const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
          rtcpParameters.reducedSize = rsize.length > 0;
          rtcpParameters.compound = rsize.length === 0;

          // parses the rtcp-mux attrіbute.
          // Note that Edge does not support unmuxed RTCP.
          const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
          rtcpParameters.mux = mux.length > 0;

          return rtcpParameters;
        };

        SDPUtils.writeRtcpParameters = function (rtcpParameters) {
          let sdp = '';
          if (rtcpParameters.reducedSize) {
            sdp += 'a=rtcp-rsize\r\n';
          }
          if (rtcpParameters.mux) {
            sdp += 'a=rtcp-mux\r\n';
          }
          if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {
            sdp += 'a=ssrc:' + rtcpParameters.ssrc +
              ' cname:' + rtcpParameters.cname + '\r\n';
          }
          return sdp;
        };


        // parses either a=msid: or a=ssrc:... msid lines and returns
        // the id of the MediaStream and MediaStreamTrack.
        SDPUtils.parseMsid = function (mediaSection) {
          let parts;
          const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
          if (spec.length === 1) {
            parts = spec[0].substr(7).split(' ');
            return { stream: parts[0], track: parts[1] };
          }
          const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
            .map(line => SDPUtils.parseSsrcMedia(line))
            .filter(msidParts => msidParts.attribute === 'msid');
          if (planB.length > 0) {
            parts = planB[0].value.split(' ');
            return { stream: parts[0], track: parts[1] };
          }
        };

        // SCTP
        // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back
        // to draft-ietf-mmusic-sctp-sdp-05
        SDPUtils.parseSctpDescription = function (mediaSection) {
          const mline = SDPUtils.parseMLine(mediaSection);
          const maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');
          let maxMessageSize;
          if (maxSizeLine.length > 0) {
            maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
          }
          if (isNaN(maxMessageSize)) {
            maxMessageSize = 65536;
          }
          const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
          if (sctpPort.length > 0) {
            return {
              port: parseInt(sctpPort[0].substr(12), 10),
              protocol: mline.fmt,
              maxMessageSize,
            };
          }
          const sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');
          if (sctpMapLines.length > 0) {
            const parts = sctpMapLines[0]
              .substr(10)
              .split(' ');
            return {
              port: parseInt(parts[0], 10),
              protocol: parts[1],
              maxMessageSize,
            };
          }
        };

        // SCTP
        // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers
        // support by now receiving in this format, unless we originally parsed
        // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line
        // protocol of DTLS/SCTP -- without UDP/ or TCP/)
        SDPUtils.writeSctpDescription = function (media, sctp) {
          let output = [];
          if (media.protocol !== 'DTLS/SCTP') {
            output = [
              'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\r\n',
              'c=IN IP4 0.0.0.0\r\n',
              'a=sctp-port:' + sctp.port + '\r\n',
            ];
          } else {
            output = [
              'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\r\n',
              'c=IN IP4 0.0.0.0\r\n',
              'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\r\n',
            ];
          }
          if (sctp.maxMessageSize !== undefined) {
            output.push('a=max-message-size:' + sctp.maxMessageSize + '\r\n');
          }
          return output.join('');
        };

        // Generate a session ID for SDP.
        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
        // recommends using a cryptographically random +ve 64-bit value
        // but right now this should be acceptable and within the right range
        SDPUtils.generateSessionId = function () {
          return Math.random().toString().substr(2, 21);
        };

        // Write boiler plate for start of SDP
        // sessId argument is optional - if not supplied it will
        // be generated randomly
        // sessVersion is optional and defaults to 2
        // sessUser is optional and defaults to 'thisisadapterortc'
        SDPUtils.writeSessionBoilerplate = function (sessId, sessVer, sessUser) {
          let sessionId;
          const version = sessVer !== undefined ? sessVer : 2;
          if (sessId) {
            sessionId = sessId;
          } else {
            sessionId = SDPUtils.generateSessionId();
          }
          const user = sessUser || 'thisisadapterortc';
          // FIXME: sess-id should be an NTP timestamp.
          return 'v=0\r\n' +
            'o=' + user + ' ' + sessionId + ' ' + version +
            ' IN IP4 127.0.0.1\r\n' +
            's=-\r\n' +
            't=0 0\r\n';
        };

        // Gets the direction from the mediaSection or the sessionpart.
        SDPUtils.getDirection = function (mediaSection, sessionpart) {
          // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
          const lines = SDPUtils.splitLines(mediaSection);
          for (let i = 0; i < lines.length; i++) {
            switch (lines[i]) {
              case 'a=sendrecv':
              case 'a=sendonly':
              case 'a=recvonly':
              case 'a=inactive':
                return lines[i].substr(2);
              default:
              // FIXME: What should happen here?
            }
          }
          if (sessionpart) {
            return SDPUtils.getDirection(sessionpart);
          }
          return 'sendrecv';
        };

        SDPUtils.getKind = function (mediaSection) {
          const lines = SDPUtils.splitLines(mediaSection);
          const mline = lines[0].split(' ');
          return mline[0].substr(2);
        };

        SDPUtils.isRejected = function (mediaSection) {
          return mediaSection.split(' ', 2)[1] === '0';
        };

        SDPUtils.parseMLine = function (mediaSection) {
          const lines = SDPUtils.splitLines(mediaSection);
          const parts = lines[0].substr(2).split(' ');
          return {
            kind: parts[0],
            port: parseInt(parts[1], 10),
            protocol: parts[2],
            fmt: parts.slice(3).join(' '),
          };
        };

        SDPUtils.parseOLine = function (mediaSection) {
          const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
          const parts = line.substr(2).split(' ');
          return {
            username: parts[0],
            sessionId: parts[1],
            sessionVersion: parseInt(parts[2], 10),
            netType: parts[3],
            addressType: parts[4],
            address: parts[5],
          };
        };

        // a very naive interpretation of a valid SDP.
        SDPUtils.isValidSDP = function (blob) {
          if (typeof blob !== 'string' || blob.length === 0) {
            return false;
          }
          const lines = SDPUtils.splitLines(blob);
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
              return false;
            }
            // TODO: check the modifier a bit more.
          }
          return true;
        };

        // Expose public methods.
        if (true) {
          module.exports = SDPUtils;
        }


        /***/
      }),
/* 56 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.Call = void 0;
        var tslib_1 = __webpack_require__(1);
        var C = tslib_1.__importStar(__webpack_require__(3));
        var JsSIP = tslib_1.__importStar(__webpack_require__(4));
        var Debug_1 = __webpack_require__(2);
        var events_1 = __webpack_require__(13);
        var FloorControl_1 = __webpack_require__(57);
        var MediaHandler_1 = __webpack_require__(60);
        var Participant_1 = __webpack_require__(58);
        var Participants_1 = __webpack_require__(68);
        var Utils_1 = __webpack_require__(59);
        /**
         * @internal
         */
        var LOGD = Debug_1.Debugger.extend('Call');
        /**
         * @internal
         */
        var LOGE = Debug_1.Debugger.extend('ERROR:Call');
        /**
         * @public
         *
         * Class handing a SWSIPVOIP2 Call.
         *
         * @remarks About events:
         * Events raised by the call can be devided into categories and subcategories.
         * They are defined by the event type and subtype. A user can decide to subscriber to
         * an entire category, or a subset of it:
         * @example
         * ```
         * call.on('<type>', (e) => {....}); // subscribe to all '<type>' events
         * call.on('<type>:<subtype>', (e) => {....}); // subscribe to '<type>:<subtype>' only
         * ```
         */
        var Call = /** @class */ (function (_super) {
          tslib_1.__extends(Call, _super);
          function Call(ua, options) {
            var _this = _super.call(this) || this;
            _this.mCseq = 0;
            _this.mNbDisconnection = 0;
            _this.mFailedReason = Call.FailedReason.SUCCESS;
            _this.mIsAnEmergencyCall = false;
            _this.mIsOnHold = false;
            _this.mStopRequested = false;
            _this.mNumberOfReconnectionAttempts = 0;
            _this.mParticipants = new Participants_1.Participants();
            /**
             * @returns the reason why the call has failed. SUCCESS if the call hasn't failed
             */
            _this.getError = function () { return _this.mFailedReason; };
            /**
             * @returns the reason why the call has stopped. undefined if the call hasn't stopped yet
             */
            _this.getStoppedReason = function () { return _this.mStoppedReason; };
            /**
             * retrieve the current floor owner, if any
             * @returns the msisdn\@fqdn of the floor owner, or null if no one is the floor owner
             */
            _this.getFloorOwner = function () { return _this.mFloorControl.getFloorOwner(); };
            /**
             * retrieve the current floor owner, or the previous floor owner if the floor is currently idle
             * @returns the msisdn\@fqdn of the floor owner, or null if no one took the floor, ever
             */
            _this.getFloorOwnerLast = function () { return _this.mFloorControl.getFloorOwnerLast(); };
            /**
             * retrieve the updated floor owner identity, if any
             * This is to be used when integrating with a 3GPP gateway: sometimes, those updates the identity
             * of the floor owner after the floor is granted to it. This function provides this identity, to be called after
             * {@link (FloorControl:namespace).Event.EXT_FLOOR_OWNER_USER_ID_UPDATE} event
             * @returns the updated identity of the floor owner
             */
            _this.getFloorOwnerExtUserIdUpdated = function () { return _this.mFloorControl.getFloorOwnerExtUserIdUpdated(); };
            /**
             * @returns the floor local state
             */
            _this.getFloorState = function () { return _this.mFloorControl.getFloorState(); };
            /**
             * @returns the previous floor local state
             */
            _this.getPreviousFloorState = function () { return _this.mFloorControl.getPreviousFloorState(); };
            /**
             * @returns the duration for which the floor was granted, undefined if no duration was provided
             */
            _this.getFloorGrantedDuration = function () { return _this.mFloorControl.getFloorGrantedDuration(); };
            /**
             * @returns the floor deny reason, if any, UNKNOWN otherwise
             */
            _this.getFloorDenyReason = function () { return _this.mFloorControl.getFloorDenyReason(); };
            /**
             * @returns the floor revoke reason, if any, UNKNOWN otherwise
             */
            _this.getFloorRevokeReason = function () { return _this.mFloorControl.getFloorRevokeReason(); };
            /**
             * has permission to request floor? The server allows the client to request floor even though
             * there's already a floor owner (getFloorOwner() != null). Typically when the client
             * has a higher priority than the current floor owner
             * @returns true if the client can request floor, false otherwise
             */
            _this.hasPermissionToRequestFloor = function () { return _this.mFloorControl.hasPermissionToRequestFloor(); };
            /**
             * @returns the options that were provided to the constructor
             */
            _this.getOptions = function () { return _this.mOptions; };
            /**
             * @returns the localId that was initially provided in
             * Call.options given to the constructor
             */
            _this.getLocalId = function () { return _this.mLocalId; };
            /**
             * @returns the sesssion Id
             */
            _this.getSessionId = function () {
              return _this.mSessionId ? _this.mSessionId : _this.mOptions.sessionId;
            };
            /**
             * @returns the swto
             */
            _this.getSwTo = function () { return _this.mOptions.swTo; };
            /**
             * @returns the sesssion Type
             */
            _this.getSessionType = function () {
              return _this.mSessionType ? _this.mSessionType : _this.mOptions.sessionType;
            };
            /**
             * @returns the sesssion Media
             */
            _this.getSessionMedia = function () {
              return _this.mSessionMedia ? _this.mSessionMedia : _this.mOptions.sessionMedia;
            };
            /**
             * @returns the sesssion goup id
             */
            _this.getSessionGroupId = function () {
              return _this.mSessionGroupId ? _this.mSessionGroupId : _this.mOptions.sessionGroupId;
            };
            /**
             * @returns true if the call is a channel
             */
            _this.isAChannel = function () { var _a; return _this.mSessionType === Call.SessionType.WALKIETALKIE && ((_a = _this.mSessionId) === null || _a === void 0 ? void 0 : _a.indexOf('group:')) !== -1; };
            /**
             * @returns true if the session is large group (ie no participant event will be received)
             */
            _this.isLargeGroup = function () { return !!_this.mLargeGroupCount; };
            /**
             * @returns true if the session is emergency call
             */
            _this.isEmergencyCall = function () { return _this.mIsAnEmergencyCall; };
            /**
             * @returns the msisdnatfqdn of the subscriber that triggered the emergency
             */
            _this.getEmergencyInitiator = function () { return _this.mEmergencyInitiator; };
            /**
             * @returns true if the call has an audio channel
             */
            _this.isAudio = function () {
              var media = _this.getSessionMedia();
              return media ? (media.includes(Call.SessionMedia.AUDIO)) : false;
            };
            /**
             * @returns true if the call has a video channel
             */
            _this.isVideo = function () {
              var media = _this.getSessionMedia();
              return media ? (media.includes(Call.SessionMedia.VIDEO)) : false;
            };
            /**
             * @returns true if the call sends and receives media
             */
            _this.sendsAndReceives = function () {
              return _this.mOptions.sessionType !== Call.SessionType.LIVESTREAM;
            };
            /**
             * @returns true if the call only receives media (no send)
             */
            _this.receivesOnly = function () {
              return _this.mOptions.sessionType === Call.SessionType.LIVESTREAM
                && (!!_this.mOptions.sessionId || (!!_this.mOptions.swTo && _this.mOptions.swTo.includes('camera:')));
            };
            /**
             * @returns true if the call only sends media (no receive)
             */
            _this.sendsOnly = function () {
              return _this.mOptions.sessionType === Call.SessionType.LIVESTREAM
                && !_this.mOptions.sessionId && !(!!_this.mOptions.swTo && _this.mOptions.swTo.includes('camera:'));
            };
            /**
             * Retrieves the list of participants in the session, in an hashmap that sorts the msisdn
             * according to their current state ({@link (Participant:namespace).State} for the list). If a specific state
             * is provided, only the participant in this state are returned. If ALL_PARTICIPANT is provided,
             * all known participants are returned.
             * @param state - the state for which we want to get the participants
             * @returns hashamp of Participant.State to an array of String containing the msisdn of the participants
             */
            _this.getParticipants = function (state) {
              return _this.mParticipants.getByState(state);
            };
            /**
             * Retrieves the list of newly arrived participants in the session, in an hashmap that sorts the msisdn
             * according to their current state ({@link (Participant:namespace).State} for the list). If a specific state
             * is provided, only the participant in this state are returned. If ALL_PARTICIPANT is provided,
             * all known participants are returned.
             * "new" participants are participants that were never obtained through sw_participants_get,
             *  2 consecutive calls to this function with only_new set to true gets you 2 different results:
             *     - first one with all the "new" participants
             *     - second with empty lists
             * @param state - the states for which we want to get the participants
             * @returns hashamp of Participant.State to an array of String containing the msisdn of the participants
             */
            _this.getNewParticipants = function (state) {
              return _this.mParticipants.getByState(state);
            };
            /**
             * gets an array containing the group names matching the group id this call is related to.
             * This includes groups set as destination in {@link (Call:namespace).Options.swTo}.
             * Group names are indexed by their ID.
             * @returns the group names
             */
            _this.getGroupNames = function () { return _this.mGroupNames; };
            /**
             * gets an array of msisdnatfqdn and groups. This is the current {@link (Call:namespace).Options.swTo}.
             * @returns the group users list
             */
            _this.getGroupUsersList = function () { return _this.mGroupUsersList; };
            /**
             * gets the list of added users after the server processed an inviteNewParticipants request
             * @returns the group added users
             */
            _this.getGroupAddedUsers = function () { return _this.mGroupAddedUsers; };
            /**
             * Gets the reception time
             * @returns the date
             */
            _this.getReceptionTime = function () { return _this.mReceptionTime; };
            /**
             * Retrieves the state of the participant which msisdn at fqdn is provided
             * @param msisdn - the identity of the participant (msisdn alone, or msisdn\@fqdn)
             * @returns the state, Participant.State.UNKNOWN if the subscriber could not be found
             */
            _this.getParticipantState = function (msisdn) {
              var part = _this.mParticipants.get(msisdn);
              return part ? part.getState() : Participant_1.Participant.State.UNKNOWN;
            };
            /**
             * Retrieves the previous state of the participant which msisdn at fqdn is provided
             * @param msisdn - the identity of the participant (msisdn alone, or msisdn\@fqdn)
             * @returns the state, Participant.State.UNKNOWN if the subscriber could not be found
             */
            _this.getParticipantPreviousState = function (msisdn) {
              var part = _this.mParticipants.get(msisdn);
              return part ? part.getPreviousState() : Participant_1.Participant.State.UNKNOWN;
            };
            /**
             * Retrieves the floor priority of the participant which msisdn at fqdn is provided
             * @param msisdn - the identity of the participant (msisdn alone, or msisdn\@fqdn)
             * @returns the priority, 0 if the subscriber could not be found
             */
            _this.getParticipantFloorPriority = function (msisdn) {
              var part = _this.mParticipants.get(msisdn);
              return part ? part.getFloorPriority() : 0;
            };
            /**
             * Retrieves the arrival time of the participant which msisdn at fqdn is provided
             * @param msisdn - the identity of the participant (msisdn alone, or msisdn\@fqdn)
             * @returns the arrival time, undefined if the subscriber could not be found
             */
            _this.getParticipantArrivalTime = function (msisdn) {
              var part = _this.mParticipants.get(msisdn);
              return part === null || part === void 0 ? void 0 : part.getArrivalTime();
            };
            /**
             * Retrieves the video capture source of the participant which msisdn at fqdn is provided
             * @param msisdn - the identity of the participant (msisdn alone, or msisdn\@fqdn)
             * @returns the video capture source, undefined if the subscriber could not be found
             */
            _this.getParticipantVideoCaptureSource = function (msisdn) {
              var part = _this.mParticipants.get(msisdn);
              return part === null || part === void 0 ? void 0 : part.getVideoCaptureSource();
            };
            /**
             * Retrieves the msisdn at fqdn of the last updated participant
             * @returns the identity of the last updated participant
             */
            _this.getLastUpdatedParticipant = function () { var _a; return (_a = _this.mParticipants.getLastUpdated()) === null || _a === void 0 ? void 0 : _a.getDisplayName(); };
            /**
             * Checks if the provided participant is from an interas regroup
             * @param contact - the identity of the participant
             * @returns true if the subscriber is from interas regroup
             */
            _this.isParticipantFromInterASRegroup = function (contact) {
              var part = _this.mParticipants.get(contact);
              return part ? part.isFromInterASRegroup() : false;
            };
            /**
             * Retrieves the msisdn at fqdn of the transferor
             * @returns the identity of the transferor
             */
            _this.getTransferor = function () {
              return _this.mTransferor;
            };
            /**
             * Retrieves the Ids of the merge session, if any
             * @returns the merged session ids
             */
            _this.getMergedSessionIds = function () {
              return _this.mMergedSessionIds;
            };
            /**
             * Sets the rendering elements used by the Call to play local and remote streams
             * @param options - the Play options
             * @returns true if everything went well, false otherwise
             */
            _this.setPlayOptions = function (options) {
              if (options.rendererLocal) {
                _this.mOptions.playOptions.rendererLocal = options.rendererLocal;
              }
              if (options.rendererRemote) {
                _this.mOptions.playOptions.rendererRemote = options.rendererRemote;
              }
              if (!_this.mMediaHandler) {
                return false;
              }
              return _this.mMediaHandler.setPlayOptions(_this.mOptions.playOptions);
            };
            /**
             * @returns the value of the current local volume, in dB range [-127, 0]
             */
            _this.getMediaVolumeLocal = function () { return _this.mMediaHandler.getVolumeLocal(); };
            /**
             * @returns the value of the current remote volume, in dB range [-127, 0]
             */
            _this.getMediaVolumeRemote = function () { return _this.mMediaHandler.getVolumeRemote(); };
            /**
             * @returns Blob containing the last local record
             */
            _this.getRecordLocal = function () { return _this.mMediaHandler.getRecordLocal(); };
            /**
             * @returns the duration of the last local record, in ms
             */
            _this.getRecordDurationLocal = function () { return _this.mMediaHandler.getRecordDurationLocal(); };
            /**
             * @returns Blob containing the last remote record
             */
            _this.getRecordRemote = function () { return _this.mMediaHandler.getRecordRemote(); };
            /**
             * @returns the duration of the last remote record, in ms
             */
            _this.getRecordDurationRemote = function () { return _this.mMediaHandler.getRecordDurationRemote(); };
            /**
             * @returns an integer which possible values are:
             *    - 5: very good: no network problem. - clear sound
             *    - 4: good: a little of packet loss and/or little jitter - ok sound, but could be better
             *    - 3: medium: more packet loss and/or jitter - distortions and/or small gaps.
             *    - 2: bad: strong packet loss and/or jitter - heavy distortions and/or big gapes
             *    - 1: very bad: the stack fails to receive reports from the remote participant - no sound
             *    - 0: N/A: not supposed to get an indicator
             */
            _this.getMediaQos = function () { return _this.mMediaHandler.getQos(); };
            /**
             * Opens a popup, showing the states of up and down streams
             * @remarks
             * this should be used for debug only, or as an easter egg ;)
             */
            _this.openMediaStatsWindow = function () { return _this.mMediaHandler.openMediaStatsWindow(); };
            /**
             * Set the audio to be played on one of the following
             * @param c - the audio channel
             */
            _this.setAudioPlayChannel = function (c) { return _this.mMediaHandler.setAudioPlayPanning(c); };
            /**
             * Starts the call
             *
             * What this function does:
             * - get a subscriber token if the a promise was provided to {@link (Call:namespace).Options}.
             * - get a mediastream if needed, according to the parameters in {@link (Call:namespace).Options}
             * - sends an SIP INVITE. Upon reception of a response, the event {@link (Call:namespace).Event.STARTED}
             *   is raised if everything went fine, {@link (Call:namespace).Event.FAILED} otherwise.
             *   Check {@link (Call:class).getError} to know why
             */
            _this.start = function () {
              // TODO: Add listners on UA's connect/disconnect if ua isn't connected yet
              if (_this.mOptions.getSubscriberToken && !_this.mSubscriberToken) {
                _this.mOptions.getSubscriberToken()
                  .then(function (token) {
                    if (!token) {
                      throw new Error('Invalid empty token');
                    }
                    _this.mSubscriberToken = token;
                    LOGD("".concat(_this.toString(), " Got susbcriber token"));
                    _this.start();
                  }).catch(function (err) {
                    var e = err;
                    LOGE("".concat(_this.toString(), " Error while getting subscriber token, aborting: ").concat(e.message));
                    LOGE(e.stack);
                    if (_this.mNbDisconnection) {
                      setTimeout(function () { return _this.start(); }, 1000);
                    }
                    else {
                      _this.mFailedReason = Call.FailedReason.COULD_NOT_GET_TOKEN;
                      _this.newEvent(Call.Event.FAILED);
                      _this.stop();
                      _this.stopJssipUa();
                      _this.newEvent(Call.Event.STOPPED);
                    }
                  });
                return;
              }
              var mediaStream = _this.mOptions.mediaStream || _this.mMediaHandler.getMediaStreamLocal();
              if (!_this.receivesOnly() && !mediaStream) {
                var mediaHandlerOptions = {
                  audio: _this.mOptions.sessionMedia.includes(Call.SessionMedia.AUDIO),
                  video: _this.mOptions.sessionMedia.includes(Call.SessionMedia.VIDEO)
                };
                _this.mMediaHandler.getMediaStream(mediaHandlerOptions)
                  .then(function (ms) {
                    LOGD("".concat(_this.toString(), " Got mediastream: ").concat(Utils_1.Utils.strMediaStream(ms)));
                    _this.mMediaHandler.setMediaStreamLocal(ms);
                    _this.start();
                  }).catch(function (err) {
                    var e = err;
                    LOGE("".concat(_this.toString(), " Error while getting mediastream, aborting: ").concat(e.message));
                    LOGE(e.stack);
                    _this.mFailedReason = Call.FailedReason.COULD_NOT_GET_MEDIASTREAM;
                    _this.newEvent(Call.Event.FAILED);
                    _this.stop();
                    _this.stopJssipUa();
                    _this.newEvent(Call.Event.STOPPED);
                  });
                return;
              }
              LOGD("".concat(_this.toString(), " Using mediastream: ").concat(Utils_1.Utils.strMediaStream(mediaStream)));
              var onConnected = function () { return _this.start(); };
              var onConnectionError = function () {
                if (_this.mNumberOfReconnectionAttempts !== 0) {
                  _this.newEvent(Call.Event.DISCONNECTED_AND_RECONNECTING);
                  _this.mNumberOfReconnectionAttempts++;
                  LOGD("UA ".concat(_this.mUa.toString(), " is still not connected, ").concat(_this.toString(), " ")
                    + "number of reconnection attempts: ".concat(_this.mNumberOfReconnectionAttempts));
                  return;
                }
                _this.mFailedReason = Call.FailedReason.CONNECTION_ERROR;
                _this.newEvent(Call.Event.FAILED);
                _this.stop();
                _this.stopJssipUa();
                _this.newEvent(Call.Event.STOPPED);
              };
              if (!_this.mUa.isConnected()) {
                LOGD("UA ".concat(_this.mUa.toString(), " is still not connected, ").concat(_this.toString(), " ")
                  + 'will wait for it to actually connect before proceeding');
                _this.mUa.addConnectionEventListeners(onConnected, onConnectionError);
                return;
              }
              _this.mUa.removeConnectionEventListeners(onConnected, onConnectionError);
              var transport = _this.mUa.getTransport();
              var uaOptions = _this.mUa.getOptions();
              var configuration = {
                uri: _this.mOptions.subscriberMsisdn + '@' + uaOptions.host + ':' + uaOptions.port,
                sockets: [transport],
                register: false,
                user_agent: C.USER_AGENT,
                session_timers: false
              };
              _this.mJssipUa = new JsSIP.UA(configuration);
              _this.mJssipUa.start();
              var isReceiverOnly = _this.receivesOnly();
              var isSenderOnly = _this.sendsOnly();
              var mediaConstraints = {};
              var rtcOfferConstraints = {};
              if (_this.isAudio()) {
                rtcOfferConstraints.offerToReceiveAudio = !isSenderOnly;
                mediaConstraints.audio = !isReceiverOnly;
              }
              if (_this.isVideo()) {
                rtcOfferConstraints.offerToReceiveVideo = !isSenderOnly;
                mediaConstraints.video = !isReceiverOnly;
              }
              var userAgentCallOptions = {
                mediaStream: mediaStream,
                mediaConstraints: mediaConstraints,
                // rtcConstraints?: any;
                extraHeaders: _this.getInviteExtraHeaders(),
                pcConfig: {
                  iceServers: []
                },
                rtcOfferConstraints: rtcOfferConstraints
              };
              _this.mJssipUa.on('connecting', function (ev) {
                LOGD("".concat(_this.toString(), " Connecting to: ").concat(ev.socket.sip_uri));
              });
              _this.mJssipUa.on('connected', function (ev) {
                LOGD("".concat(_this.toString(), " Connected to: ").concat(ev.socket.sip_uri));
                if (_this.mNumberOfReconnectionAttempts) {
                  _this.start();
                }
              });
              _this.mJssipUa.on('disconnected', function (ev) {
                var _a;
                if (_this.mStopRequested) {
                  return;
                }
                LOGD("".concat(_this.toString(), " Disconnected from: ").concat(ev.socket.sip_uri));
                var session = _this.mMediaHandler.getRtcSession();
                session === null || session === void 0 ? void 0 : session.off('accepted', _this.onAccepted);
                session === null || session === void 0 ? void 0 : session.off('ended', _this.onEnded);
                session === null || session === void 0 ? void 0 : session.off('failed', _this.onFailed);
                _this.mMediaHandler.destroyConnectionToRemote();
                (_a = _this.mJssipUa) === null || _a === void 0 ? void 0 : _a.terminateSessions();
                _this.newEvent(Call.Event.DISCONNECTED_AND_RECONNECTING);
                _this.mNumberOfReconnectionAttempts++;
                _this.start();
              });
              _this.mJssipUa.on('newRTCSession', _this.onNewRtcSession);
              _this.mJssipUa.on('newMessage', _this.onMessage);
              _this.mJssipUa.call(_this.mUri.toString(), userAgentCallOptions);
            };
            /**
             * Stops the call
             *
             * The call is actually ended when the event {@link (Call:namespace).Event.STOPPED} is raised
             */
            _this.stop = function () {
              _this.mMediaHandler.destroy();
              _this.mStopRequested = true;
              if (!_this.mJssipUa) {
                return false;
              }
              var options = {
                extraHeaders: [
                  'SWReason: ' + Call.Hangup.USER_HANGUP
                ]
              };
              _this.mJssipUa.terminateSessions(options);
              return true;
            };
            /**
             * @returns an MediaOptions object containing which component is muted
             * if the call is currently muted (ie sends no media)
             * Note it returns true if the call is onhold
             */
            _this.isMuted = function () { return _this.mMediaHandler.isMutedCapture(); };
            /**
             * Makes the call mute itself: send no more media
             * Note this has no effect if the call is already onhold
             * @param options - an MediaOptions object containing which component to mute
             * @returns true if the call managed to mute itself
             */
            _this.mute = function (options) {
              return _this.mIsOnHold || _this.mMediaHandler.muteCapture(options);
            };
            /**
             * Makes the call unmute itself: send media
             * Note this has no effect if the call is already onhold
             * @param options - an MediaOptions object containing which component to unmute
             * @returns true if the call managed to unmute itself
             */
            _this.unmute = function (options) {
              return _this.mIsOnHold || _this.mMediaHandler.unmuteCapture(options);
            };
            /**
             * @returns an MediaOptions object containing which component is muted
             * if the call currently muted play (ie plays no media)
             */
            _this.isPlayMuted = function () { return _this.mMediaHandler.isMutedPlay(); };
            /**
             * Makes the call mute itself: stop playing media
             * Note this has no effect if the call is already onhold
             * @param options - an MediaOptions object containing which component to mute
             * @returns true if the call managed to mute play
             */
            _this.mutePlay = function (options) {
              var floorOwner = _this.mFloorControl.getFloorOwner();
              if (floorOwner) {
                LOGD("".concat(_this.toString(), " muting audio while floor is taken by ").concat(floorOwner));
              }
              return _this.mIsOnHold || _this.mMediaHandler.mutePlay(options);
            };
            /**
             * Makes the call unmute itself: resume playing media
             * Note this has no effect if the call is already onhold
             * @param options - an MediaOptions object containing which component to unmute
             * @returns true if the call managed to unmute play
             */
            _this.unmutePlay = function (options) {
              return _this.mIsOnHold || _this.mMediaHandler.unmutePlay(options);
            };
            /**
             * sets the volume of the played audio, if any. This function has
             * no effects on video only calls.
             * Note that
             *  * @example
             * ```
             * setPlayVolume(0)
             * ```
             * should have the same functional result as
             * ```
             * mutePlay({audio: true})
             * ```
             * however, they are implemented differently:
             * the former sets the volume of the HTML element that was initially
             * provided in PlayOptions, while the former actually disable the track
             * of the RTCPeerConnection receiver.
             * @param volume - the volume value, possible range: [0 1]
             * @returns true if the volume could be set, false otherwise
             */
            _this.setPlayVolume = function (volume) {
              return _this.mMediaHandler.setPlayVolume(volume);
            };
            /**
             * whether or not the call is on hold
             * @returns true if the call is on hold, false otherwise
             */
            _this.isOnHold = function () { return _this.mIsOnHold; };
            /**
             * whether or not the other participants are on hold
             * @returns true if all the other participants are currently on hold
             */
            _this.areOthersOnHold = function () {
              return _this.mParticipants.count([Participant_1.Participant.State.ATTENDING]) <= 1
                && _this.mParticipants.count([Participant_1.Participant.State.ATTENDING_ONHOLD]) > 0;
            };
            /**
             * mute both speakers and mics: the call sends no more media nor plays any incoming stream
             * the client sends a request to the server so all other participants are aware it is on hold
             * @returns true if it manages to go on hold
             */
            _this.putOnHold = function () {
              if (_this.mIsOnHold) {
                LOGD("".concat(_this.toString(), " is already on hold"));
                return true;
              }
              _this.mIsOnHold = true;
              _this.mMediaHandler.muteCapture();
              _this.mMediaHandler.mutePlay();
              return _this.sendServiceMessage('RequestOnHold');
            };
            /**
             * unmute both speakers and mics: the call sends media and plays any incoming stream
             * the client sends a request to the server so all other participants are aware it resumed the call
             * @returns true if it manages to resume
             */
            _this.resume = function () {
              if (!_this.mIsOnHold) {
                LOGD("".concat(_this.toString(), " is already on not hold"));
                return true;
              }
              _this.mIsOnHold = false;
              _this.mMediaHandler.unmuteCapture();
              _this.mMediaHandler.unmutePlay();
              return _this.sendServiceMessage('RequestResume');
            };
            /**
             * make the call invite new participants (subscribers or groups)
             * @param swto - contains the list of invited subscribers/groups, all separated by a comma:
             *                - subscribers: "msisdn\@fqdn"
             *                - groups: groupId:"groupId"
             *                - example; 1111111111\@1.2.3.4,1111112222\@1.2.3.4,group:1
             * @param swout - contains the list of invited callees, all separated by a comma:
             *                - subscribers: "msisdn"
             *                - example; 33100000001,33100000002
             * @param newSessionGroupId - contains the new session group id. This new session group id will be pushed
             *                          to all participants along with the newly invited participants
             *                          if the invitation goes through
             * @returns true if it managed to send the invitation
             */
            _this.inviteNewParticipants = function (newSwto, newSwout, newSessionGroupId) {
              if (!_this.mJssipUa || (!newSwto && !newSwout)) {
                return false;
              }
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD("".concat(_this.toString(), " could successfully invite new Participants"));
                    _this.newEvent(Call.Event.SESSION_SUBSCRIBER_INVITATION_OK);
                  }
                },
                failed: function (ev) {
                  _this.received500Error(ev.response);
                  _this.newEvent(Call.Event.SESSION_SUBSCRIBER_INVITATION_NOK);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: SERVICE',
                  'ServiceMessageType: VoipSessionInviteNewSubscriber'
                ]
              };
              if (newSwto && options.extraHeaders) {
                options.extraHeaders.push('swto: ' + newSwto);
              }
              if (newSwout && options.extraHeaders) {
                options.extraHeaders.push('swout: ' + newSwout);
              }
              if (newSessionGroupId && options.extraHeaders) {
                options.extraHeaders.push('SessionGroupId: ' + newSessionGroupId);
              }
              _this.mJssipUa.sendMessage(_this.mUri, '', options);
              return true;
            };
            /**
             * make the stack transfer the call to a target participant
             * @param swto - contain the target "msisdn\@fqdn"
             * @param swout - contains the target "msisdn"
             * @returns true if it managed to send the invitation
             */
            _this.transfer = function (swto, swout) {
              if (!_this.mJssipUa || (!swto && !swout)) {
                return false;
              }
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD(_this.toString() + ' could successfully invite new Participants');
                    _this.newEvent(Call.Event.SESSION_TRANSFER_OK);
                  }
                },
                failed: function (ev) {
                  _this.received500Error(ev.response);
                  _this.newEvent(Call.Event.SESSION_TRANSFER_NOK);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: SERVICE',
                  'ServiceMessageType: VoipSessionTransfer'
                ]
              };
              if (swto && options.extraHeaders) {
                options.extraHeaders.push('swto: ' + swto);
              }
              if (swout && options.extraHeaders) {
                options.extraHeaders.push('swout: ' + swout);
              }
              _this.mJssipUa.sendMessage(_this.mUri, '', options);
              return true;
            };
            /**
             * make the stack update the call
             * @param updateParameters - the update parameters
             * @returns true if it managed to send the update
             */
            _this.update = function (updateParameters) {
              if (!_this.mJssipUa) {
                return false;
              }
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD(_this.toString() + ' could successfully update the session');
                    _this.newEvent(Call.Event.SESSION_UPDATE_OK);
                  }
                },
                failed: function (ev) {
                  _this.received500Error(ev.response);
                  _this.newEvent(Call.Event.SESSION_UPDATE_NOK);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: SERVICE',
                  'ServiceMessageType: VoipSessionUpdate'
                ]
              };
              if (updateParameters.isEmergencyCall !== undefined && options.extraHeaders) {
                options.extraHeaders.push('isEmergencyCall: ' + String(updateParameters.isEmergencyCall));
              }
              _this.mJssipUa.sendMessage(_this.mUri, '', options);
              return true;
            };
            /**
             * Kicks the participants in swTo. Only participants invited by the caller can be kicked.
             *
             * @param swTo - The list of callees to kick. This is a list of MSISDN\@FQDN and group:id separated by commas.
             * @returns true if everything went fine
             */
            _this.kickInvitedParticipants = function (swTo) {
              return _this.sendServiceMessage('VoipSessionKickInvitedParticipants', ['swto: ' + swTo]);
            };
            /**
             * send a participant list request. The caller has to wait for
             * the {@link (Participant:namespace).Event.PARTICIPANT_LIST} event
             * to actually get the participant list
             * @returns true if it manages to send the participant list
             */
            _this.requestParticipantList = function () {
              if (!_this.mJssipUa) {
                return false;
              }
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD("RequestParticipantList has been successfully executed: ".concat(ev.response.status_code));
                    var pl = ev.response.getHeader('ParticipantList');
                    var list = JSON.parse(Utils_1.Utils.stripslashes(pl.substring(1, pl.length - 1)));
                    _this.onServiceMessageParticipantList(list);
                  }
                  else {
                    LOGD('RequestParticipantList succeeded without body?');
                  }
                },
                failed: function (ev) {
                  _this.received500Error(ev.response);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: SERVICE',
                  'ServiceMessageType: RequestParticipantList'
                ]
              };
              _this.mJssipUa.sendMessage(_this.mUri, '', options);
              return true;
            };
            /**
             * Enqueues a Floor Request: claim the floor in PoC sessions
             * @returns true if the call managed to sends the request, false otherwise
             */
            _this.requestFloor = function () { return _this.mFloorControl.requestFloor(); };
            /**
             * Enqueues a Floor Release: release the floor in PoC sessions once it has been seized
             * @returns true if the call managed to sends the request, false otherwise
             */
            _this.releaseFloor = function () { return _this.mFloorControl.releaseFloor(); };
            _this.enqueueDtmf = function (dtmf) { return _this.mMediaHandler.enqueueDtmf(dtmf); };
            /**
             * @returns a Human readable version of the call instance
             */
            _this.toString = function () {
              var str = "Session #".concat(_this.mInstanceId, " ");
              str += "[sessionId: ".concat(_this.getSessionId() || '?', "] ");
              str += "[sessionType: ".concat(_this.getSessionType() || '?', "] ");
              str += "[sessionMedia: ".concat(_this.getSessionMedia() || '?', "] ");
              if (_this.mOptions.localId) {
                str += "[localId: ".concat(_this.mOptions.localId, "]");
              }
              return str;
            };
            _this.newEvent = function (type, subtype) {
              var ev = {
                type: type,
                subtype: subtype,
                call: _this
              };
              // idiot proofing event emission: use try...catch block because there may be unhandled errors in there
              try {
                _this.emit(ev.type, ev);
                if (ev.subtype) {
                  _this.emit(ev.type + ':' + ev.subtype, ev);
                }
              }
              catch (e) {
                var error = e;
                var typeSubstype = ev.type + (ev.subtype ? (':' + ev.subtype) : '');
                LOGE("".concat(_this.toString(), ": error in caller while handling event ").concat(typeSubstype, ": ").concat(error.message));
                LOGE(error.stack);
              }
            };
            _this.isWalkieTalkie = function () { return _this.mOptions.sessionType === Call.SessionType.WALKIETALKIE; };
            _this.onNewRtcSession = function (ev) {
              _this.mMediaHandler.setRtcSession(ev.session);
              ev.session.on('accepted', _this.onAccepted);
              ev.session.on('ended', _this.onEnded);
              ev.session.on('failed', _this.onFailed);
            };
            _this.onAccepted = function (ev) {
              LOGD("".concat(_this.toString(), " onAccepted"));
              if (_this.parseheaders(ev.response)) {
                _this.newEvent(Call.Event.STARTED);
              }
              else {
                LOGE("".concat(_this.toString(), " Failed to parse headers"));
              }
              if (_this.getSessionType() === Call.SessionType.WALKIETALKIE
                && _this.mFloorControl.getFloorState() !== FloorControl_1.FloorControl.State.HAS_PERMISSION) {
                _this.mMediaHandler.muteCapture();
              }
              //        this.mMediaHandler.setEncoderParameters();
            };
            _this.onEnded = function (ev) {
              LOGD("".concat(_this.toString(), " onEnded: ").concat(ev.cause));
              switch (ev.cause) {
                case JsSIP.C.causes.BYE:
                  if (ev.originator === 'local') {
                    _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_SENT;
                    LOGD("".concat(_this.toString(), " Call ended by sending a BYE"));
                  }
                  else if (ev.message) {
                    var byeReason = ev.message.getHeader('bye_reason');
                    switch (byeReason) {
                      case 'END_REASON_GROUP_REMOVED':
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED_GROUP_REMOVED;
                        break;
                      case 'END_REASON_CALL_REPLACED':
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED_CALL_REPLACED;
                        break;
                      case 'END_REASON_INITIATOR_LEFT':
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED_INITIATOR_LEFT;
                        break;
                      case 'END_REASON_NOT_ALLOWED':
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED_NOT_ALLOWED;
                        break;
                      case 'END_REASON_HANG_TIME':
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED_HANG_TIME;
                        break;
                      case 'END_REASON_TERMINATED':
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED_TERMINATED;
                        break;
                      default:
                        LOGD("".concat(_this.toString(), " Received a BYE with unknown reason: ").concat(byeReason));
                        _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED;
                        break;
                    }
                    LOGD("".concat(_this.toString(), " Call ended with reason: ").concat(_this.mStoppedReason));
                  }
                  else {
                    _this.mStoppedReason = Call.StoppedReason.STOPPED_BYE_RECEIVED;
                    LOGD("".concat(_this.toString(), " Call ended without a reason given by backend"));
                  }
                  _this.newEvent(Call.Event.STOPPED);
                  break;
              }
              _this.stopJssipUa();
              _this.stop();
            };
            _this.onFailed = function (ev) {
              LOGD("".concat(_this.toString(), " onFailed: ").concat(ev.cause));
              switch (ev.cause) {
                case JsSIP.C.causes.SIP_FAILURE_CODE:
                  _this.received500Error(ev.message);
                  break;
                default:
                  _this.mFailedReason = Call.FailedReason.INTERNAL_SERVER_ERROR;
                  break;
              }
              _this.newEvent(Call.Event.FAILED);
              _this.stop();
              _this.stopJssipUa();
              _this.newEvent(Call.Event.STOPPED);
            };
            _this.stopJssipUa = function () {
              if (_this.mJssipUa) {
                _this.mJssipUa.stop();
                delete _this.mJssipUa;
              }
            };
            _this.getInviteExtraHeaders = function () {
              var extraHeaders = [];
              if (_this.mSubscriberToken) {
                extraHeaders[extraHeaders.length] = "token: ".concat(_this.mSubscriberToken);
                delete _this.mSubscriberToken;
              }
              else if (_this.mOptions.subscriberPassword) {
                extraHeaders[extraHeaders.length] = "password: ".concat(_this.mOptions.subscriberPassword);
              }
              var getInviteExtraHeadersJoinSessionId = function () {
                if (_this.mOptions.sessionId) {
                  extraHeaders[extraHeaders.length] = "sessionid: ".concat(_this.mOptions.sessionId);
                }
                if (_this.mOptions.synchronizeWithOtherDevices) {
                  extraHeaders[extraHeaders.length] = 'synchronizewithotherdevices: true';
                }
              };
              if (_this.mOptions.sessionId && _this.mNbDisconnection > 0) {
                /* in case of reconnection, simply rejoin with the exisiting the session id */
                getInviteExtraHeadersJoinSessionId();
              }
              else {
                if (_this.mOptions.sessionId) {
                  /* if there is a session id set, it means we're joining one */
                  getInviteExtraHeadersJoinSessionId();
                }
                extraHeaders[extraHeaders.length] = "sessionmedia: ".concat(_this.mOptions.sessionMedia);
                extraHeaders[extraHeaders.length] = "sessiontype: ".concat(_this.mOptions.sessionType);
                if (!!_this.mOptions.swTo) {
                  extraHeaders[extraHeaders.length] = "swto: ".concat(_this.mOptions.swTo);
                }
                if (!!_this.mOptions.swOut) {
                  extraHeaders[extraHeaders.length] = "swout: ".concat(_this.mOptions.swOut);
                }
                if (_this.mOptions.isAnonymous) {
                  extraHeaders[extraHeaders.length] = 'isanonymous: true';
                }
                if (_this.mOptions.sessionGroupId) {
                  extraHeaders[extraHeaders.length] = "sessiongroupid: ".concat(_this.mOptions.sessionGroupId);
                }
                if (_this.mOptions.localId) {
                  extraHeaders[extraHeaders.length] = "clientsessionid: ".concat(_this.mOptions.localId);
                }
                if (_this.mOptions.isEmergencyCall) {
                  extraHeaders[extraHeaders.length] = 'isemergencycall: true';
                }
                if (_this.mOptions.isBroadcastCall) {
                  extraHeaders[extraHeaders.length] = 'isbroadcastcall: true';
                }
                if (_this.mOptions.availableOnlyRecipients) {
                  extraHeaders[extraHeaders.length] = 'availableonlyrecipients: true';
                }
                if (_this.mOptions.sessionSipPriority) {
                  extraHeaders[extraHeaders.length] = "priority: ".concat(_this.mOptions.sessionSipPriority.toString());
                }
                if (_this.mOptions.floorRequestOnInvite) {
                  extraHeaders[extraHeaders.length] = 'implicitFloorRequest: true';
                  // make sure implicit floor request isn't set in case of reconnection
                  _this.mOptions.floorRequestOnInvite = false;
                }
                if (_this.mOptions.mergedSessionIds) {
                  extraHeaders[extraHeaders.length] = "mergedsessionids: ".concat(_this.mOptions.mergedSessionIds);
                }
                if (_this.mMediaHandler.getVideoCaptureSource() !== Participant_1.Participant.VideoCaptureSource.DEFAULT) {
                  extraHeaders[extraHeaders.length] = "videocapturesource: ".concat(_this.mMediaHandler.getVideoCaptureSource());
                }
              }
              return extraHeaders;
            };
            _this.parseheaders = function (response) {
              var e_1, _a;
              if (!response) {
                return false;
              }
              var headers = [
                'sessionid', 'isemergencycall', 'isbroadcastcall', 'largegroup', 'sessiongroupid', 'priority',
                'swfrom', 'swfromname', 'forwardedfrom', 'forwardedname', 'participantlist',
                'call-id', 'cseq'
              ];
              try {
                for (var headers_1 = tslib_1.__values(headers), headers_1_1 = headers_1.next(); !headers_1_1.done; headers_1_1 = headers_1.next()) {
                  var header = headers_1_1.value;
                  var val = response.getHeader(header);
                  if (!val) {
                    continue;
                  }
                  switch (header) {
                    case 'sessionid':
                      _this.mSessionId = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mSessionId));
                      break;
                    case 'isemergencycall':
                      _this.mIsAnEmergencyCall = val === 'true';
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(Utils_1.Utils.strBool(_this.mIsAnEmergencyCall)));
                      break;
                    case 'isbroadcastcall':
                      _this.mIsABroadcastCall = val === 'true';
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(Utils_1.Utils.strBool(_this.mIsABroadcastCall)));
                      break;
                    case 'largegroup':
                      _this.mLargeGroupCount = Number.parseInt(val, 10);
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mLargeGroupCount));
                      break;
                    case 'sessiongroupid':
                      _this.mSessionGroupId = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mSessionGroupId));
                      break;
                    case 'priority':
                      _this.mSessionPriority = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mSessionPriority));
                      break;
                    case 'swfrom':
                      _this.mSwFrom = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mSwFrom));
                      break;
                    case 'swfromname':
                      _this.mSwFromName = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mSwFromName));
                      break;
                    case 'forwardedfrom':
                      _this.mForwardedFrom = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mForwardedFrom));
                      break;
                    case 'forwardedname':
                      _this.mForwardedName = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mForwardedName));
                      break;
                    case 'participantlist':
                      try {
                        var list = JSON.parse(Utils_1.Utils.stripslashes(val.substring(1, val.length - 1)));
                        _this.onServiceMessageParticipantList(list);
                      }
                      catch (e) {
                        var err = e;
                        LOGE("Failed to parse ".concat(header, ": ").concat(err.name, ": ").concat(err.message));
                        return false;
                      }
                      break;
                    case 'call-id':
                      _this.mCallId = val;
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mCallId));
                      break;
                    case 'cseq':
                      _this.mCseq = parseInt(val, 10);
                      LOGD("VoIP call ".concat(_this.toString(), " ").concat(header, ": ").concat(_this.mCseq));
                      break;
                  }
                }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                try {
                  if (headers_1_1 && !headers_1_1.done && (_a = headers_1.return)) _a.call(headers_1);
                }
                finally { if (e_1) throw e_1.error; }
              }
              return true;
            };
            _this.onMessageOutgoingRequest = function (request) {
              if (!_this.mCallId) {
                return;
              }
              // this is kind of hack-ish: JsSIP doesn't send Messages using the same dialog, hence
              // call-id and cseq do not match with the dialog opened by INVITE. All outgoing messages
              // call-id and cseq are overwritten with the values used by INVITE and its responses.
              var callid = request.getHeader('call-id');
              LOGD("".concat(_this.toString(), " Overwriting Call-ID \"").concat(callid, "\" to: \"").concat(_this.mCallId, "\""));
              request.call_id = _this.mCallId;
              request.setHeader('call-id', _this.mCallId);
              request.cseq = ++_this.mCseq;
              request.setHeader('cseq', request.cseq.toString() + ' ' + request.method);
              // this is ugly: JsSIP does not allow the caller to set the dialog cseq. As in a PTT,
              // the dialog sends several messages using the above hack, the dialog local seqnum is
              // left untouched until the BYE, so there's a mismatch, and the engine 500 errors the
              // BYE. The following makes sure the session inner dialog local seqnum is incremented
              // everytime a message is sent.
              var session = _this.mMediaHandler.getRtcSession();
              if (session) {
                /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                session._dialog._local_seqnum = _this.mCseq;
              }
            };
            _this.onMessage = function (ev) {
              var messageType = ev.request.getHeader('MessageType');
              var smt = ev.request.getHeader(Call.messageType2Sub(messageType));
              LOGD("".concat(_this.toString(), " messagetype: ").concat(messageType, "/").concat(smt));
              if (ev.originator === 'local') {
                _this.onMessageOutgoingRequest(ev.request);
              }
              if (_this.isWalkieTalkie()) {
                var fev = ev.request.getHeader(Call.MessageTypeSub.MB_CONTROL_MESSAGE_TYPE);
                _this.mFloorControl.onMediaburstMessage(fev, ev.request);
              }
              if (messageType === Call.MessageType.SERVICE) {
                _this.onServiceMessage(ev);
              }
              else if (messageType !== Call.MessageType.MB_CONTROL) {
                LOGD("".concat(_this.toString(), " MessageType: ").concat(messageType));
              }
            };
            _this.onServiceMessage = function (ev) {
              if (ev.originator === 'local') {
                return true;
              }
              var smt = ev.request.getHeader(Call.MessageTypeSub.SERVICE_MESSAGE_TYPE);
              if (!smt) {
                return false;
              }
              if ('VoipSessionUpdated' === smt) {
                var updatedSession = JSON.parse(ev.request.body);
                if (updatedSession.ReadyToTransmit) {
                  _this.newEvent(Call.Event.FLOOR_CONTROL, FloorControl_1.FloorControl.Event.READY_TO_TRANSMIT);
                }
                if (updatedSession.isEmergencyCall !== undefined) {
                  LOGD("Emergency call has been updated: ".concat(Utils_1.Utils.strBool(updatedSession.isEmergencyCall))
                    + " (was: ".concat(Utils_1.Utils.strBool(_this.mIsAnEmergencyCall), ")"));
                  _this.mIsAnEmergencyCall = updatedSession.isEmergencyCall;
                  if (_this.mIsAnEmergencyCall && updatedSession.emergencyInitiator !== undefined) {
                    _this.mEmergencyInitiator = updatedSession.emergencyInitiator;
                    LOGD("Emergency call intiator has been updated: ".concat(_this.mEmergencyInitiator));
                  }
                  _this.newEvent(Call.Event.SESSION_UPDATED);
                }
                return true;
              }
              var list = JSON.parse(ev.request.body);
              switch (smt) {
                case Participant_1.Participant.Event.PARTICIPANT_LIST:
                case Participant_1.Participant.Event.PARTICIPANT_INVITED:
                case Participant_1.Participant.Event.PARTICIPANT_TRANSFER:
                  _this.onServiceMessageParticipantList(list);
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_LIST:
                default:
                  if (list.Contact) {
                    _this.mParticipants.onServiceMessageParticipant(smt, list);
                  }
                  // if (this.mSessionType !== Call.SessionType.WALKIETALKIE
                  //     && this.mSessionType !== Call.SessionType.AMBIENT_LISTENING) {
                  //     const $pcount = this.mParticipants.count(
                  //            [Participant.State.ATTENDING, Participant.State.ATTENDING_ONHOLD]
                  //        );
                  //     if ($pcount == 1) {
                  //         this.mMediaHandler.muteCapture();
                  //     } else if ($pcount > 1) {
                  //         if (this.m)
                  //     }
                  // }
                  break;
              }
              return true;
            };
            _this.onServiceMessageParticipantList = function (participantList) {
              if (participantList.ParticipantList) {
                _this.mParticipants.updateParticipantList(participantList.ParticipantList, true);
              }
              if (participantList.AddedParticipantList) {
                _this.mParticipants.updateParticipantList(participantList.AddedParticipantList, false);
              }
              if (participantList.SessionType) {
                _this.mSessionType = participantList.SessionType;
              }
              if (participantList.SessionMedia) {
                _this.mSessionMedia = participantList.SessionMedia;
              }
              if (participantList.SessionGroupId) {
                _this.mSessionGroupId = participantList.SessionGroupId;
              }
              if (participantList.SessionPriority) {
                _this.mSessionPriority = participantList.SessionPriority;
              }
              if (participantList.GroupNames) {
                _this.mGroupNames = participantList.GroupNames;
              }
              if (participantList.GroupUsersList) {
                _this.mGroupUsersList = Object.assign([], participantList.GroupUsersList);
              }
              if (participantList.GroupAddedUsers) {
                if (_this.mGroupAddedUsers) {
                  _this.mGroupAddedUsers.concat(participantList.GroupAddedUsers);
                }
                else {
                  _this.mGroupAddedUsers = Object.assign([], participantList.GroupAddedUsers);
                }
              }
              if (participantList.ReceptionTime) {
                _this.mReceptionTime = new Date(participantList.ReceptionTime);
              }
              _this.mParticipants.parseAttendingArrivalTime(participantList);
              _this.mParticipants.parseFloorPriority(participantList);
              if (participantList.FloorOwner) {
                _this.mFloorControl.updateFloorControlState(FloorControl_1.FloorControl.State.HAS_NO_PERMISSION);
                _this.mFloorControl.updateFloorOwner(participantList.FloorOwner);
              }
              if (participantList.Transferor) {
                _this.mTransferor = participantList.Transferor;
              }
              if (participantList.MergedSessionIds) {
                _this.mMergedSessionIds = participantList.MergedSessionIds;
              }
              // pop the ParticipantList only after all possible values have been updated
              if (participantList.ParticipantList || participantList.AddedParticipantList) {
                _this.newEvent(Call.Event.PARTICIPANT, Participant_1.Participant.Event.PARTICIPANT_LIST);
              }
            };
            _this.sendServiceMessage = function (serviceMessageType, headers) {
              if (!_this.mJssipUa) {
                return false;
              }
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD("".concat(serviceMessageType, " has been successfully executed: ").concat(ev.response.status_code));
                  }
                },
                failed: function (ev) {
                  _this.received500Error(ev.response);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: SERVICE',
                  'ServiceMessageType: ' + serviceMessageType
                ]
              };
              if (headers && options.extraHeaders) {
                options.extraHeaders = options.extraHeaders.concat(headers);
              }
              _this.mJssipUa.sendMessage(_this.mUri, '', options);
              return true;
            };
            _this.received500Error = function (response) {
              if (!response) {
                return false;
              }
              if (response.body) {
                var e = JSON.parse(response.body);
                _this.mFailedReason = e.error;
                LOGE(_this.toString() + ': Server error: ' + e.error);
              }
              else {
                LOGE(_this.toString() + ': No explicit error from Server');
                _this.mFailedReason = Call.FailedReason.INTERNAL_SERVER_ERROR;
              }
              return true;
            };
            _this.mInstanceId = Call.sInstanceCount++;
            _this.mUa = ua;
            var uaOptions = ua.getOptions();
            _this.mUri = new JsSIP.URI('sips', C.VOIP_APP, uaOptions.host, C.VOIP_APP_PORT);
            if (options.localId) {
              _this.mLocalId = options.localId;
            }
            else {
              _this.mLocalId = Utils_1.Utils.guid();
            }
            _this.mOptions = options;
            if (!_this.mOptions.captureOptions) {
              _this.mOptions.captureOptions = {};
            }
            if (!_this.mOptions.playOptions) {
              _this.mOptions.playOptions = {};
            }
            Call.logOptions(options);
            _this.mMediaHandler = new MediaHandler_1.MediaHandler(_this.mOptions.captureOptions, _this.mOptions.playOptions, "[Session #".concat(_this.mInstanceId, "]"));
            _this.mMediaHandler.onvolumelocal = function () {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.VOLUME_LOCAL);
            };
            _this.mMediaHandler.onvolumeremote = function () {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.VOLUME_REMOTE);
            };
            _this.mMediaHandler.onqos = function () {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.QOS);
            };
            _this.mMediaHandler.onrecordlocal = function () {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.BURST_RECORDED_SENT);
            };
            _this.mMediaHandler.onrecordremote = function () {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.BURST_RECORDED_RECEIVED);
            };
            _this.mMediaHandler.onlocalmediastreamtrackend = function ( /* track: MediaStreamTrack */) {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.MEDIA_STREAM_LOCAL_TRACK_ENDED);
              var onError = function () {
                LOGD("".concat(_this.toString(), " Has no local mediastream with active tracks, ending now"));
                _this.mStoppedReason = Call.StoppedReason.STOPPED_SHARING_LOCAL_MEDIA;
                _this.stop();
                _this.stopJssipUa();
                _this.newEvent(Call.Event.STOPPED);
              };
              if (!_this.mMediaHandler.doesMediaStreamLocalHaveActiveTracks()) {
                if (_this.receivesOnly()) {
                  onError();
                  return;
                }
                var mediaHandlerOptions = {
                  audio: _this.mOptions.sessionMedia.includes(Call.SessionMedia.AUDIO),
                  video: _this.mOptions.sessionMedia.includes(Call.SessionMedia.VIDEO)
                };
                _this.mMediaHandler.getMediaStream(mediaHandlerOptions)
                  .then(function (ms) {
                    LOGD("".concat(_this.toString(), " Got mediastream: ").concat(Utils_1.Utils.strMediaStream(ms)));
                    _this.mMediaHandler.setMediaStreamLocal(ms);
                  }).catch(function (err) {
                    var e = err;
                    LOGE("".concat(_this.toString(), " Error while getting mediastream, aborting: ").concat(e.message));
                    LOGE(e.stack);
                    onError();
                  });
              }
            };
            _this.mMediaHandler.ondevicechange = function () {
              if (!_this.mMediaHandler) {
                return;
              }
              _this.newEvent(Call.Event.MEDIA, MediaHandler_1.MediaHandler.Event.MEDIA_STREAM_DEVICE_CHANGE);
              var mediaHandlerOptions = {
                audio: _this.mOptions.sessionMedia.includes(Call.SessionMedia.AUDIO),
                video: _this.mOptions.sessionMedia.includes(Call.SessionMedia.VIDEO)
              };
              _this.mMediaHandler.getMediaStream(mediaHandlerOptions)
                .then(function (ms) {
                  LOGD("".concat(_this.toString(), " Got mediastream: ").concat(Utils_1.Utils.strMediaStream(ms)));
                  _this.mMediaHandler.setMediaStreamLocal(ms);
                }).catch(function (err) {
                  var e = err;
                  LOGE("".concat(_this.toString(), " Error while getting mediastream, aborting: ").concat(e.message));
                  LOGE(e.stack);
                });
            };
            _this.mParticipants.onevent = function (pev) {
              _this.newEvent(Call.Event.PARTICIPANT, pev);
            };
            _this.mFloorControl = new FloorControl_1.FloorControl(options.subscriberMsisdn, _this.mParticipants);
            _this.mFloorControl.sendmessage = function (sendMessageOptions) {
              if (!_this.mJssipUa) {
                return;
              }
              return _this.mJssipUa.sendMessage(_this.mUri, '', sendMessageOptions);
            };
            _this.mFloorControl.onevent = function (fev) {
              _this.newEvent(Call.Event.FLOOR_CONTROL, fev);
              if (fev === FloorControl_1.FloorControl.Event.GRANTED) {
                _this.mMediaHandler.startRecordLocal();
              }
              else if (fev === FloorControl_1.FloorControl.Event.TAKEN) {
                if (_this.isMuted()) {
                  LOGD("".concat(_this.toString(), " Floor taken while muted."));
                }
                _this.mMediaHandler.startRecordRemote();
              }
              else if (fev === FloorControl_1.FloorControl.Event.IDLE) {
                _this.mMediaHandler.stopRecordLocal();
                _this.mMediaHandler.stopRecordRemote();
              }
            };
            _this.mFloorControl.mute = function (doMute) {
              return doMute ? _this.mMediaHandler.muteCapture() : _this.mMediaHandler.unmuteCapture();
            };
            return _this;
          }
          Call.sInstanceCount = 0;
          /**
           * Logs the provided call options
           * @param options - the call options
           */
          Call.logOptions = function (options) {
            LOGD(" - subscriberMsisdn: ".concat(options.subscriberMsisdn));
            if (options.getSubscriberToken) {
              LOGD(' - getSubscriberToken');
            }
            else if (options.subscriberPassword) {
              LOGD(' - subscriberPassword: XXX');
            }
            else {
              LOGD(' - no auth method???');
            }
            if (options.swTo) {
              LOGD(" - swTo: ".concat(options.swTo));
            }
            if (options.swOut) {
              LOGD(" - swOut: ".concat(options.swOut));
            }
            if (options.isAnonymous) {
              LOGD(" - isAnonymous: ".concat(Utils_1.Utils.strBool(options.isAnonymous)));
            }
            if (options.sessionId) {
              LOGD(" - sessionId: ".concat(options.sessionId));
            }
            if (options.sessionType) {
              LOGD(" - sessionType: ".concat(options.sessionType));
            }
            if (options.sessionSipPriority) {
              LOGD(" - sessionSipPriority: ".concat(options.sessionSipPriority));
            }
            if (options.sessionMedia) {
              LOGD(" - sessionMedia: ".concat(options.sessionMedia));
            }
            if (options.sessionGroupId) {
              LOGD(" - sessionGroupId: ".concat(options.sessionGroupId));
            }
            if (options.localId) {
              LOGD(" - localId: ".concat(options.localId));
            }
            if (options.autoReconnect) {
              LOGD(" - autoReconnect: ".concat(Utils_1.Utils.strBool(options.autoReconnect)));
            }
            if (options.synchronizeWithOtherDevices) {
              LOGD(" - synchronizeWithOtherDevices: ".concat(Utils_1.Utils.strBool(options.synchronizeWithOtherDevices)));
            }
            if (options.isEmergencyCall) {
              LOGD(" - isEmergencyCall: ".concat(Utils_1.Utils.strBool(options.isEmergencyCall)));
            }
            if (options.isBroadcastCall) {
              LOGD(" - isBroadcastCall: ".concat(Utils_1.Utils.strBool(options.isBroadcastCall)));
            }
            if (options.availableOnlyRecipients) {
              LOGD(" - availableOnlyRecipients: ".concat(Utils_1.Utils.strBool(options.availableOnlyRecipients)));
            }
            if (options.floorRequestOnInvite) {
              LOGD(" - floorRequestOnInvite: ".concat(Utils_1.Utils.strBool(options.floorRequestOnInvite)));
            }
            if (options.mergedSessionIds) {
              LOGD(" - mergedSessionIds: ".concat(options.mergedSessionIds));
            }
            if (options.mediaStream) {
              LOGD(" - mediaStream: ".concat(Utils_1.Utils.strMediaStream(options.mediaStream)));
            }
            if (options.captureOptions) {
              LOGD(' - captureOptions:');
              if (options.captureOptions.htmlSource) {
                var c = options.captureOptions.htmlSource;
                LOGD("   - htmlSource: ".concat(c.localName, ": ").concat(c.id));
              }
              if (options.captureOptions.screensharing) {
                LOGD("   - screensharing: ".concat(Utils_1.Utils.strBool(options.captureOptions.screensharing)));
              }
            }
            if (options.playOptions) {
              LOGD(' - playOptions:');
              if (options.playOptions.rendererRemote) {
                LOGD("   - rendererRemote: ".concat(Utils_1.Utils.strMediaElement(options.playOptions.rendererRemote)));
              }
              if (options.playOptions.rendererLocal) {
                LOGD("   - rendererLocal: ".concat(Utils_1.Utils.strMediaElement(options.playOptions.rendererLocal)));
              }
            }
          };
          return Call;
        }(events_1.EventEmitter));
        exports.Call = Call;
        /**
         * @public
         */
        (function (Call) {
          /**
           * @internal
           */
          var MessageType;
          (function (MessageType) {
            MessageType["SERVICE"] = "SERVICE";
            MessageType["MB_CONTROL"] = "MB_CONTROL";
          })(MessageType = Call.MessageType || (Call.MessageType = {}));
          /**
           * @internal
           */
          var MessageTypeSub;
          (function (MessageTypeSub) {
            MessageTypeSub["SERVICE_MESSAGE_TYPE"] = "ServiceMessageType";
            MessageTypeSub["MB_CONTROL_MESSAGE_TYPE"] = "MBControlMessageType";
          })(MessageTypeSub = Call.MessageTypeSub || (Call.MessageTypeSub = {}));
          /**
           * @internal
           */
          Call.messageType2Sub = function (mt) {
            switch (mt) {
              case MessageType.SERVICE: return MessageTypeSub.SERVICE_MESSAGE_TYPE;
              case MessageType.MB_CONTROL: return MessageTypeSub.MB_CONTROL_MESSAGE_TYPE;
              default: return '';
            }
          };
          var Event;
          (function (Event) {
            /**
             * The call has been successfully started (INVITE + 200 OK, this event can be raised several times)
             */
            Event["STARTED"] = "Started";
            /**
             * The call has been been stopped. The reason for that is available with {@link (Call:class).getStoppedReason}
             */
            Event["STOPPED"] = "Stopped";
            /**
             * The call has failed. The reason for that is available with {@link (Call:class).getError}
             */
            Event["FAILED"] = "Failed";
            /**
             * The Call has been disconnected because a disconnection occured, it is currently tryin to reconnect
             */
            Event["DISCONNECTED_AND_RECONNECTING"] = "disconnected_and_reconnecting";
            /**
             * the call to {@link (Call:class).inviteNewParticipants} has been successful
             */
            Event["SESSION_SUBSCRIBER_INVITATION_OK"] = "invite_new_participants_ok";
            /**
             * the call to {@link (Call:class).inviteNewParticipants} has failed. See
             * {@link (Call:class).getError} to get the reason why.
             */
            Event["SESSION_SUBSCRIBER_INVITATION_NOK"] = "invite_new_participants_nok";
            /**
             * the call to {@link (Call:class).transfer} has been successful
             */
            Event["SESSION_TRANSFER_OK"] = "transfer_ok";
            /**
             * the call to {@link (Call:class).transfer} has failed. See
             * {@link (Call:class).getError} to get the reason why.
             */
            Event["SESSION_TRANSFER_NOK"] = "transfer_nok";
            /**
             * the call to {@link (Call:class).update} has been successful
             */
            Event["SESSION_UPDATE_OK"] = "update_ok";
            /**
             * the call to {@link (Call:class).update} has failed. See
             * {@link (Call:class).getError} to get the reason why.
             */
            Event["SESSION_UPDATE_NOK"] = "update_nok";
            /**
             * the session has been updated
             */
            Event["SESSION_UPDATED"] = "updated";
            /**
             * The call participant list has been updated.
             */
            Event["PARTICIPANT"] = "Participant";
            /**
             * The call internal floor control state has been updated.
             */
            Event["FLOOR_CONTROL"] = "FloorControl";
            /**
             * The call media has been updated.
             */
            Event["MEDIA"] = "Media";
          })(Event = Call.Event || (Call.Event = {}));
          var SessionMedia;
          (function (SessionMedia) {
            /**
             * placeholder
             */
            SessionMedia["UNKNOWN"] = "unknown";
            /**
             * Audio only
             */
            SessionMedia["AUDIO"] = "audio";
            /**
             * Video only
             */
            SessionMedia["VIDEO"] = "video";
            /**
             * Audio and Video
             */
            SessionMedia["AUDIOVIDEO"] = "audiovideo";
          })(SessionMedia = Call.SessionMedia || (Call.SessionMedia = {}));
          /**
           * The session call type.
           */
          var SessionType;
          (function (SessionType) {
            /**
             * placeholder
             */
            SessionType["UNKNOWN"] = "unknown";
            /**
             * a one to one full duplex call session without floor control
             */
            SessionType["FREECALL"] = "live";
            /**
             * a half duplex call session (sender or receiver only)
             */
            SessionType["WALKIETALKIE"] = "PoC";
            /**
             * a half duplex call session (sender or receiver only)
             */
            SessionType["LIVESTREAM"] = "livestream";
            /**
             * a one to many full duplex call session without floor control
             */
            SessionType["CONFERENCE"] = "conference";
            /**
             * a half duplex call session without floor control
             */
            SessionType["AMBIENT_LISTENING"] = "ambient-listening";
          })(SessionType = Call.SessionType || (Call.SessionType = {}));
          /**
           * The session priority.
           */
          var SipPriority;
          (function (SipPriority) {
            /**
             * non urgent
             */
            SipPriority["NON_URGENT"] = "non-urgent";
            /**
             * normal
             */
            SipPriority["NORMAL"] = "normal";
            /**
             * urgent
             */
            SipPriority["URGENT"] = "urgent";
            /**
             * emergency
             */
            SipPriority["EMERGENCY"] = "emergency";
          })(SipPriority = Call.SipPriority || (Call.SipPriority = {}));
          var Hangup;
          (function (Hangup) {
            /**
             * @internal
             * the user explicitely requests to hangup the call.
             */
            Hangup["USER_HANGUP"] = "USER_HANGUP";
            /**
             * @internal
             * the use cancels the call
             */
            Hangup["CANCEL"] = "CANCEL";
          })(Hangup = Call.Hangup || (Call.Hangup = {}));
          /**
           * The reason why the call has stopped. Note that no reconnection is expected.
           */
          var StoppedReason;
          (function (StoppedReason) {
            StoppedReason["STOPPED_UNKNOWN"] = "unknown";
            /**
             * The call has been cancelled.
             */
            StoppedReason["STOPPED_CANCELLED"] = "cancelled";
            /**
             * The call has been disconnected.
             */
            StoppedReason["STOPPED_DISCONNECTION"] = "disconnection";
            /**
             * The call has ended after a BYE was sent.
             */
            StoppedReason["STOPPED_BYE_SENT"] = "bye_sent";
            /**
             * The call has ended after a BYE was received without any reason.
             */
            StoppedReason["STOPPED_BYE_RECEIVED"] = "bye_received";
            /**
             * The call was ended by the server as the subscriber isn't allowed anymore in the session
             */
            StoppedReason["STOPPED_BYE_RECEIVED_NOT_ALLOWED"] = "bye_received_not_allowed";
            /**
             * The call was ended by the server as the subscriber has joined the session with an other device/browser.
             */
            StoppedReason["STOPPED_BYE_RECEIVED_CALL_REPLACED"] = "bye_received_call_replaced";
            /**
             * The call was ended by the server as the initiator of the session left.
             */
            StoppedReason["STOPPED_BYE_RECEIVED_INITIATOR_LEFT"] = "bye_received_initiator_left";
            /**
             * The call was ended by the server as the subscriber was removed from the group
             */
            StoppedReason["STOPPED_BYE_RECEIVED_GROUP_REMOVED"] = "bye_received_group_received";
            /**
             * The call was ended by the server because nothing happened for a while
             */
            StoppedReason["STOPPED_BYE_RECEIVED_HANG_TIME"] = "bye_received_hang_time";
            /**
             * The call was ended by the server because a subscriber terminated the call
             */
            StoppedReason["STOPPED_BYE_RECEIVED_TERMINATED"] = "bye_received_terminated";
            /**
             * The call has ended because all autoreconnection attempts has failed.
             */
            StoppedReason["STOPPED_AUTORECONNECTION_TIMEOUT"] = "autoreconnection_timeout";
            /**
             * The call has ended because the subscriber stopped sharing
             */
            StoppedReason["STOPPED_SHARING_LOCAL_MEDIA"] = "stopped_sharing_local_media";
          })(StoppedReason = Call.StoppedReason || (Call.StoppedReason = {}));
          /**
           * The reason why the call has failed.
           */
          var FailedReason;
          (function (FailedReason) {
            FailedReason["SUCCESS"] = "SUCCESS";
            /**
             * Trying to join a call with a non existing account
             */
            FailedReason["ACCOUNT_NOT_EXIST"] = "ACCOUNT_NOT_EXIST";
            /**
             * Bad password or token
             */
            FailedReason["AUTH_BAD_PASSWORD"] = "AUTH_BAD_PASSWORD";
            /**
             * The MSISDN is not authorized for requested action
             */
            FailedReason["UNAUTHORIZED_MSISDN"] = "UNAUTHORIZED_MSISDN";
            /**
             * Subscriber has been blocked
             */
            FailedReason["SUBSCRIBER_BLOCKED"] = "SUBSCRIBER_BLOCKED";
            /**
             * Subscriber has been disabled
             */
            FailedReason["SUBSCRIBER_DISABLED"] = "SUBSCRIBER_DISABLED";
            /**
             * Subscriber has been unassigned
             */
            FailedReason["SUBSCRIBER_UNASSIGNED"] = "SUBSCRIBER_UNASSIGNED";
            /**
             * Subscriber's organization has been blocked
             */
            FailedReason["ORGANIZATION_BLOCKED"] = "ORGANIZATION_BLOCKED";
            /**
             * Subscriber's organization credentials is expired
             */
            FailedReason["ORGANIZATION_EXPIRED"] = "ORGANIZATION_EXPIRED";
            /**
             * Call out has failed
             */
            FailedReason["CALL_OUT_FAILED"] = "CALL_OUT_FAILED";
            /**
             * Call out failed because callee is already on the line
             */
            FailedReason["CALL_OUT_BUSY"] = "CALL_OUT_BUSY";
            /**
             * Trying to join a call that does not exists
             */
            FailedReason["UNKNOWN_SESSION_ID"] = "UNKNOWN_SESSION_ID";
            /**
             * Service is currently unavailable
             */
            FailedReason["SERVICE_UNAVAILABLE"] = "SERVICE_UNAVAILABLE";
            /**
             * Subscriber is not allowed to make the call as the feature is not allowed
             */
            FailedReason["FEATURE_NOT_ALLOWED"] = "FEATURE_NOT_ALLOWED";
            /**
             * Subscriber is not authorized to make the call
             */
            FailedReason["CUG_DENIED"] = "CUG_DENIED";
            /**
             * No resource is currently available to make the call
             */
            FailedReason["NO_RESOURCE"] = "NO_RESOURCE";
            /**
             * Channel is full
             */
            FailedReason["CHANNEL_FULL"] = "CHANNEL_FULL";
            /**
             * SDP negociation has failed, or SDP is missing
             */
            FailedReason["MISSING_SDP"] = "MISSING_SDP";
            /**
             * The sent INVITE has been rejected by the backend as it is considered as invalid
             */
            FailedReason["INVALID_INVITE"] = "INVALID_INVITE";
            /**
             * The server VoIP application has failed
             */
            FailedReason["INTERNAL_SERVER_ERROR"] = "INTERNAL_SERVER_ERROR";
            /**
             * The client has sent too many INVITES
             */
            FailedReason["INCOMING_SIP_INVITES_LIMIT_REACHED"] = "INCOMING_SIP_INVITES_LIMIT_REACHED";
            /**
             * The client has sent too many MESSAGES
             */
            FailedReason["INCOMING_SIP_MESSAGES_LIMIT_REACHED"] = "INCOMING_SIP_MESSAGES_LIMIT_REACHED";
            /**
             * The client has failed to authenticate too many times
             */
            FailedReason["FAILED_AUTHENTICATION_LIMIT_REACHED"] = "FAILED_AUTHENTICATION_LIMIT_REACHED";
            /**
             * The client has been rejected because too many participants are in the session
             */
            FailedReason["TOO_MANY_PARTICIPANTS"] = "TOO_MANY_PARTICIPANTS";
            /**
             * The call to {@link (Call:namespace).Options.getSubscriberToken} has failed
             */
            FailedReason["COULD_NOT_GET_TOKEN"] = "COULD_NOT_GET_TOKEN";
            /**
             * The call could not get a mediastream preliminary to start the call
             */
            FailedReason["COULD_NOT_GET_MEDIASTREAM"] = "COULD_NOT_GET_MEDIASTREAM";
            /**
             * The call could not BE ESTABLISHED
             */
            FailedReason["CONNECTION_ERROR"] = "CONNECTION_ERROR";
          })(FailedReason = Call.FailedReason || (Call.FailedReason = {}));
        })(Call = exports.Call || (exports.Call = {}));
        exports.Call = Call;


        /***/
      }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.FloorControl = void 0;
        var Debug_1 = __webpack_require__(2);
        var Participant_1 = __webpack_require__(58);
        var Utils_1 = __webpack_require__(59);
        /** @internal */
        var LOGD = Debug_1.Debugger.extend('FloorControl');
        /** @public */
        var FloorControl = /** @class */ (function () {
          function FloorControl(msisdn, participants) {
            var _this = this;
            this.mFloorStateCurrent = FloorControl.State.HAS_NO_PERMISSION;
            this.mFloorStatePrevious = FloorControl.State.HAS_NO_PERMISSION;
            this.mFloorDenyReason = FloorControl.DenyReason.UNKNOWN;
            this.mFloorRevokeReason = FloorControl.RevokeReason.UNKNOWN;
            this.mFloorHasPermissionToRequestFloor = false;
            this.getFloorOwner = function () { return _this.mFloorOwner; };
            this.getFloorOwnerLast = function () { return _this.mFloorOwnerLast; };
            this.getFloorOwnerExtUserIdUpdated = function () { return _this.mFloorOwnerExtUserIdUpdated; };
            this.getFloorState = function () { return _this.mFloorStateCurrent; };
            this.getPreviousFloorState = function () { return _this.mFloorStatePrevious; };
            this.getFloorGrantedDuration = function () { return _this.mFloorGrantedDuration; };
            this.getFloorDenyReason = function () { return _this.mFloorDenyReason; };
            this.getFloorRevokeReason = function () { return _this.mFloorRevokeReason; };
            this.hasPermissionToRequestFloor = function () { return _this.mFloorHasPermissionToRequestFloor; };
            this.updateFloorOwner = function (str) {
              _this.mFloorOwner = Participant_1.Participant.contactBeforeAt(str);
              _this.mFloorOwnerLast = _this.mFloorOwner;
              var pFloorOwner = _this.mParticipants.get(_this.mFloorOwner);
              var pSelf = _this.mParticipants.get(_this.mSubscriberMsisdn);
              if (pFloorOwner && pSelf) {
                _this.mFloorHasPermissionToRequestFloor = pSelf.getFloorPriority() > pFloorOwner.getFloorPriority();
              }
              else {
                _this.mFloorHasPermissionToRequestFloor = true;
              }
              LOGD("New floor owner set to \"".concat(_this.mFloorOwner, "\",")
                + " permission to request floor: ".concat(Utils_1.Utils.strBool(_this.mFloorHasPermissionToRequestFloor)));
            };
            this.updateFloorControlState = function (newState) {
              if (newState === _this.mFloorStateCurrent) {
                return;
              }
              _this.mFloorStatePrevious = _this.mFloorStateCurrent;
              _this.mFloorStateCurrent = newState;
              LOGD("Floor control state new state: ".concat(_this.mFloorStateCurrent, " (was: ").concat(_this.mFloorStatePrevious, ")"));
              _this.mute(_this.mFloorStateCurrent !== FloorControl.State.HAS_PERMISSION);
            };
            /**
             * Enqueues a Floor Request: claim the floor in PoC sessions
             * @returns true if the stack managed to sends the request, false otherwise
             */
            this.requestFloor = function () {
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD("FloorRequest has been granted: ".concat(ev.response.status_code));
                  }
                  _this.updateFloorControlState(FloorControl.State.HAS_PERMISSION);
                  _this.onevent(FloorControl.Event.GRANTED);
                },
                failed: function (ev) {
                  if (ev.response && ev.response.body) {
                    var e = JSON.parse(ev.response.body);
                    _this.mFloorDenyReason = e.error;
                    LOGD("FloorRequest has been denied: ".concat(_this.mFloorDenyReason));
                  }
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  LOGD(ev);
                  _this.onevent(FloorControl.Event.DENY);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: MB_CONTROL',
                  'MBControlMessageType: MediaBurstRequest'
                ]
              };
              _this.sendmessage(options);
              return true;
            };
            /**
             * Enqueues a Floor Release: release the floor in PoC sessions once it has been seized
             * @returns true if the stack managed to sends the request, false otherwise
             */
            this.releaseFloor = function () {
              var eventHandlers = {
                succeeded: function (ev) {
                  if (ev.response) {
                    LOGD("FloorRelease has been granted: ".concat(ev.response.status_code));
                  }
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  _this.onevent(FloorControl.Event.IDLE);
                },
                failed: function (ev) {
                  if (ev.response) {
                    LOGD("FloorRelease has been denied: ".concat(ev.response.status_code));
                  }
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  _this.onevent(FloorControl.Event.IDLE);
                }
              };
              var options = {
                eventHandlers: eventHandlers,
                extraHeaders: [
                  'MessageType: MB_CONTROL',
                  'MBControlMessageType: MediaBurstRelease'
                ]
              };
              _this.sendmessage(options);
              return true;
            };
            this.onMediaburstMessage = function (fev, request) {
              var floorTakenBody;
              var floorGrantedBody;
              var processed = true;
              switch (fev) {
                case FloorControl.Event.REQUEST: /* sent by the Call, ev.originator === 'local' */
                  _this.updateFloorControlState(FloorControl.State.PENDING_REQUEST);
                  break;
                case FloorControl.Event.RELEASE: /* sent by the Call, ev.originator === 'local' */
                  _this.updateFloorControlState(FloorControl.State.PENDING_RELEASE);
                  break;
                case FloorControl.Event.TAKEN: /* sent by the AS, ev.originator === 'remote' */
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  floorTakenBody = JSON.parse(request.body);
                  _this.updateFloorOwner(floorTakenBody.FloorOwner);
                  break;
                case FloorControl.Event.GRANTED: /* sent by the AS, ev.originator === 'remote' */
                  _this.updateFloorControlState(FloorControl.State.HAS_PERMISSION);
                  floorGrantedBody = JSON.parse(request.body);
                  _this.mFloorGrantedDuration = floorGrantedBody.FloorGrantedTime;
                  break;
                case FloorControl.Event.DENY: /* sent by the AS, ev.originator === 'remote' */
                  if (request.body) {
                    var e = JSON.parse(request.body);
                    _this.mFloorDenyReason = e.error;
                    LOGD("FloorRequest has been denied: ".concat(_this.mFloorDenyReason));
                  }
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  break;
                case FloorControl.Event.EXT_FLOOR_OWNER_USER_ID_UPDATE: /* sent by the AS, ev.originator === 'remote' */
                  floorTakenBody = JSON.parse(request.body);
                  _this.mFloorOwnerExtUserIdUpdated = floorTakenBody.FloorOwner;
                  LOGD("Floor owner \"".concat(_this.mFloorOwner || '?', "\" ")
                    + "updated identity: \"".concat(_this.mFloorOwnerExtUserIdUpdated, "\""));
                  break;
                case FloorControl.Event.IDLE: /* sent by the AS, ev.originator === 'remote' */
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  delete _this.mFloorOwner;
                  delete _this.mFloorOwnerExtUserIdUpdated;
                  delete _this.mFloorGrantedDuration;
                  break;
                case FloorControl.Event.REVOKE: /* sent by the AS, ev.originator === 'remote' */
                  _this.updateFloorControlState(FloorControl.State.HAS_NO_PERMISSION);
                  delete _this.mFloorOwner;
                  delete _this.mFloorOwnerExtUserIdUpdated;
                  break;
                default:
                  processed = false;
              }
              if (processed) {
                LOGD("Successfully processed event: ".concat(fev));
                _this.onevent(fev);
              }
              else {
                LOGD("Unknown event: ".concat(fev));
              }
              return processed;
            };
            this.mSubscriberMsisdn = msisdn;
            this.mParticipants = participants;
            this.sendmessage = function (options) {
              return LOGD("options: ".concat(JSON.stringify(options)));
            };
            this.onevent = function (fev) { return LOGD("event: ".concat(fev)); };
            this.mute = function (doMute) { return LOGD("mute: ".concat(Utils_1.Utils.strBool(doMute))); };
          }
          return FloorControl;
        }());
        exports.FloorControl = FloorControl;
        /** @public */
        (function (FloorControl) {
          var State;
          (function (State) {
            /**
             * initial state
             */
            State["START_STOP"] = "StartStop";
            /**
             * the client has no permission, and did not request the floor
             */
            State["HAS_NO_PERMISSION"] = "HasNoPermission";
            /**
             * the client has no permission, and did send a floor request
             */
            State["PENDING_REQUEST"] = "PendingRequest";
            /**
             * the client has the floor
             */
            State["HAS_PERMISSION"] = "HasPermission";
            /**
             * the client has the floor, and did send a floor release
             */
            State["PENDING_RELEASE"] = "PendingRelease";
            /**
             * the client floor control is inactive, for one of the following reasons:
             * - the call is reconnecting
             * - the client is alone in the call
             * - the call is stopping
             * - the call is on hold (either the client, or all the other participant are on hold)
             */
            State["INACTIVE"] = "Inactive";
          })(State = FloorControl.State || (FloorControl.State = {}));
          var Event;
          (function (Event) {
            /**
             * a floor request has been sent, the local floor state is now PENDING_REQUEST.
             */
            Event["REQUEST"] = "MediaBurstRequest";
            /**
             * a floor release has been sent, the local floor state is now PENDING_RELEASE.
             */
            Event["RELEASE"] = "MediaBurstRelease";
            /**
             * the floor is now free to take, the local floor state is now HAS_NO_PERMISSION.
             */
            Event["IDLE"] = "MediaBurstIdle";
            /**
             * the floor has been taken on the server, the local floor state is unchanged.
             */
            Event["TAKEN"] = "MediaBurstTaken";
            /**
             * the floor has been granted, the local floor state is now HAS_PERMISSION.
             */
            Event["GRANTED"] = "MediaBurstGranted";
            /**
             * the floor request has timed out and failed, the local floor state is unchanged.
             */
            Event["REQUEST_TIMEOUT"] = "MediaBurstRequestTimeout";
            /**
             * the floor request has been denied, the local floor state returns to HAS_NO_PERMISSION.
             */
            Event["DENY"] = "MediaBurstDeny";
            /**
             * the floor has been revoked, the local floor state is now HAS_NO_PERMISSION.
             */
            Event["REVOKE"] = "MediaBurstRevoke";
            /**
             * the floor release has timed out and failed, the local floor state is unchanged.
             */
            Event["RELEASE_TIMEOUT"] = "MediaBurstReleaseTimeout";
            /**
             * the floor request has been queued, the local floor state is unchanged.
             */
            Event["QUEUED"] = "MediaBurstQueued";
            /**
             * The floor owner user id has been updated
             */
            Event["EXT_FLOOR_OWNER_USER_ID_UPDATE"] = "MediaBurstExtFloorOwnerUserIdUpdate";
            /**
             * The floor is now ready to be taken
             */
            Event["READY_TO_TRANSMIT"] = "ReadyToTransmit";
          })(Event = FloorControl.Event || (FloorControl.Event = {}));
          var DenyReason;
          (function (DenyReason) {
            /**
             * An other client has permission
             */
            DenyReason["ANOTHER_CLIENT_HAS_PERMISSION"] = "BURST_DENIED_ANOTHER_CLIENT_HAS_PERMISSION";
            /**
             * Internal server error
             */
            DenyReason["INTERNAL_SERVER_ERROR"] = "BURST_DENIED_INTERNAL_SERVER_ERROR";
            /**
             * Participant is alone
             */
            DenyReason["ONLY_ONE_PARTICIPANT"] = "BURST_DENIED_ONLY_ONE_PARTICIPANT";
            /**
             * Timer T9 (Retry-after) has not expired after permission to send media has been revoked
             */
            DenyReason["RETRY_AFTER_TIMER_NOT_EXPIRED"] = "BURST_DENIED_RETRY_AFTER_TIMER_NOT_EXPIRED";
            /**
             * The participant can only receive media stream
             */
            DenyReason["RECEIVE_ONLY"] = "BURST_DENIED_RECEIVE_ONLY";
            /**
             * There's no available resource for the participant to take the floor
             */
            DenyReason["NO_RESOURCES"] = "BURST_DENIED_NO_RESOURCES";
            /**
             * The request queue is full
             */
            DenyReason["QUEUE_FULL"] = "BURST_DENIED_QUEUE_FULL";
            /**
             * Any other reason
             */
            DenyReason["OTHER"] = "BURST_DENIED_OTHER";
            /**
             * Placeholder
             */
            DenyReason["UNKNOWN"] = "BURST_DENIED_UNKNOWN";
          })(DenyReason = FloorControl.DenyReason || (FloorControl.DenyReason = {}));
          var RevokeReason;
          (function (RevokeReason) {
            /**
             * Participant is now alone (probably after a participant left)
             */
            RevokeReason["ONLY_ONE_PARTICIPANT"] = "OnlyOneParticipant";
            /**
             * The participant took the floor for longer than the granted duration
             */
            RevokeReason["MEDIABURST_TOO_LONG"] = "MediaburstTooLong";
            /**
             * The participant has no permission
             */
            RevokeReason["NO_PERMISSION"] = "NoPermission";
            /**
             * The participant has been preempted by an other participant
             */
            RevokeReason["PREEMPTED"] = "Preempted";
            /**
             * There's no resource left
             */
            RevokeReason["NO_RESOURCES"] = "NoResources";
            /**
             * Any other reason
             */
            RevokeReason["OTHER"] = "Other";
            /**
             * Placeholder
             */
            RevokeReason["UNKNOWN"] = "Unknown";
          })(RevokeReason = FloorControl.RevokeReason || (FloorControl.RevokeReason = {}));
        })(FloorControl = exports.FloorControl || (exports.FloorControl = {}));
        exports.FloorControl = FloorControl;


        /***/
      }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.Participant = void 0;
        var Debug_1 = __webpack_require__(2);
        /** @internal */
        var LOGD = Debug_1.Debugger.extend('Participant');
        /** @internal */
        var Participant = /** @class */ (function () {
          function Participant(contact) {
            var _this = this;
            this.mState = Participant.State.CREATED;
            this.mStatePrevious = Participant.State.CREATED;
            this.mFloorPriority = 0;
            this.mIsNew = true;
            this.mIsFromInterASRegroup = false;
            this.getDisplayName = function () { return _this.mIdentity; };
            this.getIdentity = function () { return _this.mIdentity + (_this.mHost ? '@' + _this.mHost : ''); };
            this.isAttending = function () {
              return _this.mState === Participant.State.ATTENDING
                || _this.mState === Participant.State.ATTENDING_ONHOLD;
            };
            this.getFloorPriority = function () { return _this.mFloorPriority; };
            this.getState = function () { return _this.mState; };
            this.getPreviousState = function () { return _this.mStatePrevious; };
            this.getArrivalTime = function () { return _this.mArrivalTime; };
            this.getVideoCaptureSource = function () {
              return _this.mVideoCaptureSource ? _this.mVideoCaptureSource : Participant.VideoCaptureSource.CAMERA;
            };
            this.isNew = function () { return _this.mIsNew; };
            this.setNew = function (n) {
              _this.mIsNew = n;
            };
            this.isFromInterASRegroup = function () { return _this.mIsFromInterASRegroup; };
            this.hasIdentity = function (msidn) {
              return Participant.contactBeforeAt(msidn) === _this.mIdentity;
            };
            this.updateState = function (state, renew) {
              if (_this.mState !== state) {
                /* If a participant is attending, it should not return to CREATED, INVITED or REACHED */
                if (_this.isAttending()) {
                  switch (state) {
                    case Participant.State.CREATED:
                    case Participant.State.INVITED:
                    case Participant.State.REACHED:
                      LOGD('NOT updating ' + _this.mIdentity + ' item: ' + _this.toString() + ' to "' + state + '"');
                      return;
                    default:
                      break;
                  }
                }
                _this.mStatePrevious = _this.mState;
                _this.mState = state;
                if (!_this.isAttending()) {
                  delete _this.mArrivalTime;
                }
                LOGD('Updated state: ' + _this.toString());
              }
              if (renew) {
                _this.mIsNew = true;
                LOGD('Updated state: ' + _this.toString() + ' has been renewed');
              }
            };
            this.updateArrivalTime = function (d) {
              _this.mArrivalTime = d;
              LOGD('Updated arrival time: ' + _this.toString());
            };
            this.updateFloorPriority = function (p) {
              _this.mFloorPriority = p;
              LOGD('Updated floor priority: ' + _this.toString());
            };
            this.updateVideoCaptureSource = function (vcs) {
              _this.mVideoCaptureSource = vcs;
              LOGD('Updated VideoCaptureSource: ' + _this.toString());
            };
            this.toString = function () {
              var ret = 'Participant "' + _this.mIdentity;
              if (_this.mHost) {
                ret += '@' + _this.mHost;
              }
              ret += '" [' + _this.mState + ']';
              if (_this.mIsFromInterASRegroup) {
                ret += ' [interasregroup]';
              }
              if (_this.mStatePrevious) {
                ret += " [previous: ".concat(_this.mStatePrevious, "]");
              }
              if (_this.mFloorPriority) {
                ret += " [priority: ".concat(_this.mFloorPriority, "]");
              }
              if (_this.mArrivalTime && _this.isAttending()) {
                ret += " [arrivalTime: ".concat(_this.mArrivalTime.toISOString(), "]");
              }
              if (_this.mVideoCaptureSource && _this.isAttending()) {
                ret += " [VideoCapture: ".concat(_this.mVideoCaptureSource, "]");
              }
              return ret;
            };
            this.mIsFromInterASRegroup = contact.startsWith(Participant.PREFIX_INTERASREGROUP);
            if (this.mIsFromInterASRegroup) {
              contact = contact.substring(Participant.PREFIX_INTERASREGROUP.length);
            }
            var at = contact.indexOf('@');
            if (at > 0) {
              this.mIdentity = contact.substr(0, at);
              this.mHost = contact.substr(at + 1);
            }
            else {
              this.mIdentity = contact;
            }
          }
          Participant.PREFIX_INTERASREGROUP = 'interasregroup:';
          Participant.contactBeforeAt = function (contact) {
            var isFromInterASRegroup = contact.startsWith(Participant.PREFIX_INTERASREGROUP);
            if (isFromInterASRegroup) {
              contact = contact.substring(Participant.PREFIX_INTERASREGROUP.length);
            }
            var at = contact.indexOf('@');
            return (at > 0) ? contact.substr(0, at) : contact;
          };
          return Participant;
        }());
        exports.Participant = Participant;
        /** @public */
        (function (Participant) {
          var Event;
          (function (Event) {
            /**
             * An up to date participant list has been received, {@link (Call:class).getParticipants} to get it
             */
            Event["PARTICIPANT_LIST"] = "ParticipantList";
            /**
             * New participants have been invited, {@link (Call:class).getNewParticipants} to get the newest list
             */
            Event["PARTICIPANT_INVITED"] = "ParticipantInvited";
            /**
             * A participant has been reached, {@link (Call:class).getLastUpdatedParticipant} to find out which
             */
            Event["PARTICIPANT_REACHED"] = "ParticipantReached";
            /**
             * A participant joined, {@link (Call:class).getLastUpdatedParticipant} to find out which
             */
            Event["PARTICIPANT_JOINED"] = "ParticipantJoined";
            /**
             * A participant left, {@link (Call:class).getLastUpdatedParticipant} to find out which
             */
            Event["PARTICIPANT_LEFT"] = "ParticipantLeft";
            /**
             * A participant refused to join the session, {@link (Call:class).getLastUpdatedParticipant} to find out which
             */
            Event["PARTICIPANT_REFUSED"] = "ParticipantRefused";
            /**
             * A participant is now on hold, {@link (Call:class).getLastUpdatedParticipant} to find out which
             */
            Event["PARTICIPANT_ONHOLD"] = "ParticipantOnHold";
            /**
             * A participant has resumed the call, {@link (Call:class).getLastUpdatedParticipant} to find out which
             */
            Event["PARTICIPANT_RESUME"] = "ParticipantResume";
            /**
             * A participant is transfering the call, {@link (Call:class).getTransferor} to find out which
             */
            Event["PARTICIPANT_TRANSFER"] = "ParticipantTransfer";
          })(Event = Participant.Event || (Participant.Event = {}));
          /** @internal */
          var LeftCause;
          (function (LeftCause) {
            LeftCause["CONNECTION_ERROR"] = "ConnectionError";
          })(LeftCause = Participant.LeftCause || (Participant.LeftCause = {}));
          var RefusedReason;
          (function (RefusedReason) {
            RefusedReason["UNANSWERING"] = "UNANSWERING";
            RefusedReason["DECLINED"] = "DECLINED";
            RefusedReason["BUSY"] = "BUSY";
          })(RefusedReason = Participant.RefusedReason || (Participant.RefusedReason = {}));
          var State;
          (function (State) {
            /**
             * unknown
             */
            State["UNKNOWN"] = "UNKNOWN";
            /**
             * The participant is created on the server
             */
            State["CREATED"] = "CREATED";
            /**
             * the participant has been invited to join the session
             */
            State["INVITED"] = "INVITED";
            /**
             * The participant has been reached on the server
             */
            State["REACHED"] = "REACHED";
            /**
             * the participant is currently attending to the session
             */
            State["ATTENDING"] = "ATTENDING";
            /**
             * the participant is currently attending to the session and is on hold
             */
            State["ATTENDING_ONHOLD"] = "ATTENDING_ONHOLD";
            /**
             * the participant is currently reconnecting to the session
             */
            State["RECONNECTING"] = "RECONNECTING";
            /**
             * the participant hung up on the call
             */
            State["HUNGUP"] = "HUNGUP";
            /**
             * The participant did not answer to the invitation
             */
            State["UNANSWERING"] = "UNANSWERING";
            /**
             * the participant declined
             */
            State["DECLINED"] = "DECLINED";
            /**
             * the participant is currently busy
             */
            State["BUSY"] = "BUSY";
            /**
             * the participant does not have the feature
             */
            State["FEATURE_NOT_ALLOWED"] = "FEATURE_NOT_ALLOWED";
            /**
             * the CUG denied to call this participant
             */
            State["CUG_DENIED"] = "CUG_DENIED";
            /**
             * ALL
             */
            State["ALL_PARTICIPANT"] = "All";
          })(State = Participant.State || (Participant.State = {}));
          /**
           * The Video Capture Source, if any
           */
          var VideoCaptureSource;
          (function (VideoCaptureSource) {
            /**
             * the source is a regular camera
             */
            VideoCaptureSource["CAMERA"] = "camera";
            /**
             * the source is an external camera
             */
            VideoCaptureSource["CAMERA_EXTERNAL"] = "camera_external";
            /**
             * the source is a screen sharing
             */
            VideoCaptureSource["SCREEN_SHARING"] = "screen_sharing";
            /**
             * the source is a canvas
             */
            VideoCaptureSource["CANVAS"] = "canvas";
            /**
             * the source is a file
             */
            VideoCaptureSource["FILE"] = "file";
            VideoCaptureSource["DEFAULT"] = "camera";
          })(VideoCaptureSource = Participant.VideoCaptureSource || (Participant.VideoCaptureSource = {}));
        })(Participant = exports.Participant || (exports.Participant = {}));
        exports.Participant = Participant;


        /***/
      }),
/* 59 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.Utils = void 0;
        var tslib_1 = __webpack_require__(1);
        /** @internal */
        var Utils;
        (function (Utils) {
          Utils.strBool = function (b) { return b ? 'true' : 'false'; };
          /**
           * Deep copy function for TypeScript.
           * there's a couple of "eslint-disable" to ignore the typing hacks
           * @param T - Generic type of target/copied value.
           * @param target - Target value to be copied.
           * {@link https://github.com/ykdr2017/ts-deepcopy}
           */
          Utils.deepCopy = function (target) {
            if (target === null) {
              return target;
            }
            if (target instanceof Date) {
              return new Date(target.getTime());
            }
            if (target instanceof Array) {
              var cp_1 = [];
              target.forEach(function (v) {
                cp_1.push(v);
              });
              /* eslint-disable @typescript-eslint/no-unsafe-return */
              return cp_1.map(function (n) { return Utils.deepCopy(n); });
            }
            if (typeof target === 'object' && target !== {}) {
              var cp_2 = tslib_1.__assign({}, target);
              Object.keys(cp_2).forEach(function (k) {
                /* eslint-disable @typescript-eslint/no-unsafe-assignment */
                cp_2[k] = Utils.deepCopy(cp_2[k]);
              });
              return cp_2;
            }
            return target;
          };
          Utils.guid = function () {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
              var r = Math.random() * 16 | 0;
              var v = (c === 'x') ? r : (r & 0x3 | 0x8);
              return v.toString(16);
            });
          };
          //     length: function(aa) {
          //         var i = 0;
          //         for (var key in aa) {
          //             if (Utils.isNotNull(aa[key])) {
          //                 ++i;
          //             }
          //         }
          //         return i;
          //     },
          Utils.addslashes = function (str) {
            str = str.replace(/\\/g, '\\\\');
            str = str.replace(/\"/g, '\\"');
            str = str.replace(/\"/g, '\\"');
            str = str.replace(/\'/g, '\\\'');
            str = str.replace(/\0/g, '\\0');
            return str;
          };
          Utils.stripslashes = function (str) {
            str = str.replace(/\\"/g, '"');
            str = str.replace(/\\"/g, '"');
            str = str.replace(/\\'/g, '\'');
            str = str.replace(/\\0/g, '\0');
            str = str.replace(/\\\\/g, '\\');
            return str;
          };
          Utils.random = function (min, max) { return Math.floor(Math.random() * (max - min)) + min; };
          Utils.isEmpty = function (arr) { return arr.length === 0; };
          Utils.strMediaElement = function (element) {
            if (!element) {
              return 'No element';
            }
            var str = "Element ".concat(element.localName);
            str += " id: '".concat(element.id);
            str += " / srcObj: ['".concat(Utils.strMediaStream(element.srcObject), "']");
            str += " [muted: '".concat(Utils.strBool(element.muted), "']");
            str += " [paused: '".concat(Utils.strBool(element.paused), "']");
            str += " [volume: '".concat(element.volume, "']");
            return str;
          };
          Utils.strMediaStream = function (mediaStream) {
            var e_1, _a;
            if (!mediaStream) {
              return 'No stream';
            }
            var str = "Stream: ".concat(mediaStream.id);
            var tracks = mediaStream.getTracks();
            try {
              for (var tracks_1 = tslib_1.__values(tracks), tracks_1_1 = tracks_1.next(); !tracks_1_1.done; tracks_1_1 = tracks_1.next()) {
                var t = tracks_1_1.value;
                str += Utils.strMediaStreamTrack(t);
              }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
              try {
                if (tracks_1_1 && !tracks_1_1.done && (_a = tracks_1.return)) _a.call(tracks_1);
              }
              finally { if (e_1) throw e_1.error; }
            }
            return str;
          };
          Utils.strMediaStreamTrack = function (t) {
            return t
              ? "[".concat(t.kind, " ('").concat(t.label, "'): ").concat(t.id, " [enabled: ").concat(Utils.strBool(t.enabled), "] [state: ").concat(t.readyState, "]] ")
              : ' [notrack]';
          };
          Utils.strRtpRtcpCname = function (rtcObject) {
            var _a;
            var parameters = rtcObject.getParameters();
            if (!parameters) {
              return;
            }
            return (_a = parameters.rtcp) === null || _a === void 0 ? void 0 : _a.cname;
          };
        })(Utils = exports.Utils || (exports.Utils = {}));


        /***/
      }),
/* 60 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.MediaHandler = void 0;
        var tslib_1 = __webpack_require__(1);
        var SdpTransform = tslib_1.__importStar(__webpack_require__(20));
        var Debug_1 = __webpack_require__(2);
        var MediaHandlerAudio_1 = __webpack_require__(61);
        var MediaHandlerSdp_1 = __webpack_require__(62);
        var MediaHandlerStats_1 = __webpack_require__(63);
        var Participant_1 = __webpack_require__(58);
        var Utils_1 = __webpack_require__(59);
        var webrtc_adapter_1 = tslib_1.__importDefault(__webpack_require__(44));
        /** @internal */
        var LOGD = Debug_1.Debugger.extend('MediaHandler');
        /** @internal */
        var LOGE = Debug_1.Debugger.extend('ERROR:MediaHandler');
        /** @internal */
        var LOGICE = LOGD.extend('ICE');
        /** @internal */
        var MediaHandler = /** @class */ (function () {
          function MediaHandler(captureOptions, playOptions, prefix) {
            var _this = this;
            this.mPrefix = '';
            this.mPlayOptions = {};
            this.mMutedCapture = {
              audio: false,
              video: false
            };
            this.mMutedPlay = {
              audio: false,
              video: false
            };
            this.mVideoCaptureSource = Participant_1.Participant.VideoCaptureSource.DEFAULT;
            this.getMediaStream = function (mediaOptions) {
              var getContraints = function (source) {
                var constraints = {};
                if (mediaOptions.audio) {
                  constraints.audio = {
                    // autoGainControl: MediaHandler.sConfig.audio.autoGainControl,
                    channelCount: MediaHandler.sConfig.audio.channelCount,
                    echoCancellation: MediaHandler.sConfig.audio.echoCancellation
                    // noiseSuppression: MediaHandler.sConfig.audio.noiseSuppression
                  };
                }
                if (mediaOptions.video) {
                  if (source === Participant_1.Participant.VideoCaptureSource.SCREEN_SHARING) {
                    constraints.video = {
                      frameRate: MediaHandler.sConfig.video.screensharing.fps
                    };
                    // chrome does not use strictly the provided constraints
                    // When no resolution contraints are provided, the browser uses the
                    // window/screen resolution.
                    // if (WEBRTC_ADAPTER.browserDetails.browser === 'firefox') {
                    //     constraints.video.height = MediaHandler.sConfig.video.screensharing.height;
                    //     constraints.video.width = MediaHandler.sConfig.video.screensharing.width;
                    // }
                  }
                  else {
                    constraints.video = {
                      frameRate: MediaHandler.sConfig.video.camera.fps,
                      height: MediaHandler.sConfig.video.camera.height,
                      width: MediaHandler.sConfig.video.camera.width
                      // resizeMode: 'none'
                    };
                  }
                }
                return constraints;
              };
              if (_this.mCaptureOptions.htmlSource) {
                _this.mVideoCaptureSource = Participant_1.Participant.VideoCaptureSource.CANVAS;
                var mediaStream_1 = _this.mCaptureOptions.htmlSource.captureStream(MediaHandler.sConfig.video.screensharing.fps);
                var tagName_1 = _this.mCaptureOptions.htmlSource.tagName;
                return new Promise(function (resolve, reject) {
                  if (mediaStream_1) {
                    LOGD("".concat(_this.mPrefix, " Got mediastream from element: ").concat(tagName_1));
                    resolve(mediaStream_1);
                  }
                  else {
                    reject(new DOMException('Could not get mediastream from element: ' + tagName_1));
                  }
                });
              }
              else if (_this.mCaptureOptions.screensharing) {
                _this.mVideoCaptureSource = Participant_1.Participant.VideoCaptureSource.SCREEN_SHARING;
                return navigator.mediaDevices.getDisplayMedia(getContraints(_this.mVideoCaptureSource));
              }
              else {
                MediaHandler.listDevices();
                _this.mVideoCaptureSource = Participant_1.Participant.VideoCaptureSource.CAMERA;
                return navigator.mediaDevices.getUserMedia(getContraints(_this.mVideoCaptureSource));
              }
            };
            this.getVideoCaptureSource = function () { return _this.mVideoCaptureSource; };
            this.getRtcSession = function () { return _this.mJssipRtcSession; };
            this.setRtcSession = function (session) {
              _this.mJssipRtcSession = session;
              if (!_this.mJssipRtcSession.connection) {
                return;
              }
              var onpeerconnectionchange = function (ev) {
                var pc = ev.target;
                LOGICE("".concat(_this.mPrefix, " ").concat(ev.type, ", gathering \"").concat(pc.iceGatheringState, "\",")
                  + " connection: \"".concat(pc.iceConnectionState, "\""));
              };
              var onicecandidate = function (ev) {
                var _b;
                var pc = ev.target;
                LOGICE("".concat(_this.mPrefix, " ").concat(ev.type, ", gathering \"").concat(pc.iceGatheringState, "\",")
                  + " connection: \"".concat(pc.iceConnectionState, "\": ").concat(((_b = ev.candidate) === null || _b === void 0 ? void 0 : _b.candidate) || '?'));
              };
              _this.mJssipRtcSession.connection.onconnectionstatechange = onpeerconnectionchange;
              _this.mJssipRtcSession.connection.onicecandidate = onicecandidate;
              _this.mJssipRtcSession.connection.onicecandidateerror = onpeerconnectionchange;
              _this.mJssipRtcSession.connection.oniceconnectionstatechange = onpeerconnectionchange;
              _this.mJssipRtcSession.connection.onicegatheringstatechange = onpeerconnectionchange;
              _this.mJssipRtcSession.connection.onnegotiationneeded = onpeerconnectionchange;
              _this.mJssipRtcSession.connection.onsignalingstatechange = onpeerconnectionchange;
              _this.mJssipRtcSession.connection.ondatachannel = function (ev) {
                var pc = ev.target;
                LOGICE("".concat(_this.mPrefix, " ").concat(ev.type, ", gathering \"").concat(pc.iceGatheringState, "\",")
                  + " connection: \"".concat(pc.iceConnectionState, "\": ").concat(ev.channel.label));
              };
              _this.mJssipRtcSession.connection.ontrack = function (ev) {
                var e_1, _b;
                var pc = ev.target;
                LOGICE("".concat(_this.mPrefix, " ").concat(ev.type, ", gathering \"\"").concat(pc.iceGatheringState, "\",")
                  + " connection: \"".concat(pc.iceConnectionState, "\": ").concat(ev.track.label, "/").concat(ev.track.id));
                if (ev.track.getSettings) {
                  var settings = ev.track.getSettings();
                  LOGICE("".concat(_this.mPrefix, " Track ").concat(Utils_1.Utils.strMediaStreamTrack(ev.track), " settings: ")
                    + "".concat(JSON.stringify(settings, null, '\t')));
                }
                if (ev.track.getCapabilities) {
                  var capabilities = ev.track.getCapabilities();
                  LOGICE("".concat(_this.mPrefix, " Track ").concat(Utils_1.Utils.strMediaStreamTrack(ev.track), " capabilities:")
                    + " ".concat(JSON.stringify(capabilities, null, '\t')));
                }
                try {
                  for (var _c = tslib_1.__values(ev.streams), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var mediaStream = _d.value;
                    if (_this.mMediaStreamRemote === mediaStream) {
                      continue;
                    }
                    _this.mMediaStreamRemote = mediaStream;
                    LOGD("".concat(_this.mPrefix, " Setting new remote mediastream: ").concat(Utils_1.Utils.strMediaStream(_this.mMediaStreamRemote)));
                    if (webrtc_adapter_1.default.browserDetails.browser === 'firefox') {
                      delete _this.mMediaHandlerAudioRemote;
                      if (_this.mMediaStreamRemote && _this.mMediaStreamRemote.getAudioTracks().length) {
                        _this.mMediaHandlerAudioRemote = new MediaHandlerAudio_1.MediaHandlerAudio(_this.mMediaStreamRemote);
                        _this.mMediaHandlerAudioRemote.onvolume = _this.onvolumeremote;
                      }
                    }
                  }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                  try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                  }
                  finally { if (e_1) throw e_1.error; }
                }
                LOGD("".concat(_this.mPrefix, " Setting receiver: ").concat(Utils_1.Utils.strMediaStreamTrack(ev.track)));
                if (ev.track.kind === 'audio') {
                  _this.mRtpReceiver.audio = ev.receiver;
                }
                else if (ev.track.kind === 'video') {
                  _this.mRtpReceiver.video = ev.receiver;
                }
                _this.plugRenderers();
              };
              _this.mJssipRtcSession.on('sdp', _this.onsdp);
              _this.mJssipRtcSession.on('peerconnection:setremotedescriptionfailed', _this.onSetRemoteDescriptionFailed);
              _this.mMediaHandlerStats = new MediaHandlerStats_1.MediaHandlerStats(_this.mJssipRtcSession.connection, _this.mPrefix);
              _this.mMediaHandlerStats.onqos = _this.onqos;
            };
            this.destroy = function () {
              var _b;
              _this.destroyConnectionToRemote();
              LOGD("".concat(_this.mPrefix, " Destroying MediaHandler"));
              (_b = _this.mMediaHandlerAudioLocal) === null || _b === void 0 ? void 0 : _b.destroy();
              delete _this.mMediaHandlerAudioLocal;
              if (_this.mMediaStreamLocal) {
                MediaHandler.stopMediaStream(_this.mMediaStreamLocal);
              }
              delete _this.mMediaStreamLocal;
            };
            this.destroyConnectionToRemote = function () {
              var _b, _c;
              LOGD("".concat(_this.mPrefix, " Destroying MediaHandler to remote"));
              (_b = _this.mMediaHandlerStats) === null || _b === void 0 ? void 0 : _b.destroy();
              delete _this.mMediaHandlerStats;
              (_c = _this.mMediaHandlerAudioRemote) === null || _c === void 0 ? void 0 : _c.destroy();
              delete _this.mMediaHandlerAudioRemote;
              MediaHandler.stopMediaStream(_this.mMediaStreamRemote);
              delete _this.mMediaStreamRemote;
              delete _this.mJssipRtcSession;
            };
            this.enqueueDtmf = function (dtmf) {
              if (!_this.mRtpSender.dtmf) {
                if (!_this.mRtpSender.audio) {
                  LOGE("".concat(_this.mPrefix, " Could not enqueue DTMF ").concat(dtmf, ": no audio sender is available"));
                  return false;
                }
                if (!_this.mRtpSender.audio.dtmf) {
                  LOGE("".concat(_this.mPrefix, " Could not enqueue DTMF ").concat(dtmf, ": no DTMF sender is available"));
                  return false;
                }
                // if (!this.mRtpSender.audio.dtmf.canInsertDTMF) {
                //     LOGE(`Could not enqueue DTMF ${dtmf}: DTMF sender cannot insert DTMF`);
                //     return false;
                // }
                _this.mRtpSender.dtmf = _this.mRtpSender.audio.dtmf;
                _this.mRtpSender.dtmf.ontonechange = function (ev) {
                  if (ev.tone) {
                    LOGD("".concat(_this.mPrefix, " DTMF sent: ").concat(ev.tone));
                  }
                };
              }
              LOGD("".concat(_this.mPrefix, " DTMF Now enqueuing: ").concat(dtmf));
              _this.mRtpSender.dtmf.insertDTMF(dtmf);
              return true;
            };
            this.setPlayOptions = function (options) {
              if (!options) {
                return false;
              }
              if (options.rendererLocal) {
                _this.mPlayOptions.rendererLocal = options.rendererLocal;
                LOGD("".concat(_this.mPrefix, " Setting renderer local: ").concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererLocal)));
              }
              if (options.rendererRemote) {
                _this.mPlayOptions.rendererRemote = options.rendererRemote;
                LOGD("".concat(_this.mPrefix, " Setting renderer remote: ").concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererRemote)));
              }
              _this.mPlayOptions.shouldRecord = options.shouldRecord;
              _this.plugRenderers();
              return true;
            };
            this.getVolumeLocal = function () {
              return _this.mMediaHandlerAudioLocal
                ? _this.mMediaHandlerAudioLocal.getVolume()
                : MediaHandlerAudio_1.MediaHandlerAudio.AUDIO_LEVEL_MIN;
            };
            this.getVolumeRemote = function () {
              return _this.mMediaHandlerAudioRemote
                ? _this.mMediaHandlerAudioRemote.getVolume()
                : MediaHandlerAudio_1.MediaHandlerAudio.AUDIO_LEVEL_MIN;
            };
            this.getRecordLocal = function () { return _this.mRecordLocal; };
            this.getRecordDurationLocal = function () { return _this.mRecordDurationLocal; };
            this.getRecordRemote = function () { return _this.mRecordRemote; };
            this.getRecordDurationRemote = function () { return _this.mRecordDurationRemote; };
            this.getQos = function () {
              return _this.mMediaHandlerStats ? _this.mMediaHandlerStats.getQos() : 0;
            };
            this.openMediaStatsWindow = function () {
              if (_this.mMediaHandlerStats) {
                _this.mMediaHandlerStats.openWindow();
              }
            };
            this.setAudioPlayPanning = function (c) {
              if (!_this.mMediaHandlerAudioRemote) {
                LOGE("".concat(_this.mPrefix, " Panning is not available"));
                return;
              }
              // if (!this.mMediaHandlerPannerRemote) {
              //     this.mMediaHandlerPannerRemote = new MediaHandlerPanner(this.mMediaStreamRemote);
              // }
              _this.mMediaHandlerAudioRemote.pan(c);
              LOGD("".concat(_this.mPrefix, " Audio channel set to: ").concat(c));
            };
            this.isMutedCapture = function () { return _this.mMutedCapture; };
            this.muteCapture = function (options) {
              // mute/unmute could theoritically be implemented using the following:
              // track.enabled = false
              //    This one does mute the audio capture, BUT the browser keeps sending CN packets :/
              // remoteTrack/addTrack
              //    This one is complicated, implies to fully implement onnegotiationneeded,
              //    which is done with switchToRecvOnly anyway
              // replaceTrack(null)/replaceTrack(track)
              //    cuts the need for onnegotiationneeded, has different effects on browsers:
              //    - firefox: keeps sending CN packets
              //    - chrome: stops sending packet
              // switchToRecvOnly
              //    renegociation works for all with the desired effect, although it's more painful to maintain
              //
              // links:
              // https://jsfiddle.net/j1elo/n3tf0rtL/
              if (options === void 0) { options = { audio: true, video: true }; }
              LOGD("".concat(_this.mPrefix, " muteCapture: ").concat(JSON.stringify(options)));
              options.audio = options.audio && !!_this.mRtpSender.audio;
              options.video = options.video && !!_this.mRtpSender.video;
              // this.deactivateSend(options);
              if (options.audio && _this.mRtpSender.audio && _this.mRtpSender.audio.track) {
                _this.mMutedCapture.audio = true;
                _this.mRtpSender.audio.track.enabled = false;
              }
              if (options.video && _this.mRtpSender.video && _this.mRtpSender.video.track) {
                _this.mMutedCapture.video = true;
                _this.mRtpSender.video.track.enabled = false;
              }
              // if (!this.mJssipRtcSession) {
              //     LOGE('Cannot mute capture: no RTC session');
              //     return false;
              // }
              // const muteSender = (sender: RTCRtpSender): void => {
              //     const media = sender.track?.kind;
              //     sender.replaceTrack(null)
              //         .then(() => {
              //             LOGD(`Successfully muted ${media} capture by replacing track by null`);
              //         })
              //         .catch(err => {
              //             LOGE(`Failed to mute ${media} capture by replacing track by null: ${err.name}`);
              //         });
              // };
              // if (options.audio && this.mRtpSender.audio) {
              //     muteSender(this.mRtpSender.audio);
              //     this.mMutedCapture.audio = true;
              // }
              // if (options.video && this.mRtpSender.video) {
              //     muteSender(this.mRtpSender.video);
              //     this.mMutedCapture.video = true;
              // }
              return true;
            };
            this.unmuteCapture = function (options) {
              if (options === void 0) { options = { audio: true, video: true }; }
              LOGD("".concat(_this.mPrefix, " unmuteCapture: ").concat(JSON.stringify(options)));
              options = options || { audio: true, video: true };
              if (options.audio && _this.mRtpSender.audio && _this.mRtpSender.audio.track) {
                //            muteSender(this.mRtpSender.audio);
                _this.mMutedCapture.audio = false;
                _this.mRtpSender.audio.track.enabled = true;
              }
              if (options.video && _this.mRtpSender.video && _this.mRtpSender.video.track) {
                //            muteSender(this.mRtpSender.video);
                _this.mMutedCapture.video = false;
                _this.mRtpSender.video.track.enabled = true;
              }
              // this.activateSend();
              // if (!this.mJssipRtcSession || !this.mMediaStreamLocal) {
              //     LOGE('Cannot unmute capture: no RTC session nor local mediastream');
              //     return false;
              // }
              // const unmuteSender = (sender: RTCRtpSender, track: MediaStreamTrack): void => {
              //     sender.replaceTrack(track)
              //         .then(() => {
              //             LOGD(`Successfully unmuted ${track?.kind} capture by setting track`
              //                 + ` to ${Utils.strMediaStreamTrack(track)}`);
              //         })
              //         .catch(err => {
              //             LOGD(`Failed to unmute ${track?.kind} capture by setting track`
              //             + `to ${Utils.strMediaStreamTrack(track)}: ${err.name}`);
              //         });
              // };
              // if (options.audio && this.mRtpSender.audio) {
              //     const tracks = this.mMediaStreamLocal.getAudioTracks();
              //     if (tracks) {
              //         unmuteSender(this.mRtpSender.audio, tracks[0]);
              //     }
              //     this.mMutedCapture.audio = false;
              // }
              // if (options.video && this.mRtpSender.video) {
              //     const tracks = this.mMediaStreamLocal.getVideoTracks();
              //     if (tracks) {
              //         unmuteSender(this.mRtpSender.video, tracks[0]);
              //     }
              //     this.mMutedCapture.video = false;
              // }
              return true;
            };
            this.isMutedPlay = function () { return _this.mMutedPlay; };
            this.mutePlay = function (options) {
              if (options === void 0) { options = { audio: true, video: true }; }
              if (!_this.mJssipRtcSession || !_this.mMediaStreamRemote) {
                LOGE("".concat(_this.mPrefix, " Cannot mute play: no RTC session nor remote mediastream"));
                return false;
              }
              if (options.audio && _this.mRtpReceiver.audio) {
                _this.mRtpReceiver.audio.track.enabled = false;
                _this.mMutedPlay.audio = true;
                LOGD("".concat(_this.mPrefix, " Successfully muted audio play: ").concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererRemote)));
              }
              if (options.video && _this.mRtpReceiver.video) {
                _this.mRtpReceiver.video.track.enabled = false;
                _this.mMutedPlay.video = true;
                LOGD("".concat(_this.mPrefix, " Successfully muted video play: ").concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererRemote)));
              }
              return true;
            };
            this.unmutePlay = function (options) {
              if (options === void 0) { options = { audio: true, video: true }; }
              if (!_this.mJssipRtcSession || !_this.mMediaStreamRemote) {
                LOGE("".concat(_this.mPrefix, " Cannot unmute play: no RTC session nor remote mediastream"));
                return false;
              }
              if (options.audio && _this.mRtpReceiver.audio) {
                _this.mRtpReceiver.audio.track.enabled = true;
                _this.mMutedPlay.audio = false;
                LOGD("".concat(_this.mPrefix, " Successfully unmuted audio play: ").concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererRemote)));
              }
              if (options.video && _this.mRtpReceiver.video) {
                _this.mRtpReceiver.video.track.enabled = true;
                _this.mMutedPlay.video = false;
                LOGD("".concat(_this.mPrefix, " Successfully unmuted video play: ").concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererRemote)));
              }
              return true;
            };
            this.setPlayVolume = function (volume) {
              var ret = true;
              if (_this.mMediaHandlerAudioRemote) {
                _this.mMediaHandlerAudioRemote.setGain(volume);
                LOGD("".concat(_this.mPrefix, " Set the play gain to: ").concat(volume));
              }
              else if (_this.mPlayOptions.rendererRemote) {
                _this.mPlayOptions.rendererRemote.volume = volume;
                LOGD("".concat(_this.mPrefix, " Set the play volume of ")
                  + "".concat(Utils_1.Utils.strMediaElement(_this.mPlayOptions.rendererRemote), " to: ").concat(volume));
              }
              else {
                LOGD("".concat(_this.mPrefix, " Could not set the play volume to: ").concat(volume));
                ret = false;
              }
              return ret;
            };
            this.doesMediaStreamLocalHaveActiveTracks = function () {
              var e_2, _b;
              if (!_this.mMediaStreamLocal) {
                return false;
              }
              var ret = false;
              var tracks = _this.mMediaStreamLocal.getTracks();
              try {
                for (var tracks_1 = tslib_1.__values(tracks), tracks_1_1 = tracks_1.next(); !tracks_1_1.done; tracks_1_1 = tracks_1.next()) {
                  var track = tracks_1_1.value;
                  ret = track.readyState !== 'ended';
                  if (ret) {
                    break;
                  }
                }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                try {
                  if (tracks_1_1 && !tracks_1_1.done && (_b = tracks_1.return)) _b.call(tracks_1);
                }
                finally { if (e_2) throw e_2.error; }
              }
              return ret;
            };
            this.getMediaStreamLocal = function () { return _this.mMediaStreamLocal; };
            this.setMediaStreamLocal = function (mediaStream) {
              var e_3, _b;
              _this.mMediaStreamLocal = mediaStream;
              delete _this.mMediaHandlerAudioLocal;
              if (_this.mMediaStreamLocal && _this.mMediaStreamLocal.getAudioTracks().length) {
                _this.mMediaHandlerAudioLocal = new MediaHandlerAudio_1.MediaHandlerAudio(_this.mMediaStreamLocal, true);
                _this.mMediaHandlerAudioLocal.onvolume = _this.onvolumelocal;
              }
              var tracks = mediaStream.getTracks();
              var _loop_1 = function (track) {
                if (track.getSettings) {
                  var settings = track.getSettings();
                  LOGD("".concat(_this.mPrefix, " Track ").concat(Utils_1.Utils.strMediaStreamTrack(track), " settings: ").concat(JSON.stringify(settings, null, '\t')));
                }
                if (track.getCapabilities) {
                  var capabilities = track.getCapabilities();
                  LOGD("".concat(_this.mPrefix, " Track ").concat(Utils_1.Utils.strMediaStreamTrack(track), " capabilities: ")
                    + "".concat(JSON.stringify(capabilities, null, '\t')));
                }
                track.onended = function (ev) {
                  LOGD("".concat(_this.mPrefix, " UI Event: ").concat(ev.type, " for media track: ")
                    + Utils_1.Utils.strMediaStreamTrack(ev.target));
                  if (_this.onlocalmediastreamtrackend) {
                    _this.onlocalmediastreamtrackend(track);
                  }
                };
              };
              try {
                for (var tracks_2 = tslib_1.__values(tracks), tracks_2_1 = tracks_2.next(); !tracks_2_1.done; tracks_2_1 = tracks_2.next()) {
                  var track = tracks_2_1.value;
                  _loop_1(track);
                }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                try {
                  if (tracks_2_1 && !tracks_2_1.done && (_b = tracks_2.return)) _b.call(tracks_2);
                }
                finally { if (e_3) throw e_3.error; }
              }
              _this.plugRenderers();
            };
            this.startRecordRemote = function () {
              if (!_this.mPlayOptions.shouldRecord || !_this.mMediaStreamRemote) {
                return;
              }
              var t = Date.now();
              _this.mMediaRecorderRemote = new MediaRecorder(_this.mMediaStreamRemote);
              _this.mMediaRecorderRemote.ondataavailable = function (blobEv) {
                if (blobEv.data && blobEv.data.size > 0) {
                  _this.mRecordRemote = blobEv.data;
                  _this.mRecordDurationRemote = Date.now() - t;
                  LOGD("".concat(_this.mPrefix, " New recording of remote burst of ").concat(blobEv.data.size, " bytes ")
                    + "(duration ".concat(_this.mRecordDurationRemote, ") (").concat(blobEv.data.type, ")"));
                  if (_this.onrecordremote) {
                    _this.onrecordremote();
                  }
                }
                else {
                  LOGD("".concat(_this.mPrefix, " unhandled record event for remote burst: ").concat(blobEv.type)
                    + " on stream ".concat(Utils_1.Utils.strMediaStream(_this.mMediaStreamRemote)));
                }
              };
              _this.mMediaRecorderRemote.onerror = function (evt) {
                var e = evt;
                LOGD("".concat(_this.mPrefix, " ev ").concat(evt.type, " ").concat(e.error.name, ": ").concat(e.error.message));
              };
              _this.mMediaRecorderRemote.onstart = function (evt) { return LOGD("Starting recording remote burst (".concat(evt.type, ")")); };
              _this.mMediaRecorderRemote.onstop = function (evt) { return LOGD("Stopping recording remote burst (".concat(evt.type, ")")); };
              _this.mMediaRecorderRemote.start();
              LOGD("".concat(_this.mPrefix, " Now recording remote burst on stream ").concat(Utils_1.Utils.strMediaStream(_this.mMediaStreamRemote)));
            };
            this.stopRecordRemote = function () {
              var _b;
              (_b = _this.mMediaRecorderRemote) === null || _b === void 0 ? void 0 : _b.stop();
              delete _this.mMediaRecorderRemote;
            };
            this.startRecordLocal = function () {
              if (!_this.mPlayOptions.shouldRecord || !_this.mMediaStreamLocal) {
                return;
              }
              var t = Date.now();
              _this.mMediaRecorderLocal = new MediaRecorder(_this.mMediaStreamLocal);
              _this.mMediaRecorderLocal.ondataavailable = function (blobEv) {
                if (blobEv.data && blobEv.data.size > 0) {
                  _this.mRecordLocal = blobEv.data;
                  _this.mRecordDurationLocal = Date.now() - t;
                  LOGD("".concat(_this.mPrefix, " New recording of local burst of ").concat(blobEv.data.size, " bytes ")
                    + "(duration ".concat(_this.mRecordDurationRemote || '?', ") (").concat(blobEv.data.type, ")"));
                  if (_this.onrecordlocal) {
                    _this.onrecordlocal();
                  }
                }
                else {
                  LOGD("".concat(_this.mPrefix, " unhandled record event for local burst: ").concat(blobEv.type)
                    + " on stream ".concat(Utils_1.Utils.strMediaStream(_this.mMediaStreamRemote)));
                }
              };
              _this.mMediaRecorderLocal.onerror = function (evt) {
                var e = evt;
                LOGD("ev ".concat(evt.type, " ").concat(e.error.name, ": ").concat(e.error.message));
              };
              _this.mMediaRecorderLocal.onstart = function (evt) { return LOGD("Starting recording local burst (".concat(evt.type, ")")); };
              _this.mMediaRecorderLocal.onstop = function (evt) { return LOGD("Stopping recording local burst (".concat(evt.type, ")")); };
              _this.mMediaRecorderLocal.start();
              LOGD("".concat(_this.mPrefix, " Now recording local burst on stream ").concat(Utils_1.Utils.strMediaStream(_this.mMediaStreamLocal)));
            };
            this.stopRecordLocal = function () {
              var _b;
              (_b = _this.mMediaRecorderLocal) === null || _b === void 0 ? void 0 : _b.stop();
              delete _this.mMediaRecorderLocal;
            };
            this.plugRenderers = function () {
              var e_4, _b;
              var elements = [_this.mPlayOptions.rendererLocal, _this.mPlayOptions.rendererRemote];
              var elementEventListener = function (ev) {
                LOGD("".concat(_this.mPrefix, " UI Event: ").concat(ev.type, " for rendering element: ")
                  + Utils_1.Utils.strMediaElement(ev.target));
              };
              try {
                for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {
                  var element = elements_1_1.value;
                  if (!element) {
                    break;
                  }
                  element.onabort = elementEventListener;
                  element.onended = elementEventListener;
                  element.onpause = elementEventListener;
                  element.onplaying = elementEventListener;
                  element.onstalled = elementEventListener;
                  element.onerror = function (ev, src, lno, cno, err) {
                    if (typeof (ev) === 'string') {
                      LOGD("".concat(_this.mPrefix, " UI Event: ").concat(ev, " for rendering element: ").concat((err === null || err === void 0 ? void 0 : err.message) || '?'));
                    }
                    else {
                      LOGD("".concat(_this.mPrefix, " UI Event: ").concat(ev.type, ", error: ").concat((err === null || err === void 0 ? void 0 : err.message) || '?', " for rendering element: ")
                        + Utils_1.Utils.strMediaElement(ev.target));
                    }
                  };
                }
              }
              catch (e_4_1) { e_4 = { error: e_4_1 }; }
              finally {
                try {
                  if (elements_1_1 && !elements_1_1.done && (_b = elements_1.return)) _b.call(elements_1);
                }
                finally { if (e_4) throw e_4.error; }
              }
              var plugSourceObject = function (element, mediaStream) {
                if (element.srcObject === mediaStream) {
                  return;
                }
                LOGD("".concat(_this.mPrefix, " Plugging ").concat(Utils_1.Utils.strMediaStream(mediaStream))
                  + " to renderer ".concat(Utils_1.Utils.strMediaElement(element)));
                element.autoplay = true;
                element.srcObject = mediaStream;
                // note that even the remote renderer is muted, audio routing is done using the webaudio api
                element.muted = true;
                try {
                  var playPromise = element.play();
                  // In browsers that don’t yet support this functionality, playPromise won’t be defined.
                  playPromise.then(function (ev) {
                    LOGD("".concat(_this.mPrefix, " Successfully starting to play renderer ").concat(Utils_1.Utils.strMediaElement(element)));
                    LOGD(ev);
                  }).catch(function (e) {
                    var err = e;
                    LOGD("".concat(_this.mPrefix, " Failed to play renderer ").concat(Utils_1.Utils.strMediaElement(element), ": ").concat(err.name, ": ").concat(err.message));
                  });
                }
                catch (e) {
                  var err = e;
                  LOGD("".concat(_this.mPrefix, " Exception when playing renderer ").concat(Utils_1.Utils.strMediaElement(element), ": ").concat(err.name, ": ").concat(err.message));
                }
              };
              if (_this.mPlayOptions.rendererLocal && _this.mMediaStreamLocal) {
                plugSourceObject(_this.mPlayOptions.rendererLocal, _this.mMediaStreamLocal);
              }
              if (_this.mPlayOptions.rendererRemote && _this.mMediaStreamRemote) {
                plugSourceObject(_this.mPlayOptions.rendererRemote, _this.mMediaStreamRemote);
                // if there's no mMediaHandlerAudioRemote, then unmute the remote renderer
                _this.mPlayOptions.rendererRemote.muted = !!_this.mMediaHandlerAudioRemote;
              }
            };
            this.onsdp = function (ev) {
              if (ev.originator === 'local') {
                var sdp = SdpTransform.parse(ev.sdp);
                sdp = MediaHandlerSdp_1.MediaHandlerSdp.filterCodecs(sdp, 'audio', ['opus'], true);
                sdp = MediaHandlerSdp_1.MediaHandlerSdp.setCodecFmtp(sdp, 'audio', 'opus', {
                  stereo: 0,
                  maxaveragebitrate: MediaHandler.sConfig.audio.opus.bitrate,
                  useinbandfec: MediaHandler.sConfig.audio.opus.fec
                });
                // sdp = MediaHandlerSdp.setPTime(sdp, 'audio',
                //     MediaHandler.sConfig.audio.ptime, MediaHandler.sConfig.audio.maxptime);
                sdp = MediaHandlerSdp_1.MediaHandlerSdp.rmExtensions(sdp, 'audio');
                // sdp = MediaHandlerSdp.addExtension(sdp, 'audio',
                //     'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time', 3);
                _this.mSdpLocal = sdp;
                ev.sdp = SdpTransform.write(sdp);
                // if (this.mJssipRtcSession && this.mJssipRtcSession.connection) {
                //     const desc: RTCSessionDescriptionInit = {
                //         sdp: ev.sdp,
                //         type: 'offer'
                //     };
                //     this.mJssipRtcSession.connection.setLocalDescription(desc);
                // };
              }
              else if (ev.originator === 'remote') {
                _this.mSdpRemote = SdpTransform.parse(ev.sdp);
                MediaHandlerSdp_1.MediaHandlerSdp.setCodecFmtp(_this.mSdpRemote, 'video', 'h264', {
                  // eslint-disable-next-line
                  'profile-level-id': MediaHandler.sConfig.video.h264.profileId
                });
                ev.sdp = SdpTransform.write(_this.mSdpRemote);
                _this.setRtcSenders();
              }
            };
            this.onSetRemoteDescriptionFailed = function () {
              LOGD("".concat(_this.mPrefix, " Error onSetRemoteDescriptionFailed"));
            };
            this.setRtcSenders = function () {
              var e_5, _b;
              var _c, _d;
              if (!_this.mJssipRtcSession || !_this.mJssipRtcSession.connection) {
                return;
              }
              var rtcSenders = _this.mJssipRtcSession.connection.getSenders();
              var _loop_2 = function (rtcSender) {
                var cname = Utils_1.Utils.strRtpRtcpCname(rtcSender);
                LOGD("".concat(_this.mPrefix, " Setting sender: ").concat(Utils_1.Utils.strMediaStreamTrack(rtcSender.track), " / cname: ").concat(cname ? cname : '-', "}"));
                if (((_c = rtcSender.track) === null || _c === void 0 ? void 0 : _c.kind) === 'audio') {
                  _this.mRtpSender.audio = rtcSender;
                }
                else if (((_d = rtcSender.track) === null || _d === void 0 ? void 0 : _d.kind) === 'video') {
                  _this.mRtpSender.video = rtcSender;
                  if (rtcSender && rtcSender.track) {
                    if (rtcSender.track.getSettings) {
                      var settings = rtcSender.track.getSettings();
                      LOGICE("".concat(_this.mPrefix, " Track ").concat(Utils_1.Utils.strMediaStreamTrack(rtcSender.track), " settings: ").concat(JSON.stringify(settings, null, '\t')));
                    }
                    if (rtcSender.track.getCapabilities) {
                      var capabilities = rtcSender.track.getCapabilities();
                      LOGICE("".concat(_this.mPrefix, " Track ").concat(Utils_1.Utils.strMediaStreamTrack(rtcSender.track), " capabilities: ").concat(JSON.stringify(capabilities, null, '\t')));
                    }
                    var params = rtcSender.getParameters();
                    LOGICE("".concat(_this.mPrefix, " rtcSender parameters ").concat(Utils_1.Utils.strMediaStreamTrack(rtcSender.track), " params: ").concat(JSON.stringify(params, null, '\t')));
                    if (!params.encodings) {
                      params.encodings = [{
                        scaleResolutionDownBy: 1
                      }];
                    }
                    var maxBitrate = 100000;
                    if (_this.mSdpRemote) {
                      switch (_this.mSdpRemote.media[0].rtp[0].codec.toLowerCase()) {
                        case 'vp8':
                          maxBitrate = MediaHandler.sConfig.video.vp8.bitrateMax;
                          break;
                        case 'vp9':
                          maxBitrate = MediaHandler.sConfig.video.vp9.bitrateMax;
                          break;
                        case 'h264':
                          maxBitrate = MediaHandler.sConfig.video.h264.bitrateMax;
                          break;
                      }
                    }
                    params.encodings[0].maxBitrate = maxBitrate;
                    rtcSender.setParameters(params).then(function () {
                      if (!rtcSender.track) {
                        return;
                      }
                      var newParams = rtcSender.getParameters();
                      LOGICE("".concat(_this.mPrefix, " rtcSender parameters ").concat(Utils_1.Utils.strMediaStreamTrack(rtcSender.track), " new params: ").concat(JSON.stringify(newParams, null, '\t')));
                    }).catch(function (e) {
                      LOGE(e.name + ': ' + e.message);
                    });
                  }
                }
              };
              try {
                for (var rtcSenders_1 = tslib_1.__values(rtcSenders), rtcSenders_1_1 = rtcSenders_1.next(); !rtcSenders_1_1.done; rtcSenders_1_1 = rtcSenders_1.next()) {
                  var rtcSender = rtcSenders_1_1.value;
                  _loop_2(rtcSender);
                }
              }
              catch (e_5_1) { e_5 = { error: e_5_1 }; }
              finally {
                try {
                  if (rtcSenders_1_1 && !rtcSenders_1_1.done && (_b = rtcSenders_1.return)) _b.call(rtcSenders_1);
                }
                finally { if (e_5) throw e_5.error; }
              }
            };
            this.deactivateSend = function (options) {
              if (options === void 0) { options = { audio: true, video: true }; }
              if (!_this.mJssipRtcSession || !_this.mJssipRtcSession.connection) {
                LOGD("".concat(_this.mPrefix, " No RTCPeerConnection to alter"));
                return;
              }
              var pc = _this.mJssipRtcSession.connection;
              var offerOptions = {
                iceRestart: false
              };
              LOGD("".concat(_this.mPrefix, " muteCapture: ").concat(JSON.stringify(offerOptions)));
              pc.createOffer(offerOptions)
                .then(function (desc) {
                  if (!_this.mSdpLocal) {
                    throw new Error('No local SDP???');
                  }
                  var sdp = _this.mSdpLocal;
                  if (options.audio) {
                    sdp = MediaHandlerSdp_1.MediaHandlerSdp.deactivateDirection(sdp, 'send', 'audio');
                  }
                  if (options.video) {
                    sdp = MediaHandlerSdp_1.MediaHandlerSdp.deactivateDirection(sdp, 'send', 'video');
                  }
                  desc.sdp = SdpTransform.write(sdp);
                  LOGD("".concat(_this.mPrefix, " deactivateSend: Setting new ").concat(desc.type ? desc.type : 'null', ": ").concat(desc.sdp));
                  return pc.setLocalDescription(desc);
                })
                .then(function () {
                  if (!_this.mSdpRemote) {
                    throw new Error('No remote SDP???');
                  }
                  var sdp = _this.mSdpRemote;
                  if (options.audio) {
                    sdp = MediaHandlerSdp_1.MediaHandlerSdp.deactivateDirection(sdp, 'recv', 'audio');
                  }
                  if (options.video) {
                    sdp = MediaHandlerSdp_1.MediaHandlerSdp.deactivateDirection(sdp, 'recv', 'video');
                  }
                  var desc = new RTCSessionDescription({
                    type: 'answer',
                    sdp: SdpTransform.write(sdp)
                  });
                  LOGD("".concat(_this.mPrefix, " deactivateSend: Setting new ").concat(desc.type, ": ").concat(desc.sdp));
                  return pc.setRemoteDescription(desc);
                })
                .then(function () {
                  LOGD("".concat(_this.mPrefix, " Successfully modified peerConnection object deactivated -> \"send\""));
                })
                .catch(function (e) {
                  LOGE(e.name + ': ' + e.message);
                });
            };
            this.activateSend = function () {
              if (!_this.mJssipRtcSession || !_this.mJssipRtcSession.connection) {
                LOGD("".concat(_this.mPrefix, " No RTCPeerConnection to alter"));
                return;
              }
              var pc = _this.mJssipRtcSession.connection;
              var offerOptions = {
                iceRestart: false
              };
              pc.createOffer(offerOptions)
                .then(function (desc) {
                  if (!_this.mSdpLocal) {
                    throw new Error('No local SDP???');
                  }
                  var sdp = _this.mSdpLocal;
                  sdp = MediaHandlerSdp_1.MediaHandlerSdp.activateDirection(sdp, 'send');
                  desc.sdp = SdpTransform.write(sdp);
                  LOGD("".concat(_this.mPrefix, " activateSend: Setting new ").concat(desc.type ? desc.type : 'null', ": ").concat(desc.sdp));
                  return pc.setLocalDescription(desc);
                })
                .then(function () {
                  if (!_this.mSdpRemote) {
                    throw new Error('No remote SDP???');
                  }
                  var sdp = _this.mSdpRemote;
                  sdp = MediaHandlerSdp_1.MediaHandlerSdp.activateDirection(sdp, 'recv');
                  var desc = new RTCSessionDescription({
                    type: 'answer',
                    sdp: SdpTransform.write(sdp)
                  });
                  LOGD("".concat(_this.mPrefix, " switchToSendRecv: Setting new ").concat(desc.type ? desc.type : 'null', ": ").concat(desc.sdp));
                  return pc.setRemoteDescription(desc);
                })
                .then(function () {
                  LOGD("".concat(_this.mPrefix, " Successfully modified peerConnection object -> \"sendrecv\""));
                })
                .catch(function (e) {
                  LOGE("".concat(_this.mPrefix, " ").concat(e.name, ": ").concat(e.message));
                });
            };
            this.mPrefix = prefix;
            LOGD("".concat(this.mPrefix, " new MediaHandler"));
            this.mRtpSender = {};
            this.mRtpReceiver = {};
            if (!captureOptions) {
              captureOptions = {};
            }
            this.mCaptureOptions = captureOptions;
            this.setPlayOptions(playOptions);
            navigator.mediaDevices.addEventListener('devicechange', function (ev) {
              LOGD("".concat(_this.mPrefix, " Event: ").concat(ev.type));
              MediaHandler.listDevices();
              if (_this.ondevicechange) {
                _this.ondevicechange();
              }
            });
          }
          var _a;
          _a = MediaHandler;
          MediaHandler.sConfig = {
            audio: {
              autoGainControl: true,
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              opus: {
                bitrate: 28000,
                fec: 1
              },
              ptime: 20,
              maxptime: 60
            },
            video: {
              camera: {
                fps: 15.0,
                height: 640,
                width: 480
              },
              screensharing: {
                fps: 5.0
              },
              vp8: {
                bitrateMax: 1000000
              },
              vp9: {
                bitrateMax: 1000000
              },
              h264: {
                bitrateMax: 1000000,
                profileId: '42e01f'
              }
            }
          };
          MediaHandler.setPTime = function (p) {
            MediaHandler.sConfig.audio.ptime = Number(p);
            return true;
          };
          MediaHandler.setMaxPTime = function (p) {
            MediaHandler.sConfig.audio.maxptime = Number(p);
            return true;
          };
          MediaHandler.setCameraMaxFramerate = function (f) {
            MediaHandler.sConfig.video.camera.fps = Number(f);
            return true;
          };
          MediaHandler.setCameraMaxResolution = function (r) {
            var res = r.split('x');
            if (res.length !== 2) {
              LOGE('Invalid resolution: ' + r);
              return false;
            }
            MediaHandler.sConfig.video.camera.width = Number(res[0]);
            MediaHandler.sConfig.video.camera.height = Number(res[1]);
            return true;
          };
          MediaHandler.setScreenSharingMaxFramerate = function (f) {
            MediaHandler.sConfig.video.screensharing.fps = Number(f);
            return true;
          };
          MediaHandler.listDevices = function () {
            navigator.mediaDevices.enumerateDevices()
              .then(function (devices) {
                var e_6, _b;
                LOGD('List of available devices:');
                var i = 0;
                try {
                  for (var devices_1 = tslib_1.__values(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {
                    var device = devices_1_1.value;
                    LOGD(" * [".concat(++i, "] ").concat(device.kind, ": ")
                      + "".concat(device.label, " id = ").concat(device.deviceId, " - ").concat(device.groupId));
                  }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                  try {
                    if (devices_1_1 && !devices_1_1.done && (_b = devices_1.return)) _b.call(devices_1);
                  }
                  finally { if (e_6) throw e_6.error; }
                }
              })
              .catch(function (e) {
                var err = e;
                LOGD("".concat(err.name, ": ").concat(err.message));
              });
          };
          MediaHandler.initDeviceChangeListener = function () {
            navigator.mediaDevices.ondevicechange = function (ev) {
              LOGD('New devices: ' + ev.type);
              _a.listDevices();
            };
          };
          MediaHandler.stopMediaStream = function (mediaStream) {
            var e_7, _b;
            if (!mediaStream) {
              return;
            }
            var tracks = mediaStream.getTracks();
            try {
              for (var tracks_3 = tslib_1.__values(tracks), tracks_3_1 = tracks_3.next(); !tracks_3_1.done; tracks_3_1 = tracks_3.next()) {
                var track = tracks_3_1.value;
                track.stop();
                mediaStream.removeTrack(track);
              }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
              try {
                if (tracks_3_1 && !tracks_3_1.done && (_b = tracks_3.return)) _b.call(tracks_3);
              }
              finally { if (e_7) throw e_7.error; }
            }
          };
          return MediaHandler;
        }());
        exports.MediaHandler = MediaHandler;
        /** @public */
        (function (MediaHandler) {
          var Event;
          (function (Event) {
            /**
             * a new value for the local volume has been computed
             */
            Event["VOLUME_LOCAL"] = "volumeLocal";
            /**
             * a new value for the remote volume has been computed
             */
            Event["VOLUME_REMOTE"] = "volumeRemote";
            /**
             * a New QOS indicator has been computed, {@link (Call:class).getMediaQos}
             */
            Event["QOS"] = "qos";
            /**
             * a track from the provided local media stream has ended (user stopped sharing)
             */
            Event["MEDIA_STREAM_LOCAL_TRACK_ENDED"] = "mediaStreamLocalTrackEnded";
            /**
             * A change in input device list has been detected
             */
            Event["MEDIA_STREAM_DEVICE_CHANGE"] = "mediaStreamDeviceChange";
            /**
             * a burst has been received and recorded
             */
            Event["BURST_RECORDED_RECEIVED"] = "burstRecordedReceived";
            /**
             * a burst has been sent and recorded
             */
            Event["BURST_RECORDED_SENT"] = "burstRecordedSent";
          })(Event = MediaHandler.Event || (MediaHandler.Event = {}));
          var Panning;
          (function (Panning) {
            /**
             * Audio is not modified, and is played in both ears
             */
            Panning[Panning["CENTER"] = 0] = "CENTER";
            /**
             * Audio is left ear only
             */
            Panning[Panning["LEFT"] = -1] = "LEFT";
            /**
             * Audio is right ear only
             */
            Panning[Panning["RIGHT"] = 1] = "RIGHT";
          })(Panning = MediaHandler.Panning || (MediaHandler.Panning = {}));
        })(MediaHandler = exports.MediaHandler || (exports.MediaHandler = {}));
        exports.MediaHandler = MediaHandler;


        /***/
      }),
/* 61 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.MediaHandlerAudio = void 0;
        var Debug_1 = __webpack_require__(2);
        var Utils_1 = __webpack_require__(59);
        /** @internal */
        var LOGD = Debug_1.Debugger.extend('MediaHandlerAudio');
        var MediaHandlerAudio = /** @class */ (function () {
          function MediaHandlerAudio(mediaStream, doMute) {
            var _this = this;
            this.mAudioContext = new AudioContext();
            // private mMediaStreamAudioDestinationNode: MediaStreamAudioDestinationNode;
            this.mAudioNodes = [];
            this.mAnalyse = 0;
            this.mVolume = MediaHandlerAudio.AUDIO_LEVEL_MIN;
            // public getMediaStreamDestination = (): MediaStreamAudioDestinationNode =>
            //     this.mMediaStreamAudioDestinationNode;
            this.destroy = function () {
              delete _this.onvolume;
              if (_this.mAnalyse) {
                cancelAnimationFrame(_this.mAnalyse);
                _this.mAnalyse = 0;
              }
              _this.mAudioNodes.forEach(function (audioNode) { return audioNode.disconnect(); });
              _this.mAudioNodes = [];
              delete _this.mStereoPannerNode;
              delete _this.mGainNode;
              if (_this.mAudioContext) {
                _this.mAudioContext.close()
                  .then(function () {
                    LOGD('Audio Context is now closed');
                  })
                  .catch(function (e) {
                    var err = e;
                    LOGD("Failed to close context: ".concat(err.name, ": ").concat(err.message));
                  });
              }
            };
            this.pan = function (value) {
              if (!_this.mStereoPannerNode) {
                return;
              }
              _this.mStereoPannerNode.pan
                .setValueAtTime(MediaHandlerAudio.clamp(value, _this.mStereoPannerNode.pan), _this.mAudioContext.currentTime);
            };
            this.setGain = function (value) {
              if (!_this.mGainNode) {
                return;
              }
              _this.mGainNode.gain
                .setValueAtTime(MediaHandlerAudio.clamp(value, _this.mGainNode.gain), _this.mAudioContext.currentTime);
            };
            this.getVolume = function () { return _this.mVolume; };
            this.doAudioProcess = function () {
              var bufLength = _this.mAnalyserNode.fftSize;
              var buf = new Uint8Array(bufLength);
              _this.mAnalyserNode.getByteTimeDomainData(buf);
              // root-mean-square on the samples
              var rms = 0;
              var f = 0;
              for (var i = 0; i < bufLength; ++i) {
                f = (buf[i++] / 0x80) - 1;
                rms += f * f;
              }
              rms = Math.sqrt(rms / bufLength);
              if (rms > 0) {
                _this.mVolume = (20.0 * Math.log10(rms));
                if (_this.mVolume < MediaHandlerAudio.AUDIO_LEVEL_MIN) {
                  _this.mVolume = MediaHandlerAudio.AUDIO_LEVEL_MIN;
                }
                if (_this.mVolume > MediaHandlerAudio.AUDIO_LEVEL_MAX) {
                  _this.mVolume = MediaHandlerAudio.AUDIO_LEVEL_MAX;
                }
              }
              _this.mAnalyse = requestAnimationFrame(_this.doAudioProcess);
              if (_this.onvolume) {
                _this.onvolume();
              }
            };
            this.mMediaStream = mediaStream;
            LOGD("Creating MediaHandlerAudio for stream: ".concat(Utils_1.Utils.strMediaStream(this.mMediaStream)));
            this.mAudioContext.addEventListener('statechange', function (ev) {
              LOGD("".concat(ev.type, ": ").concat(_this.mAudioContext.state, " - stream: ").concat(Utils_1.Utils.strMediaStream(_this.mMediaStream)));
            });
            this.mMediaStreamAudioSourceNode = this.mAudioContext.createMediaStreamSource(this.mMediaStream);
            // this.mMediaStreamAudioDestinationNode = this.mAudioContext.createMediaStreamDestination();
            this.mAnalyserNode = this.mAudioContext.createAnalyser();
            this.mAnalyserNode.fftSize = 256;
            this.mMediaStreamAudioSourceNode.connect(this.mAnalyserNode);
            this.mAudioNodes.push(this.mMediaStreamAudioSourceNode);
            this.mAudioNodes.push(this.mAnalyserNode);
            if (!doMute) {
              this.mStereoPannerNode = this.mAudioContext.createStereoPanner();
              this.mGainNode = this.mAudioContext.createGain();
              this.mAudioNodes.push(this.mStereoPannerNode);
              this.mAudioNodes.push(this.mGainNode);
              this.mAnalyserNode
                .connect(this.mGainNode)
                .connect(this.mStereoPannerNode)
                .connect(this.mAudioContext.destination);
            }
            this.doAudioProcess();
          }
          MediaHandlerAudio.AUDIO_LEVEL_MIN = -127;
          MediaHandlerAudio.AUDIO_LEVEL_MAX = 0;
          MediaHandlerAudio.clamp = function (value, ap) {
            return Math.max(Math.min(value, ap.maxValue), ap.minValue);
          };
          return MediaHandlerAudio;
        }());
        exports.MediaHandlerAudio = MediaHandlerAudio;


        /***/
      }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.MediaHandlerSdp = void 0;
        var tslib_1 = __webpack_require__(1);
        var MediaHandlerSdp;
        (function (MediaHandlerSdp) {
          MediaHandlerSdp.fmtpParse = function (fmtp) {
            var e_1, _a;
            var ret = {};
            var parts = fmtp.split(';');
            try {
              for (var parts_1 = tslib_1.__values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                var part = parts_1_1.value;
                if (!part) {
                  continue;
                }
                var kv = part.trim().split('=');
                ret[kv[0].trim()] = kv[1].trim();
              }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
              try {
                if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
              }
              finally { if (e_1) throw e_1.error; }
            }
            return ret;
          };
          MediaHandlerSdp.fmtpWrite = function (params) {
            var e_2, _a;
            var ret = [];
            try {
              for (var _b = tslib_1.__values(Object.keys(params)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                ret.push("".concat(key, "=").concat(params[key]));
              }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_2) throw e_2.error; }
            }
            return ret.join(';');
          };
          MediaHandlerSdp.setCodecFmtp = function (sdp, mediaStr, codecStr, params) {
            var e_3, _a, e_4, _b, e_5, _c;
            try {
              for (var _d = tslib_1.__values(sdp.media), _e = _d.next(); !_e.done; _e = _d.next()) {
                var media = _e.value;
                if (media.type.toLowerCase() !== mediaStr.toLowerCase()) {
                  continue;
                }
                try {
                  for (var _f = (e_4 = void 0, tslib_1.__values(media.rtp)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var rtp = _g.value;
                    if (rtp.codec.toLowerCase() !== codecStr.toLowerCase()) {
                      continue;
                    }
                    var pType = rtp.payload;
                    var parsedFmtp = {};
                    try {
                      for (var _h = (e_5 = void 0, tslib_1.__values(media.fmtp)), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var fmtp = _j.value;
                        if (fmtp.payload !== pType) {
                          continue;
                        }
                        parsedFmtp = MediaHandlerSdp.fmtpParse(fmtp.config);
                        params = Object.assign(parsedFmtp, params);
                        fmtp.config = MediaHandlerSdp.fmtpWrite(params);
                        break;
                      }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                      try {
                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                      }
                      finally { if (e_5) throw e_5.error; }
                    }
                  }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                  try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                  }
                  finally { if (e_4) throw e_4.error; }
                }
              }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
              try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
              }
              finally { if (e_3) throw e_3.error; }
            }
            return sdp;
          };
          MediaHandlerSdp.filterCodecs = function (sdp, mediaStr, codecs, withTelephoneevent) {
            var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e, e_11, _f;
            try {
              for (var _g = tslib_1.__values(sdp.media), _h = _g.next(); !_h.done; _h = _g.next()) {
                var media = _h.value;
                if (mediaStr !== '*' && media.type.toLowerCase() !== mediaStr.toLowerCase()) {
                  continue;
                }
                var newRtp = [];
                var newFmtp = [];
                var newRtcpFb = [];
                var clockRates = [];
                var newPayloads = '';
                try {
                  for (var _j = (e_7 = void 0, tslib_1.__values(media.rtp)), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var rtp = _k.value;
                    if (!codecs.includes(rtp.codec.toLowerCase())) {
                      continue;
                    }
                    if (newPayloads.length !== 0) {
                      newPayloads += ' ';
                    }
                    newPayloads += rtp.payload;
                    newRtp.push(rtp);
                    if (rtp.rate) {
                      clockRates.push(rtp.rate);
                    }
                    try {
                      for (var _l = (e_8 = void 0, tslib_1.__values(media.fmtp)), _m = _l.next(); !_m.done; _m = _l.next()) {
                        var fmtp = _m.value;
                        if (fmtp.payload === rtp.payload) {
                          newFmtp.push(fmtp);
                        }
                      }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                      try {
                        if (_m && !_m.done && (_c = _l.return)) _c.call(_l);
                      }
                      finally { if (e_8) throw e_8.error; }
                    }
                    if (media.rtcpFb) {
                      try {
                        for (var _o = (e_9 = void 0, tslib_1.__values(media.rtcpFb)), _p = _o.next(); !_p.done; _p = _o.next()) {
                          var rtcpFb = _p.value;
                          if (rtcpFb.payload === rtp.payload) {
                            newRtcpFb.push(rtcpFb);
                          }
                        }
                      }
                      catch (e_9_1) { e_9 = { error: e_9_1 }; }
                      finally {
                        try {
                          if (_p && !_p.done && (_d = _o.return)) _d.call(_o);
                        }
                        finally { if (e_9) throw e_9.error; }
                      }
                    }
                  }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                  try {
                    if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
                  }
                  finally { if (e_7) throw e_7.error; }
                }
                // Now we have the clockrate for every codec, process the telephone events
                if (withTelephoneevent) {
                  var found = false;
                  var _loop_1 = function (rtp) {
                    if (rtp.codec.toLowerCase() !== 'telephone-event') {
                      return "continue";
                    }
                    if (rtp.rate && (clockRates.includes(rtp.rate))) {
                      newPayloads += " ".concat(rtp.payload);
                      newRtp.push(rtp);
                      found = true;
                      var fmtp = media.fmtp.find(function (element) { return element.payload === rtp.payload; });
                      if (fmtp) {
                        newFmtp.push(fmtp);
                      }
                    }
                  };
                  try {
                    // filter all telephone events that matches collected clockRates
                    for (var _q = (e_10 = void 0, tslib_1.__values(media.rtp)), _r = _q.next(); !_r.done; _r = _q.next()) {
                      var rtp = _r.value;
                      _loop_1(rtp);
                    }
                  }
                  catch (e_10_1) { e_10 = { error: e_10_1 }; }
                  finally {
                    try {
                      if (_r && !_r.done && (_e = _q.return)) _e.call(_q);
                    }
                    finally { if (e_10) throw e_10.error; }
                  }
                  if (!found) {
                    var pt = 101;
                    try {
                      for (var clockRates_1 = (e_11 = void 0, tslib_1.__values(clockRates)), clockRates_1_1 = clockRates_1.next(); !clockRates_1_1.done; clockRates_1_1 = clockRates_1.next()) {
                        var clockrate = clockRates_1_1.value;
                        var rtp = {
                          payload: pt++,
                          codec: 'telephone-event',
                          rate: clockrate
                        };
                        newPayloads += " ".concat(rtp.payload);
                        newRtp.push(rtp);
                      }
                    }
                    catch (e_11_1) { e_11 = { error: e_11_1 }; }
                    finally {
                      try {
                        if (clockRates_1_1 && !clockRates_1_1.done && (_f = clockRates_1.return)) _f.call(clockRates_1);
                      }
                      finally { if (e_11) throw e_11.error; }
                    }
                  }
                }
                media.rtp = newRtp;
                media.fmtp = newFmtp;
                media.rtcpFb = newRtcpFb;
                media.payloads = newPayloads;
              }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
              try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
              }
              finally { if (e_6) throw e_6.error; }
            }
            return sdp;
          };
          MediaHandlerSdp.setPTime = function (sdp, mediaStr, ptime, maxptime) {
            var e_12, _a;
            try {
              for (var _b = tslib_1.__values(sdp.media), _c = _b.next(); !_c.done; _c = _b.next()) {
                var media = _c.value;
                if (media.type.toLowerCase() !== mediaStr.toLowerCase()) {
                  continue;
                }
                media.ptime = ptime;
                media.maxptime = maxptime;
              }
            }
            catch (e_12_1) { e_12 = { error: e_12_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_12) throw e_12.error; }
            }
            return sdp;
          };
          MediaHandlerSdp.rmExtensions = function (sdp, mediaStr) {
            var e_13, _a;
            try {
              for (var _b = tslib_1.__values(sdp.media), _c = _b.next(); !_c.done; _c = _b.next()) {
                var media = _c.value;
                if (mediaStr !== '*' && media.type.toLowerCase() !== mediaStr.toLowerCase()) {
                  continue;
                }
                delete media.ext;
              }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_13) throw e_13.error; }
            }
            return sdp;
          };
          MediaHandlerSdp.addExtension = function (sdp, mediaStr, extUri, extNb) {
            var e_14, _a;
            try {
              for (var _b = tslib_1.__values(sdp.media), _c = _b.next(); !_c.done; _c = _b.next()) {
                var media = _c.value;
                if (mediaStr !== '*' && media.type.toLowerCase() !== mediaStr.toLowerCase()) {
                  continue;
                }
                var extObj = { value: extNb, uri: extUri };
                if (!media.ext) {
                  media.ext = [extObj];
                }
                else {
                  media.ext.push(extObj);
                }
              }
            }
            catch (e_14_1) { e_14 = { error: e_14_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_14) throw e_14.error; }
            }
            return sdp;
          };
          MediaHandlerSdp.toggleSdpDirection = function (direction, toggle) {
            switch (direction) {
              case 'sendrecv':
                return toggle === 'send' ? 'recvonly' : 'sendonly';
              case 'recvonly':
                return toggle === 'send' ? 'sendrecv' : 'inactive';
              case 'sendonly':
                return toggle === 'send' ? 'inactive' : 'sendrecv';
              case 'inactive':
                return toggle === 'send' ? 'sendonly' : 'recvonly';
            }
          };
          MediaHandlerSdp.activateSdpDirection = function (direction, toggle) {
            switch (direction) {
              case 'sendrecv':
                return 'sendrecv';
              case 'recvonly':
                return toggle === 'send' ? 'sendrecv' : 'recvonly';
              case 'sendonly':
                return toggle === 'send' ? 'sendonly' : 'sendrecv';
              case 'inactive':
                return toggle === 'send' ? 'sendonly' : 'recvonly';
            }
          };
          MediaHandlerSdp.deactivateSdpDirection = function (direction, toggle) {
            switch (direction) {
              case 'sendrecv':
                return toggle === 'send' ? 'recvonly' : 'sendonly';
              case 'recvonly':
                return toggle === 'send' ? 'recvonly' : 'inactive';
              case 'sendonly':
                return toggle === 'send' ? 'inactive' : 'sendonly';
              case 'inactive':
                return 'inactive';
            }
          };
          MediaHandlerSdp.activateDirection = function (sdp, toggle, type) {
            var e_15, _a;
            if (sdp.direction) {
              sdp.direction = MediaHandlerSdp.activateSdpDirection(sdp.direction, toggle);
            }
            try {
              for (var _b = tslib_1.__values(sdp.media), _c = _b.next(); !_c.done; _c = _b.next()) {
                var media = _c.value;
                if (type && media.type !== type) {
                  continue;
                }
                if (media.direction) {
                  media.direction = MediaHandlerSdp.activateSdpDirection(media.direction, toggle);
                }
              }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_15) throw e_15.error; }
            }
            return sdp;
          };
          MediaHandlerSdp.deactivateDirection = function (sdp, toggle, type) {
            var e_16, _a;
            if (sdp.direction) {
              sdp.direction = MediaHandlerSdp.deactivateSdpDirection(sdp.direction, toggle);
            }
            try {
              for (var _b = tslib_1.__values(sdp.media), _c = _b.next(); !_c.done; _c = _b.next()) {
                var media = _c.value;
                if (type && media.type !== type) {
                  continue;
                }
                if (media.direction) {
                  media.direction = MediaHandlerSdp.deactivateSdpDirection(media.direction, toggle);
                }
              }
            }
            catch (e_16_1) { e_16 = { error: e_16_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_16) throw e_16.error; }
            }
            return sdp;
          };
        })(MediaHandlerSdp = exports.MediaHandlerSdp || (exports.MediaHandlerSdp = {}));


        /***/
      }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.MediaHandlerStats = void 0;
        var tslib_1 = __webpack_require__(1);
        var Debug_1 = __webpack_require__(2);
        var TimelineDataSerie_1 = __webpack_require__(64);
        var TimelineDataView_1 = __webpack_require__(65);
        var Utils_1 = __webpack_require__(59);
        var LOGD = Debug_1.Debugger.extend('MediaHandlerStats');
        var LOGE = Debug_1.Debugger.extend('ERROR:MediaHandlerStats');
        var MediaHandlerStats = /** @class */ (function () {
          function MediaHandlerStats(peerConnection, prefix) {
            var _this = this;
            this.mQosIndicator = 0;
            this.mPrefix = '';
            this.mLastIceCandidateStat = 0;
            this.destroy = function () {
              _this.disarm();
              if (_this.mDisplayWin) {
                //         this.mDisplayWin.close();
                delete _this.mDisplayWin;
                _this.mDisplayWinEnabled = false;
              }
            };
            this.openWindow = function () {
              _this.mDisplayWinEnabled = true;
            };
            this.getQos = function () { return _this.mQosIndicator; };
            this.arm = function () {
              _this.mStatsInterval = window.setInterval(function () {
                try {
                  _this.getStats();
                }
                catch (err) {
                  LOGE("".concat(_this.mPrefix, " Error while processing stats: "), err);
                }
              }, 1000); // run the stat routine every second
            };
            this.disarm = function () {
              if (_this.mStatsInterval) {
                clearInterval(_this.mStatsInterval);
                delete _this.mStatsInterval;
              }
            };
            this.getStats = function () {
              _this.mQosIndicator = 0;
              if (_this.mPeerConnection.signalingState !== 'stable') {
                return;
              }
              _this.mPeerConnection.getStats(null)
                .then(function (stats) {
                  var rtpStreamStats = new Map();
                  stats.forEach(function (stat, key) {
                    rtpStreamStats.set(key, stat);
                  });
                  var now = Date.now();
                  var doLogIceCandidate = now - _this.mLastIceCandidateStat > 10000;
                  if (doLogIceCandidate) {
                    _this.mLastIceCandidateStat = now;
                  }
                  rtpStreamStats.forEach(function (stat, key, parent) {
                    if (stat.type === 'candidate-pair') {
                      var iceStat = stat;
                      if (doLogIceCandidate) {
                        var localCandidate = parent.get(iceStat.localCandidateId);
                        var remoteCandidate = parent.get(iceStat.remoteCandidateId);
                        var localLog = "[".concat(localCandidate.protocol, "][").concat(localCandidate.address, ":").concat(localCandidate.port, "]");
                        var remoteLog = "[".concat(remoteCandidate.protocol, "][").concat(remoteCandidate.address, ":").concat(remoteCandidate.port, "]");
                        LOGD("".concat(_this.mPrefix, " candidate pair | state: ").concat(iceStat.state.padStart('in-progress'.length, ' '), " |")
                          + " nominated: ".concat(iceStat.nominated ? 'yes' : ' no', " |")
                          + " local ".concat(localLog.padStart(30, ' '), " | remote ").concat(remoteLog.padStart(30, ' '), " |"));
                      }
                      if (iceStat.state !== 'succeeded') {
                        return;
                      }
                      _this.mStun.current.timestamp = now;
                      var rq = iceStat.requestsSent ? iceStat.requestsSent : 0;
                      var rp = iceStat.responsesReceived ? iceStat.responsesReceived : 0;
                      _this.mStun.current.diff = rq - rp;
                      _this.mStun.current.rtt = iceStat.currentRoundTripTime;
                      return;
                    }
                    if (stat.kind !== 'audio' && stat.kind !== 'video') {
                      return;
                    }
                    if (!_this.mValuesDiff.has(stat.kind)) {
                      var tmp = {
                        current: Utils_1.Utils.deepCopy(MediaHandlerStats.DEFAULT_VALUES),
                        previous: Utils_1.Utils.deepCopy(MediaHandlerStats.DEFAULT_VALUES)
                      };
                      _this.mValuesDiff.set(stat.kind, tmp);
                    }
                    var valuesDiff = _this.mValuesDiff.get(stat.kind);
                    if (!valuesDiff) {
                      LOGE('Should never occur');
                      return;
                    }
                    valuesDiff.current.timestamp = now;
                    switch (stat.type) {
                      case 'outbound-rtp':
                        {
                          var streamStats = stat;
                          valuesDiff.current.sentSsrc = streamStats.ssrc;
                          valuesDiff.current.sentPacketsRtp = streamStats.packetsSent;
                          valuesDiff.current.sentBytesRtp = streamStats.bytesSent;
                        }
                        break;
                      case 'remote-inbound-rtp':
                        {
                          var streamStats = stat;
                          valuesDiff.current.sentSsrc = streamStats.ssrc;
                          valuesDiff.current.sentPacketsLost = streamStats.packetsLost;
                          valuesDiff.current.sentJitter = streamStats.jitter;
                        }
                        break;
                      case 'inbound-rtp':
                        {
                          var streamStats = stat;
                          valuesDiff.current.receivedSsrc = streamStats.ssrc;
                          valuesDiff.current.receivedPacketsRtp = streamStats.packetsReceived;
                          valuesDiff.current.receivedBytesRtp = streamStats.bytesReceived;
                          valuesDiff.current.receivedJitter = streamStats.jitter;
                          valuesDiff.current.receivedPacketsLost = streamStats.packetsLost;
                        }
                        break;
                    }
                  });
                  _this.process();
                })
                .catch(function (e) {
                  LOGE("".concat(_this.mPrefix, " Could not get stats: ").concat(e.name, " - ").concat(e.message));
                  if (e.name === 'InvalidStateError') {
                    _this.disarm();
                  }
                });
            };
            this.process = function () {
              var computeReport = function (current, previous) {
                if (!current.timestamp || !previous.timestamp) {
                  return;
                }
                var tdiff = current.timestamp - previous.timestamp;
                if (tdiff === 0) {
                  return;
                }
                var mreport = Utils_1.Utils.deepCopy(MediaHandlerStats.DEFAULT_REPORT);
                mreport.ssrcUp = current.sentSsrc || -1;
                mreport.ssrcDown = current.receivedSsrc || -1;
                if (current.sentPackets && previous.sentPackets) {
                  mreport.packetsUp += current.sentPackets - previous.sentPackets;
                }
                if (current.sentPacketsRtp && previous.sentPacketsRtp) {
                  mreport.packetsUp += current.sentPacketsRtp - previous.sentPacketsRtp;
                }
                if (current.sentPacketsRtcp && previous.sentPacketsRtcp) {
                  mreport.packetsUp += current.sentPacketsRtcp - previous.sentPacketsRtcp;
                }
                if (current.sentBytes && previous.sentBytes) {
                  mreport.brateUp += current.sentBytes - previous.sentBytes;
                }
                if (current.sentBytesRtp && previous.sentBytesRtp) {
                  mreport.brateUp += current.sentBytesRtp - previous.sentBytesRtp;
                }
                if (current.sentBytesRtcp && previous.sentBytesRtcp) {
                  mreport.brateUp += current.sentBytesRtcp - previous.sentBytesRtcp;
                }
                if (current.receivedPackets && previous.receivedPackets) {
                  mreport.packetsDown += current.receivedPackets - previous.receivedPackets;
                }
                if (current.receivedPacketsRtp && previous.receivedPacketsRtp) {
                  mreport.packetsDown += current.receivedPacketsRtp - previous.receivedPacketsRtp;
                }
                if (current.receivedPacketsRtcp && previous.receivedPacketsRtcp) {
                  mreport.packetsDown += current.receivedPacketsRtcp - previous.receivedPacketsRtcp;
                }
                if (current.receivedBytes && previous.receivedBytes) {
                  mreport.brateDown += current.receivedBytes - previous.receivedBytes;
                }
                if (current.receivedBytesRtp && previous.receivedBytesRtp) {
                  mreport.brateDown += current.receivedBytesRtp - previous.receivedBytesRtp;
                }
                if (current.receivedBytesRtcp && previous.receivedBytesRtcp) {
                  mreport.brateDown += current.receivedBytesRtcp - previous.receivedBytesRtcp;
                }
                mreport.packetsUp = Math.round(mreport.packetsUp / (tdiff / 1000));
                mreport.packetsDown = Math.round(mreport.packetsDown / (tdiff / 1000));
                mreport.brateUp = Math.round(mreport.brateUp * 8 / (tdiff / 1000)); // timestamp in ms
                mreport.brateDown = Math.round(mreport.brateDown * 8 / (tdiff / 1000)); // timestamp in ms
                mreport.indicator = 5;
                // the exp function allows to have a rating that decreases quickly.
                // 5% losses gives a rating of 4/5
                // 20% losses gives a rating of 2.2/5
                // 80% losses gives a rating of 0.2
                if (current.sentPacketsLost && current.sentPacketsRtp) {
                  if (!previous.sentPacketsLost) {
                    previous.sentPacketsLost = 0;
                  }
                  if (!previous.sentPacketsRtp) {
                    previous.sentPacketsRtp = 0;
                  }
                  var sentPacketsRtp = current.sentPacketsRtp - previous.sentPacketsRtp;
                  if (sentPacketsRtp !== 0) {
                    mreport.lossrateUp = 100 * (current.sentPacketsLost - previous.sentPacketsLost) / sentPacketsRtp;
                    mreport.indicator = mreport.indicator * Math.exp(-1 * mreport.lossrateUp * 4.0 / 100.0);
                  }
                }
                if (current.receivedPacketsLost && current.receivedPacketsRtp) {
                  if (!previous.receivedPacketsLost) {
                    previous.receivedPacketsLost = 0;
                  }
                  if (!previous.receivedPacketsRtp) {
                    previous.receivedPacketsRtp = 0;
                  }
                  var receivedPacketsRtp = current.receivedPacketsRtp - previous.receivedPacketsRtp;
                  if (receivedPacketsRtp !== 0) {
                    mreport.lossrateDown
                      = 100 * (current.receivedPacketsLost - previous.receivedPacketsLost) / receivedPacketsRtp;
                    mreport.indicator = mreport.indicator * Math.exp(-1 * mreport.lossrateDown * 2.0 / 100.0);
                  }
                }
                if (current.sentJitter) {
                  var tmp = current.sentJitter / MediaHandlerStats.LIMIT_JITTER;
                  if (tmp > 1) {
                    tmp = 1;
                  }
                  mreport.indicator = mreport.indicator * (1.0 - (0.1 * tmp));
                  mreport.jitterUp = current.sentJitter;
                }
                // indicator is a int value
                mreport.indicator = Math.round(mreport.indicator);
                return mreport;
              };
              var reports = new Map();
              var indicator = 0;
              var n = 0;
              _this.mValuesDiff.forEach(function (valuesDiff, kind, valuesDiffs) {
                var r = computeReport(valuesDiff.current, valuesDiff.previous);
                if (r) {
                  reports.set(kind, r);
                  indicator += r.indicator;
                  ++n;
                }
                valuesDiff.previous = Utils_1.Utils.deepCopy(valuesDiff.current);
                valuesDiffs.set(kind, valuesDiff);
                _this.updateDisplay(reports);
              });
              _this.mQosIndicator = indicator / n;
              var mapToObj = function (m) {
                return Array.from(m).reduce(function (obj, _a) {
                  var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
                  obj[key] = value;
                  return obj;
                }, {});
              };
              LOGD("".concat(_this.mPrefix, " ") + JSON.stringify(mapToObj(reports)));
              // if (this.mStun.current.timestamp) {
              //     report.stun = {
              //         diff: this.mStun.current.diff,
              //         rtt: this.mStun.current.rtt
              //     };
              // }
              if (_this.onqos) {
                _this.onqos();
              }
              _this.mStun.previous = Utils_1.Utils.deepCopy(_this.mStun.current);
            };
            // public updateBandwidth = function(report, current, previous) {
            //     if (current.stunDiff > previous.stunDiff + 10 // a difference of 10 stun rq/rp? there's something wrong
            //         || report.roundtrip > 3 * this.C.LIMIT_RTT) { // that's a looong roundtrip
            //         this.logger_.warn('lower bandwidth');
            //         this.connection_.getMediaHandler().switchToLowBandwidth();
            //     }
            // };
            this.updateDisplay = function (reports) {
              var timestamp = Date.now();
              var win;
              // if the window is enabled,
              if (_this.mDisplayWinEnabled) {
                if (!_this.mDisplayWin) {
                  var html = '';
                  html += '<html>\n';
                  html += '<head>\n';
                  html += '    <meta charset="UTF-8">\n';
                  html += '    <style>\n';
                  html += '        div.graph-container {float: left; margin: 0.5em;}\n';
                  html += '        canvas {background-color: #ccc; max-width: 100%; width: 100%;}\n';
                  html += '    </style>\n';
                  html += '</head>\n';
                  html += '<body>\n';
                  html += '    <div id="sw-graphs"></div>\n';
                  html += '</body>\n';
                  html += '</html>\n';
                  win = window.open('', 'Stats ', 'toolbar=no, location=no, directories=no, status=no, menubar=no, width=800, height=800');
                  if (win) {
                    _this.mDisplayWin = win;
                    _this.mDisplayWin.document.body.innerHTML = html;
                    _this.mDisplayWin.onbeforeunload = function () {
                      _this.mDisplayWinEnabled = false;
                      delete _this.mDisplayWin;
                      delete _this.mDataViews;
                    };
                  }
                }
                win = _this.mDisplayWin;
              }
              reports.forEach(function (report, kind) {
                var e_1, _a;
                try {
                  for (var _b = tslib_1.__values(Object.entries(report)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = tslib_1.__read(_c.value, 2), e = _d[0], val = _d[1];
                    var name_1 = kind + '-' + e;
                    var tds = void 0;
                    if (!_this.mDataSeries.has(name_1)) {
                      tds = new TimelineDataSerie_1.TimelineDataSerie();
                      tds.setColor('red');
                      _this.mDataSeries.set(name_1, tds);
                    }
                    else {
                      tds = _this.mDataSeries.get(name_1);
                    }
                    if (tds) {
                      tds.addPoint(timestamp, val);
                    }
                    if (win && win !== null) {
                      if (!_this.mDataViews) {
                        _this.mDataViews = new Map();
                      }
                      if (!_this.mDataViews.has(name_1)) {
                        var graphsContainer = win.document.getElementById('sw-graphs'); // see window opening above
                        if (graphsContainer === null) {
                          continue;
                        }
                        var idGraphContainer = "sw-graph-".concat(name_1);
                        var idCanvas = "sw-canvas-".concat(name_1);
                        var a = "<div class=\"graph-container\" id=\"".concat(idGraphContainer, "\">")
                          + "<div>".concat(kind, " ").concat(e, "</div>")
                          + "<canvas id=\"".concat(idCanvas, "\"></canvas>")
                          + '</div>';
                        graphsContainer.insertAdjacentHTML('beforeend', a);
                        var canvas = win.document.getElementById(idCanvas);
                        if (canvas === null) {
                          continue;
                        }
                        _this.mDataViews.set(name_1, new TimelineDataView_1.TimelineDataView(canvas));
                      }
                      var dv = _this.mDataViews.get(name_1);
                      if (dv && tds) {
                        dv.setDataSeries([tds]);
                        dv.updateEndDate();
                      }
                    }
                  }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                  try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                  }
                  finally { if (e_1) throw e_1.error; }
                }
              });
            };
            this.isAudio = function () {
              var desc = _this.mPeerConnection.localDescription;
              if (desc) {
                return desc.sdp.includes('audio');
              }
              return false;
            };
            this.isVideo = function () {
              var desc = _this.mPeerConnection.localDescription;
              if (desc) {
                return desc.sdp.includes('video');
              }
              return false;
            };
            this.mDisplayWinEnabled = false;
            this.mCounter = 0;
            this.mPeerConnection = peerConnection;
            this.mPrefix = prefix;
            var now = Date.now();
            this.mValuesDiff = new Map();
            this.mStun = {
              current: { timestamp: now },
              previous: { timestamp: now }
            };
            this.mDataSeries = new Map();
            this.mDataViews = new Map();
            this.arm();
          }
          MediaHandlerStats.DEFAULT_VALUES = {
            sentPackets: 0,
            sentPacketsRtp: 0,
            sentPacketsRtcp: 0,
            sentBytes: 0,
            sentBytesRtp: 0,
            sentBytesRtcp: 0,
            sentPacketsLost: 0,
            sentJitter: 0,
            sentSsrc: 0,
            receivedPackets: 0,
            receivedPacketsRtp: 0,
            receivedPacketsRtcp: 0,
            receivedBytes: 0,
            receivedBytesRtp: 0,
            receivedBytesRtcp: 0,
            receivedPacketsLost: 0,
            receivedJitter: 0,
            receivedSsrc: 0,
            timestamp: 0
          };
          MediaHandlerStats.DEFAULT_REPORT = {
            timestamp: 0,
            ssrcUp: 0,
            ssrcDown: 0,
            packetsUp: 0,
            packetsDown: 0,
            brateUp: 0,
            brateDown: 0,
            lossrateUp: 0,
            lossrateDown: 0,
            jitterUp: 0,
            indicator: 0
          };
          return MediaHandlerStats;
        }());
        exports.MediaHandlerStats = MediaHandlerStats;
        (function (MediaHandlerStats) {
          MediaHandlerStats.LIMIT_LOSS = 5;
          MediaHandlerStats.LIMIT_RTT = 200;
          MediaHandlerStats.LIMIT_JITTER = 40;
        })(MediaHandlerStats = exports.MediaHandlerStats || (exports.MediaHandlerStats = {}));
        exports.MediaHandlerStats = MediaHandlerStats;


        /***/
      }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        /*
         * Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
         *
         * Use of this source code is governed by a BSD-style license
         * that can be found in the LICENSE file in the root of the source
         * tree.
         */
        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.TimelineDataSerie = void 0;
        var tslib_1 = __webpack_require__(1);
        /** @internal */
        var TimelineDataSerie = /** @class */ (function () {
          function TimelineDataSerie() {
            var _this = this;
            // List of DataPoints in chronological order.
            this.mDataPoints = [];
            // Default color. Should always be overridden prior to display.
            this.mColor = 'red';
            // Whether or not the data series should be drawn.
            this.mIsVisible = true;
            this.mCacheStepSize = 0;
            this.mCacheValues = [];
            /**
             * @override
             */
            this.toJSON = function () {
              var e_1, _a;
              if (_this.mDataPoints.length < 1) {
                return {};
              }
              var values = [];
              try {
                for (var _b = tslib_1.__values(_this.mDataPoints), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var dataPoint = _c.value;
                  values.push(dataPoint);
                }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
              }
              return {
                startTime: _this.mDataPoints[0].time,
                endTime: _this.mDataPoints[_this.mDataPoints.length - 1].time,
                values: JSON.stringify(values)
              };
            };
            /**
             * Adds a DataPoint to |this| with the specified time and value.
             * DataPoints are assumed to be received in chronological order.
             */
            this.addPoint = function (timeTicks, value) {
              var dataPoint = {
                time: (new Date(timeTicks)).getTime(),
                value: value
              };
              _this.mDataPoints.push(dataPoint);
              // will be shifted out when the buffer is full.
              var MAX_STATS_DATA_POINT_BUFFER_SIZE = 1000;
              if (_this.mDataPoints.length > MAX_STATS_DATA_POINT_BUFFER_SIZE) {
                _this.mDataPoints.shift();
              }
            };
            this.isVisible = function () { return _this.mIsVisible; };
            this.show = function (isVisible) {
              _this.mIsVisible = isVisible;
            };
            this.getColor = function () { return _this.mColor; };
            this.setColor = function (color) {
              _this.mColor = color;
            };
            this.getCount = function () { return _this.mDataPoints.length; };
            /**
             * Returns a list containing the values of the data series at |count|
             * points, starting at |startTime|, and |stepSize| milliseconds apart.
             * Caches values, so showing/hiding individual data series is fast.
             */
            this.getValues = function (startTime, stepSize, count) {
              // Use cached values, if we can.
              if (_this.mCacheStartTime === startTime
                && _this.mCacheStepSize === stepSize
                && _this.mCacheValues.length === count) {
                return _this.mCacheValues;
              }
              // Do all the work.
              _this.mCacheValues = _this.getValuesInternal(startTime, stepSize, count);
              _this.mCacheStartTime = startTime;
              _this.mCacheStepSize = stepSize;
              return _this.mCacheValues;
            };
            /**
             * Returns the cached |values| in the specified time period.
             */
            this.getValuesInternal = function (startTime, stepSize, count) {
              var values = [];
              var nextPoint = 0;
              var currentValue = 0;
              var time = startTime;
              for (var i = 0; i < count; ++i) {
                while (nextPoint < _this.mDataPoints.length
                  && _this.mDataPoints[nextPoint].time < time) {
                  currentValue = _this.mDataPoints[nextPoint].value;
                  ++nextPoint;
                }
                values[i] = currentValue;
                time += stepSize;
              }
              return values;
            };
          }
          return TimelineDataSerie;
        }());
        exports.TimelineDataSerie = TimelineDataSerie;


        /***/
      }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        /*
         * Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
         *
         * Use of this source code is governed by a BSD-style license
         * that can be found in the LICENSE file in the root of the source
         * tree.
         */
        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.TimelineDataView = void 0;
        var tslib_1 = __webpack_require__(1);
        // ported from chrome://webrtc-internals to typescript
        var TimelineConstants_1 = __webpack_require__(66);
        var TimelineGraph_1 = __webpack_require__(67);
        /** @internal */
        var TimelineDataView = /** @class */ (function () {
          function TimelineDataView(canvas) {
            var _this = this;
            this.scrollbar = { position: 0, range: 0 };
            this.startTime = 0;
            this.endTime = 1;
            this.scale = 1000;
            this.setScale = function (scale) {
              _this.scale = scale;
            };
            /**
             * Sets the date range displayed on the graph, switches to the default
             * scale factor, and moves the scrollbar all the way to the right.
             */
            this.setDateRange = function (startDate, endDate) {
              _this.startTime = startDate.getTime();
              _this.endTime = endDate.getTime();
              // Safety check.
              if (_this.endTime <= _this.startTime) {
                _this.startTime = _this.endTime - 1;
              }
              _this.updateScrollbarrange(true);
            };
            /**
             * Updates the end time at the right of the graph to be the current time.
             * Specifically, updates the scrollbar's range, and if the scrollbar is
             * all the way to the right, keeps it all the way to the right. Otherwise,
             * leaves the view as-is and doesn't redraw anything.
             */
            this.updateEndDate = function (optDate) {
              if (!optDate) {
                optDate = (new Date()).getTime();
              }
              _this.endTime = optDate;
              _this.updateScrollbarrange(_this.graphScrolledToRightEdge());
            };
            this.getStartDate = function () { return new Date(_this.startTime); };
            /**
             * Replaces the current TimelineDataSerie with |dataSeries|.
             */
            this.setDataSeries = function (dataSeries) {
              var e_1, _a;
              // Simply recreates the Graph.
              _this.graph = new TimelineGraph_1.TimelineGraph();
              try {
                for (var dataSeries_1 = tslib_1.__values(dataSeries), dataSeries_1_1 = dataSeries_1.next(); !dataSeries_1_1.done; dataSeries_1_1 = dataSeries_1.next()) {
                  var tds = dataSeries_1_1.value;
                  _this.graph.addDataSeries(tds);
                }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                try {
                  if (dataSeries_1_1 && !dataSeries_1_1.done && (_a = dataSeries_1.return)) _a.call(dataSeries_1);
                }
                finally { if (e_1) throw e_1.error; }
              }
              _this.repaint();
            };
            /**
             * Adds |dataSeries| to the current graph.
             */
            this.addDataSeries = function (dataSeries) {
              if (!_this.graph) {
                _this.graph = new TimelineGraph_1.TimelineGraph();
              }
              _this.graph.addDataSeries(dataSeries);
              _this.repaint();
            };
            /**
             * Draws the graph on |canvas|.
             */
            this.repaint = function () {
              if (!_this.canvas) {
                return;
              }
              var width = _this.canvas.width;
              var height = _this.canvas.height;
              var context = _this.canvas.getContext('2d');
              if (!context) {
                return;
              }
              // Clear the canvas.
              context.fillStyle = TimelineConstants_1.TimelineConstants.BACKGROUND_COLOR;
              context.fillRect(0, 0, width, height);
              // Try to get font height in pixels. Needed for layout.
              var regex = RegExp('([0-9]+)px');
              var font = regex.exec(context.font);
              if (!font) {
                return;
              }
              var fontHeightString = font[1];
              var fontHeight = parseInt(fontHeightString, 10);
              // Safety check, to avoid drawing anything too ugly.
              if (fontHeightString.length === 0 || fontHeight <= 0
                || fontHeight * 4 > height || width < 50) {
                return;
              }
              // Save current transformation matrix so we can restore it later.
              context.save();
              // The center of an HTML canvas pixel is technically at (0.5, 0.5). This
              // makes near straight lines look bad, due to anti-aliasing. This
              // translation reduces the problem a little.
              context.translate(0.5, 0.5);
              // Figure out what time values to display.
              var position = _this.scrollbar.position;
              // If the entire time range is being displayed, align the right edge of
              // the graph to the end of the time range.
              if (_this.scrollbar.range === 0) {
                position = _this.getLength() - _this.canvas.width;
              }
              var visibleStartTime = _this.startTime + position * _this.scale;
              // Make space at the bottom of the graph for the time labels, and then
              // draw the labels.
              var textHeight = height;
              height -= fontHeight + TimelineConstants_1.TimelineConstants.LABEL_VERTICAL_SPACING;
              _this.drawTimeLabels(context, width, height, textHeight, visibleStartTime);
              // Draw outline of the main graph area.
              context.strokeStyle = TimelineConstants_1.TimelineConstants.GRID_COLOR;
              context.strokeRect(0, 0, width - 1, height - 1);
              if (_this.graph) {
                // Layout graph and have them draw their tick marks.
                _this.graph.layout(width, height, fontHeight, visibleStartTime, _this.scale);
                _this.graph.drawTicks(context);
                // Draw the lines of all graphs, and then draw their labels.
                _this.graph.drawLines(context);
                _this.graph.drawLabels(context);
              }
              // Restore original transformation matrix.
              context.restore();
            };
            /**
             * Draw time labels below the graph. Takes in start time as an argument
             * since it may not be |startTime|, when we're displaying the entire
             * time range.
             */
            this.drawTimeLabels = function (context, width, height, textHeight, startTime) {
              // Draw the labels 1 minute apart.
              var timeStep = 1000 * 60;
              // Find the time for the first label. This time is a perfect multiple of
              // timeStep because of how UTC times work.
              var time = Math.ceil(startTime / timeStep) * timeStep;
              context.textBaseline = 'bottom';
              context.textAlign = 'center';
              context.fillStyle = TimelineConstants_1.TimelineConstants.TEXT_COLOR;
              context.strokeStyle = TimelineConstants_1.TimelineConstants.GRID_COLOR;
              // Draw labels and vertical grid lines.
              while (true) {
                var x = Math.round((time - startTime) / _this.scale);
                if (x >= width) {
                  break;
                }
                var text = (new Date(time)).toLocaleTimeString();
                context.fillText(text, x, textHeight);
                context.beginPath();
                context.lineTo(x, 0);
                context.lineTo(x, height);
                context.stroke();
                time += timeStep;
              }
            };
            this.getDataSeriesCount = function () {
              if (_this.graph) {
                return _this.graph.getDataSeries().length;
              }
              return 0;
            };
            this.hasDataSerie = function (dataSerie) {
              if (_this.graph) {
                return _this.graph.hasDataSerie(dataSerie);
              }
              return false;
            };
            // Returns the total length of the graph, in pixels.
            this.getLength = function () {
              var timeRange = _this.endTime - _this.startTime;
              // Math.floor is used to ignore the last partial area, of length less
              // than this.scale.
              return Math.floor(timeRange / _this.scale);
            };
            /**
             * Returns true if the graph is scrolled all the way to the right.
             */
            this.graphScrolledToRightEdge = function () { return _this.scrollbar.position === _this.scrollbar.range; };
            /**
             * Update the range of the scrollbar. If |resetPosition| is true, also
             * sets the slider to point at the rightmost position and triggers a
             * repaint.
             */
            this.updateScrollbarrange = function (resetPosition) {
              if (!_this.canvas) {
                return;
              }
              var scrollbarRange = _this.getLength() - _this.canvas.width;
              if (scrollbarRange < 0) {
                scrollbarRange = 0;
              }
              // If we've decreased the range to less than the current scroll position,
              // we need to move the scroll position.
              if (_this.scrollbar.position > scrollbarRange) {
                resetPosition = true;
              }
              _this.scrollbar.range = scrollbarRange;
              if (resetPosition) {
                _this.scrollbar.position = scrollbarRange;
                _this.repaint();
              }
            };
            // this.graphDiv = doc.getElementById(divId);
            this.canvas = canvas;
            // Set the range and scale of the graph. Times are in milliseconds since
            // the Unix epoch.
            // All measurements we have must be after this time.
            this.startTime = 0;
            // The current rightmost position of the graph is always at most this.
            this.endTime = 1;
            // Horizontal scale factor, in terms of milliseconds per pixel.
            this.scale = 1000;
            // Initialize the scrollbar.
            this.updateScrollbarrange(true);
          }
          return TimelineDataView;
        }());
        exports.TimelineDataView = TimelineDataView;


        /***/
      }),
/* 66 */
/***/ ((__unused_webpack_module, exports) => {

        "use strict";

        /*
         * Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
         *
         * Use of this source code is governed by a BSD-style license
         * that can be found in the LICENSE file in the root of the source
         * tree.
         */
        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.TimelineConstants = void 0;
        // ported from chrome://webrtc-internals to typescript
        /** @internal */
        var TimelineConstants;
        (function (TimelineConstants) {
          // Maximum number of labels placed vertically along the sides of the graph.
          TimelineConstants.MAX_VERTICAL_LABELS = 6;
          // Vertical spacing between labels and between the graph and labels.
          TimelineConstants.LABEL_VERTICAL_SPACING = 4;
          // Horizontal spacing between vertically placed labels and the edges of the
          // graph.
          TimelineConstants.LABEL_HORIZONTAL_SPACING = 3;
          // Horizintal spacing between two horitonally placed labels along the bottom
          // of the graph.
          // let LABEL_LABEL_HORIZONTAL_SPACING = 25;
          // Length of ticks, in pixels, next to y-axis labels. The x-axis only has
          // one set of labels, so it can use lines instead.
          TimelineConstants.Y_AXIS_TICK_LENGTH = 10;
          TimelineConstants.GRID_COLOR = '#CCC';
          TimelineConstants.TEXT_COLOR = '#000';
          TimelineConstants.BACKGROUND_COLOR = '#FFF';
          TimelineConstants.MAX_DECIMAL_PRECISION = 2;
        })(TimelineConstants = exports.TimelineConstants || (exports.TimelineConstants = {}));


        /***/
      }),
/* 67 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        /*
         * Copyright (c) 2015 The WebRTC project authors. All Rights Reserved.
         *
         * Use of this source code is governed by a BSD-style license
         * that can be found in the LICENSE file in the root of the source
         * tree.
         */
        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.TimelineGraph = void 0;
        var tslib_1 = __webpack_require__(1);
        // ported from chrome://webrtc-internals to typescript
        var TimelineConstants_1 = __webpack_require__(66);
        /**
         * A Graph is responsible for drawing all the TimelineDataSerie that have
         * the same data type. Graphs are responsible for scaling the values, laying
         * out labels, and drawing both labels and lines for its data series.
         *
         * @internal
         */
        var TimelineGraph = /** @class */ (function () {
          function TimelineGraph() {
            var _this = this;
            this.addDataSeries = function (dataSeries) {
              _this.mDataSeries.push(dataSeries);
              return;
            };
            this.hasDataSerie = function (dataSeries) {
              var e_1, _a;
              try {
                for (var _b = tslib_1.__values(_this.mDataSeries), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var tds = _c.value;
                  if (tds === dataSeries) {
                    return true;
                  }
                }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
              }
              return false;
            };
            this.getDataSeries = function () { return _this.mDataSeries; };
            /**
             * Returns a list of all the values that should be displayed for a given
             * data series, using the current graph layout.
             */
            this.getValues = function (dataSeries) {
              if (!dataSeries.isVisible()) {
                return null;
              }
              return dataSeries.getValues(_this.mStartTime, _this.mScale, _this.mWidth);
            };
            /**
             * Updates the graph's layout. In particular, both the max value and
             * label positions are updated. Must be called before calling any of the
             * drawing functions.
             */
            this.layout = function (width, height, fontHeight, startTime, scale) {
              var e_2, _a, e_3, _b;
              _this.mWidth = width;
              _this.mHeight = height;
              _this.mFontHeight = fontHeight;
              _this.mStartTime = startTime;
              _this.mScale = scale;
              // Find largest value.
              var max = 0;
              var min = 0;
              try {
                for (var _c = tslib_1.__values(_this.mDataSeries), _d = _c.next(); !_d.done; _d = _c.next()) {
                  var tds = _d.value;
                  var values = _this.getValues(tds);
                  if (!values) {
                    continue;
                  }
                  try {
                    for (var values_1 = (e_3 = void 0, tslib_1.__values(values)), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                      var value = values_1_1.value;
                      if (value > max) {
                        max = value;
                      }
                      else if (value < min) {
                        min = value;
                      }
                    }
                  }
                  catch (e_3_1) { e_3 = { error: e_3_1 }; }
                  finally {
                    try {
                      if (values_1_1 && !values_1_1.done && (_b = values_1.return)) _b.call(values_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                  }
                }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                try {
                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
              }
              _this.layoutlabels(min, max);
            };
            /**
             * Same as layoutlabels, but ignores units. |maxDecimalDigits| is the
             * maximum number of decimal digits allowed. The minimum allowed
             * difference between two adjacent labels is 10^-|maxDecimalDigits|.
             */
            this.layoutLabelsBasic = function (minValue, maxValue, maxDecimalDigits) {
              _this.mLabels = [];
              var range = maxValue - minValue;
              // No labels if the range is 0.
              if (range === 0) {
                _this.mMin = _this.mMax = maxValue;
                return;
              }
              // The maximum number of equally spaced labels allowed. |fontHeight|
              // is doubled because the top two labels are both drawn in the same
              // gap.
              var minLabelSpacing = 2 * _this.mFontHeight + TimelineConstants_1.TimelineConstants.LABEL_VERTICAL_SPACING;
              // The + 1 is for the top label.
              var maxLabels = 1 + _this.mHeight / minLabelSpacing;
              if (maxLabels < 2) {
                maxLabels = 2;
              }
              else if (maxLabels > TimelineConstants_1.TimelineConstants.MAX_VERTICAL_LABELS) {
                maxLabels = TimelineConstants_1.TimelineConstants.MAX_VERTICAL_LABELS;
              }
              // Initial try for step size between conecutive labels.
              var stepSize = Math.pow(10, -maxDecimalDigits);
              // Number of digits to the right of the decimal of |stepSize|.
              // Used for formating label strings.
              var stepSizeDecimalDigits = maxDecimalDigits;
              // Pick a reasonable step size.
              while (true) {
                // If we use a step size of |stepSize| between labels, we'll need:
                //
                // Math.ceil(range / stepSize) + 1
                //
                // labels. The + 1 is because we need labels at both at 0 and at
                // the top of the graph.
                // Check if we can use steps of size |stepSize|.
                if (Math.ceil(range / stepSize) + 1 <= maxLabels) {
                  break;
                }
                // Check |stepSize| * 2.
                if (Math.ceil(range / (stepSize * 2)) + 1 <= maxLabels) {
                  stepSize *= 2;
                  break;
                }
                // Check |stepSize| * 5.
                if (Math.ceil(range / (stepSize * 5)) + 1 <= maxLabels) {
                  stepSize *= 5;
                  break;
                }
                stepSize *= 10;
                if (stepSizeDecimalDigits > 0) {
                  --stepSizeDecimalDigits;
                }
              }
              // Set the min/max so it's an exact multiple of the chosen step size.
              _this.mMax = Math.ceil(maxValue / stepSize) * stepSize;
              _this.mMin = Math.floor(minValue / stepSize) * stepSize;
              // Create labels.
              for (var label = _this.mMax; label >= _this.mMin; label -= stepSize) {
                _this.mLabels.push(label.toFixed(stepSizeDecimalDigits));
              }
            };
            /**
             * Draws tick marks for each of the labels in |labels|.
             */
            this.drawTicks = function (context) {
              var x1 = _this.mWidth - 1;
              var x2 = _this.mWidth - 1 - TimelineConstants_1.TimelineConstants.Y_AXIS_TICK_LENGTH;
              context.fillStyle = TimelineConstants_1.TimelineConstants.GRID_COLOR;
              context.beginPath();
              for (var i = 1; i < _this.mLabels.length - 1; ++i) {
                // The rounding is needed to avoid ugly 2-pixel wide anti-aliased
                // lines.
                var y = Math.round(_this.mHeight * i / (_this.mLabels.length - 1));
                context.moveTo(x1, y);
                context.lineTo(x2, y);
              }
              context.stroke();
            };
            /**
             * Draws a graph line for each of the data series.
             */
            this.drawLines = function (context) {
              // Factor by which to scale all values to convert them to a number from
              // 0 to height - 1.
              var scale = 0;
              var bottom = _this.mHeight - 1;
              if (_this.mMax) {
                scale = bottom / (_this.mMax - _this.mMin);
              }
              // Draw in reverse order, so earlier data series are drawn on top of
              // subsequent ones.
              for (var i = _this.mDataSeries.length - 1; i >= 0; --i) {
                var values = _this.getValues(_this.mDataSeries[i]);
                if (!values) {
                  continue;
                }
                context.strokeStyle = _this.mDataSeries[i].getColor();
                context.beginPath();
                for (var x = 0; x < values.length; ++x) {
                  // The rounding is needed to avoid ugly 2-pixel wide anti-aliased
                  // horizontal lines.
                  context.lineTo(x, bottom - Math.round((values[x] - _this.mMin) * scale));
                }
                context.stroke();
              }
            };
            /**
             * Draw labels in |labels|.
             */
            this.drawLabels = function (context) {
              if (_this.mLabels.length === 0) {
                return;
              }
              var x = _this.mWidth - TimelineConstants_1.TimelineConstants.LABEL_HORIZONTAL_SPACING;
              // Set up the context.
              context.fillStyle = TimelineConstants_1.TimelineConstants.TEXT_COLOR;
              context.textAlign = 'right';
              // Draw top label, which is the only one that appears below its tick
              // mark.
              context.textBaseline = 'top';
              context.fillText(_this.mLabels[0], x, 0);
              // Draw all the other labels.
              context.textBaseline = 'bottom';
              var step = (_this.mHeight - 1) / (_this.mLabels.length - 1);
              for (var i = 1; i < _this.mLabels.length; ++i) {
                context.fillText(_this.mLabels[i], x, step * i);
              }
            };
            /**
             * Lays out labels and sets |max|/|min|, taking the time units into
             * consideration. |maxValue| is the actual maximum value, and
             * |max| will be set to the value of the largest label, which
             * will be at least |maxValue|. Similar for |min|.
             */
            this.layoutlabels = function (minValue, maxValue) {
              if (maxValue - minValue < 1024) {
                _this.layoutLabelsBasic(minValue, maxValue, TimelineConstants_1.TimelineConstants.MAX_DECIMAL_PRECISION);
                return;
              }
              // Find appropriate units to use.
              var units = ['', 'k', 'M', 'G', 'T', 'P'];
              // Units to use for labels. 0 is '1', 1 is K, etc.
              // We start with 1, and work our way up.
              var unit = 1;
              minValue /= 1024;
              maxValue /= 1024;
              while (units[unit + 1] && maxValue - minValue >= 1024) {
                minValue /= 1024;
                maxValue /= 1024;
                ++unit;
              }
              // Calculate labels.
              _this.layoutLabelsBasic(minValue, maxValue, TimelineConstants_1.TimelineConstants.MAX_DECIMAL_PRECISION);
              // Append units to labels.
              for (var i = 0; i < _this.mLabels.length; ++i) {
                _this.mLabels[i] += ' ' + units[unit];
              }
              // Convert |min|/|max| back to unit '1'.
              _this.mMin *= Math.pow(1024, unit);
              _this.mMax *= Math.pow(1024, unit);
            };
            this.mDataSeries = [];
            // Cached properties of the graph, set in layout.
            this.mWidth = 0;
            this.mHeight = 0;
            this.mFontHeight = 0;
            this.mStartTime = 0;
            this.mScale = 0;
            // The lowest/highest values adjusted by the vertical label step size
            // in the displayed range of the graph. Used for scaling and setting
            // labels. Set in layoutLabels.
            this.mMin = 0;
            this.mMax = 0;
            // Cached text of equally spaced labels. Set in layoutLabels.
            this.mLabels = [];
          }
          return TimelineGraph;
        }());
        exports.TimelineGraph = TimelineGraph;


        /***/
      }),
/* 68 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.Participants = void 0;
        var tslib_1 = __webpack_require__(1);
        var Debug_1 = __webpack_require__(2);
        var Participant_1 = __webpack_require__(58);
        var LOGD = Debug_1.Debugger.extend('Participants');
        /** @internal */
        var Participants = /** @class */ (function () {
          function Participants() {
            var _this = this;
            this.mParticipantMap = new Map();
            this.getLastUpdated = function () { return _this.mParticipantLastUpdated; };
            this.add = function (contact, state) {
              var part;
              var c = Participant_1.Participant.contactBeforeAt(contact);
              if (_this.mParticipantMap.has(c)) {
                part = _this.mParticipantMap.get(c);
              }
              else {
                part = new Participant_1.Participant(contact);
                _this.mParticipantMap.set(c, part);
              }
              part.updateState(state, true);
              _this.mParticipantLastUpdated = part;
              return part;
            };
            this.get = function (contact) {
              var _a;
              if ((_a = _this.mParticipantLastUpdated) === null || _a === void 0 ? void 0 : _a.hasIdentity(contact)) {
                return _this.mParticipantLastUpdated;
              }
              var c = Participant_1.Participant.contactBeforeAt(contact);
              var ret = _this.mParticipantMap.get(c);
              _this.mParticipantLastUpdated = ret;
              return ret;
            };
            this.count = function (states) {
              var e_1, _a;
              var ret = 0;
              try {
                for (var _b = tslib_1.__values(_this.mParticipantMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var part = _c.value;
                  if (states.includes(part.getState())) {
                    ++ret;
                  }
                }
              }
              catch (e_1_1) { e_1 = { error: e_1_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
              }
              return ret;
            };
            this.getByState = function (state, onlyNew) {
              var e_2, _a;
              if (!state) {
                state = Participant_1.Participant.State.ALL_PARTICIPANT;
              }
              var ret = new Map();
              try {
                for (var _b = tslib_1.__values(_this.mParticipantMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var part = _c.value;
                  if (state !== Participant_1.Participant.State.ALL_PARTICIPANT && state !== part.getState()) {
                    continue;
                  }
                  if (onlyNew && !part.isNew()) {
                    continue;
                  }
                  part.setNew(false);
                  var arr = ret.get(part.getState());
                  if (!arr) {
                    arr = [];
                    ret.set(part.getState(), arr);
                  }
                  arr.push(part.getIdentity());
                }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
              }
              return ret;
            };
            this.clear = function () {
              delete _this.mParticipantLastUpdated;
              _this.mParticipantMap.clear();
            };
            this.updateParticipantList = function (participantList, reset) {
              var e_3, _a, e_4, _b;
              if (reset) {
                _this.clear();
              }
              var keys = Object.keys(participantList);
              try {
                for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                  var state = keys_1_1.value;
                  var strs = participantList[state];
                  try {
                    for (var strs_1 = (e_4 = void 0, tslib_1.__values(strs)), strs_1_1 = strs_1.next(); !strs_1_1.done; strs_1_1 = strs_1.next()) {
                      var str = strs_1_1.value;
                      _this.add(str, state);
                    }
                  }
                  catch (e_4_1) { e_4 = { error: e_4_1 }; }
                  finally {
                    try {
                      if (strs_1_1 && !strs_1_1.done && (_b = strs_1.return)) _b.call(strs_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                  }
                }
              }
              catch (e_3_1) { e_3 = { error: e_3_1 }; }
              finally {
                try {
                  if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_3) throw e_3.error; }
              }
            };
            this.parseAttendingArrivalTime = function (participantList) {
              var e_5, _a;
              if (!participantList.AttendingArrivalTime) {
                return;
              }
              try {
                for (var _b = tslib_1.__values(Object.keys(participantList.AttendingArrivalTime)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var contact = _c.value;
                  var p = _this.get(contact);
                  if (p) {
                    var d = new Date(participantList.AttendingArrivalTime[contact]);
                    p.updateArrivalTime(d);
                  }
                  else {
                    LOGD('Trying to update arrival time of unknown participant: "' + contact + '"');
                  }
                }
              }
              catch (e_5_1) { e_5 = { error: e_5_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
              }
            };
            this.parseFloorPriority = function (participantList) {
              var e_6, _a;
              var priorities = participantList.WTSupervisoryLevels
                ? participantList.WTSupervisoryLevels
                : participantList.Priorities;
              if (!priorities) {
                return;
              }
              try {
                for (var _b = tslib_1.__values(Object.keys(priorities)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var contact = _c.value;
                  var p = _this.get(contact);
                  if (p) {
                    var d = parseInt(priorities[contact], 10);
                    p.updateFloorPriority(d);
                  }
                  else {
                    LOGD('Trying to update floor priority of unknown participant: "' + contact + '"');
                  }
                }
              }
              catch (e_6_1) { e_6 = { error: e_6_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
              }
            };
            this.parseVideoCaptureSources = function (participantList) {
              var e_7, _a;
              if (!participantList.VideoCaptureSources) {
                return;
              }
              try {
                for (var _b = tslib_1.__values(Object.keys(participantList.VideoCaptureSources)), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var contact = _c.value;
                  var p = _this.get(contact);
                  if (p) {
                    var vcs = participantList.VideoCaptureSources[contact];
                    p.updateVideoCaptureSource(vcs);
                  }
                  else {
                    LOGD('Trying to update Video Capture source of unknown participant: "' + contact + '"');
                  }
                }
              }
              catch (e_7_1) { e_7 = { error: e_7_1 }; }
              finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
              }
            };
            this.onServiceMessageParticipant = function (smt, participantList) {
              if (!participantList.Contact) {
                LOGD('Invalid message "' + smt + '": missing "Contact" field');
                return;
              }
              var s = Participant_1.Participant.State.UNKNOWN;
              switch (smt) {
                case Participant_1.Participant.Event.PARTICIPANT_INVITED:
                  s = Participant_1.Participant.State.INVITED;
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_REACHED:
                  s = Participant_1.Participant.State.REACHED;
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_JOINED:
                  s = Participant_1.Participant.State.ATTENDING;
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_LEFT:
                  if (participantList.Cause === Participant_1.Participant.LeftCause.CONNECTION_ERROR) {
                    s = Participant_1.Participant.State.RECONNECTING;
                  }
                  else {
                    s = Participant_1.Participant.State.HUNGUP;
                  }
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_REFUSED:
                  s = Participant_1.Participant.State.DECLINED;
                  switch (participantList.Reason) {
                    case Participant_1.Participant.RefusedReason.BUSY:
                      s = Participant_1.Participant.State.BUSY;
                      break;
                    case Participant_1.Participant.RefusedReason.UNANSWERING:
                      s = Participant_1.Participant.State.UNANSWERING;
                      break;
                    default:
                    case Participant_1.Participant.RefusedReason.DECLINED:
                      s = Participant_1.Participant.State.DECLINED;
                      break;
                  }
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_RESUME:
                  s = Participant_1.Participant.State.ATTENDING;
                  break;
                case Participant_1.Participant.Event.PARTICIPANT_ONHOLD:
                  s = Participant_1.Participant.State.ATTENDING_ONHOLD;
                  break;
              }
              if (s === Participant_1.Participant.State.UNKNOWN) {
                LOGD('Participant message  "' + smt + '" sets ' + participantList.Contact
                  + ' to ' + Participant_1.Participant.State.UNKNOWN + ', aborting...');
                return;
              }
              var p = _this.get(participantList.Contact);
              if (p) {
                p.updateState(s, false);
              }
              else {
                LOGD('Received update about unknown participant ' + participantList.Contact);
                p = _this.add(participantList.Contact, s);
              }
              _this.parseAttendingArrivalTime(participantList);
              _this.onevent(smt);
            };
            this.onevent = function (pev) { LOGD('event: ' + pev); };
          }
          return Participants;
        }());
        exports.Participants = Participants;


        /***/
      }),
/* 69 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.Configuration = void 0;
        var tslib_1 = __webpack_require__(1);
        var Debug_1 = __webpack_require__(2);
        var MediaHandler_1 = __webpack_require__(60);
        var Socket_1 = __webpack_require__(70);
        /** @internal */
        var LOGD = Debug_1.Debugger.extend('Configuration');
        /** @internal */
        var LOGE = Debug_1.Debugger.extend('ERROR:Configuration');
        var cnfToFunc = new Map([
          ['voip_sip_connection_timeout', Socket_1.Socket.setConnectionTimeout],
          ['voip_sip_keepalive_interval', Socket_1.Socket.setKeepAliveInterval],
          ['voip_sip_keepalive_timeout', Socket_1.Socket.setKeepAliveTimeout],
          ['voip_video_camera_max_framerate', MediaHandler_1.MediaHandler.setCameraMaxFramerate],
          ['voip_video_camera_max_resolution', MediaHandler_1.MediaHandler.setCameraMaxResolution],
          ['voip_video_screensharing_max_framerate', MediaHandler_1.MediaHandler.setScreenSharingMaxFramerate]
        ]);
        /** @public */
        var Configuration = /** @class */ (function () {
          function Configuration() {
          }
          /**
           * Configure the js, using the client.json file
           *
           * @param cnfs - a dictionnary of key: value
           */
          Configuration.setGlobalConfiguration = function (cnfs) {
            var e_1, _a;
            try {
              for (var _b = tslib_1.__values(Object.entries(cnfs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = tslib_1.__read(_c.value, 2), key = _d[0], value = _d[1];
                var func = cnfToFunc.get(key);
                if (!func) {
                  LOGD('Skipping ' + key);
                  continue;
                }
                if (func(value)) {
                  LOGD('Successfully set ' + key + ' to ' + value);
                }
                else {
                  LOGE('Could not set ' + key + ' to ' + value);
                }
              }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
              try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
              }
              finally { if (e_1) throw e_1.error; }
            }
          };
          return Configuration;
        }());
        exports.Configuration = Configuration;


        /***/
      }),
/* 70 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.Socket = void 0;
        var Debug_1 = __webpack_require__(2);
        var Utils_1 = __webpack_require__(59);
        var LOGD = Debug_1.Debugger.extend('Transport');
        var LOGE = Debug_1.Debugger.extend('ERROR:Transport');
        /** @internal */
        var Socket = /** @class */ (function () {
          function Socket(url) {
            var _this = this;
            this.mInstanceId = Socket.sInstanceCount++;
            this.connect = function () {
              LOGD("".concat(_this.toString(), ": connect()"));
              if (_this.isConnected()) {
                LOGD("WebSocket ".concat(_this.url, " is already connected, recall onconnect"));
                _this.onconnect();
                return;
              }
              else if (_this.isConnecting()) {
                LOGD("WebSocket ".concat(_this.url, " is connecting"));
                return;
              }
              if (_this.mWs) {
                _this.disconnect();
              }
              LOGD("".concat(_this.toString(), ": Connecting"));
              try {
                _this.mWs = new WebSocket(_this.url, 'sip');
                _this.mWs.binaryType = 'arraybuffer';
                _this.mWs.onopen = _this.onOpen;
                _this.mWs.onclose = _this.onClose;
                _this.mWs.onmessage = _this.onMessage;
                _this.mWs.onerror = _this.onError;
                _this.mConnectionTimeout = window.setTimeout(function () {
                  LOGD("".concat(_this.toString(), ": Connection timeout"));
                  _this.onconnectiontimeout();
                  _this.disconnect();
                }, Socket.sConfig.connectionTimeout * 1000);
              }
              catch (e) {
                var err = e;
                LOGD("Connect error in ".concat(_this.toString(), ": ").concat(err.name, ": ").concat(err.message));
              }
            };
            this.disconnect = function () {
              var _a;
              if (_this.mWs) {
                var code = 1000;
                LOGD("".concat(_this.toString(), ": Disconnect with code: ").concat(Socket.code2String(code), " (").concat(code, ")"));
                (_a = _this.mWs) === null || _a === void 0 ? void 0 : _a.close(code);
                delete _this.mWs;
              }
              _this.disarmKeepAlive();
              _this.disarmKeepAliveTimeout();
            };
            this.isConnected = function () { return !!_this.mWs && _this.mWs.readyState === WebSocket.OPEN; };
            this.isConnecting = function () { return !!_this.mWs && _this.mWs.readyState === WebSocket.CONNECTING; };
            this.send = function (message) {
              // if (!this.mWs) {
              //     return false;
              // }
              // if (this.mWs.readyState === WebSocket.CLOSING) {
              //     this.connect();
              // }
              if (!_this.mWs || !_this.isConnected()) {
                LOGE("".concat(_this.toString(), " is unable to send message, WebSocket is not open"));
                return false;
              }
              _this.mWs.send(message);
              return true;
            };
            this.toString = function () {
              var readyState2String = function (key) {
                switch (key) {
                  case WebSocket.CLOSED:
                    return 'CLOSED';
                  case WebSocket.CLOSING:
                    return 'CLOSING';
                  case WebSocket.CONNECTING:
                    return 'CONNECTING';
                  case WebSocket.OPEN:
                    return 'OPEN';
                }
                return 'unknown';
              };
              var ret = "#".concat(_this.mInstanceId, ": [url: ").concat(_this.url, "]");
              if (_this.mWs) {
                ret += " [websocket state: ".concat(readyState2String(_this.mWs.readyState), " (").concat(_this.mWs.readyState, ")]");
              }
              return ret;
            };
            /**
             * WebSocket Event Handlers
             */
            this.onOpen = function (ev) {
              LOGD("".concat(_this.toString(), ": Connected ").concat(ev.type));
              if (_this.mConnectionTimeout) {
                window.clearTimeout(_this.mConnectionTimeout);
              }
              delete _this.mConnectionTimeout;
              if (_this.onconnect) {
                _this.onconnect();
              }
              _this.armKeepAlive();
              _this.armKeepAliveTimeout();
            };
            this.onClose = function (ev) {
              LOGD("".concat(_this.toString(), ": Closed ").concat(ev.type, " wasClean: ").concat(Utils_1.Utils.strBool(ev.wasClean), ",")
                + " code: ".concat(Socket.code2String(ev.code), " (").concat(ev.code, "), reason: ").concat(ev.reason));
              _this.disarmKeepAlive();
              _this.disarmKeepAliveTimeout();
              if (ev.wasClean === false) {
                LOGD("".concat(_this.toString(), ": WebSocket abrupt disconnection"));
              }
              delete _this.mWs;
              _this.mWs = undefined;
              if (_this.ondisconnect) {
                var e = {
                  socket: _this,
                  error: !ev.wasClean,
                  code: ev.code,
                  reason: ev.reason
                };
                _this.ondisconnect(e);
              }
            };
            this.onMessage = function (ev) {
              LOGD("".concat(_this.toString(), ": Received message ").concat(ev.type));
              if (ev.data === Socket.CRLF) {
                _this.resetKeepAliveTimeout();
              }
              if (_this.ondata) {
                _this.ondata(ev.data);
              }
            };
            this.onError = function (ev) {
              LOGD("".concat(_this.toString(), ": onError ").concat(ev.type));
            };
            this.armKeepAlive = function () {
              _this.mKeepAliveInterval = window.setInterval(function () {
                _this.doKeepAlive();
              }, Socket.sConfig.keepAlive.interval * 1000);
            };
            this.disarmKeepAlive = function () {
              if (_this.mKeepAliveInterval) {
                clearInterval(_this.mKeepAliveInterval);
                delete _this.mKeepAliveInterval;
              }
            };
            this.doKeepAlive = function () {
              // keepalive's ping is a double CRLF
              if (_this.send(Socket.CRLF2)) {
                LOGD("".concat(_this.toString(), ": Sent KeepAlive."));
              }
              else {
                LOGE("".concat(_this.toString(), ": Failed to send KeepAlive."));
              }
            };
            this.armKeepAliveTimeout = function () {
              LOGD("".concat(_this.toString(), ": Arming keep alive timeout to ").concat(Socket.sConfig.keepAlive.timeout, "s."));
              _this.mKeepAliveTimeout = window.setTimeout(function () {
                _this.doKeepAliveTimeout();
              }, Socket.sConfig.keepAlive.timeout * 1000);
            };
            this.disarmKeepAliveTimeout = function () {
              if (_this.mKeepAliveTimeout) {
                LOGD("".concat(_this.toString(), ": Clearing keep alive timeout."));
                clearTimeout(_this.mKeepAliveTimeout);
                delete _this.mKeepAliveTimeout;
              }
            };
            this.resetKeepAliveTimeout = function () {
              _this.disarmKeepAliveTimeout();
              _this.armKeepAliveTimeout();
            };
            this.doKeepAliveTimeout = function () {
              LOGD("".concat(_this.toString(), ": No keep alive response! Shutting the transport down."));
              _this.disarmKeepAlive();
              _this.disconnect();
              _this.ondisconnect({
                socket: _this,
                error: true
              });
            };
            LOGD("".concat(this.toString(), ": New transport"));
            this.url = url;
            this.sip_uri = '';
            this.via_transport = '';
            this.onconnect = function () { return LOGD("".concat(_this.toString(), ": base onconnect")); };
            this.ondisconnect = function (event) {
              return LOGD("".concat(_this.toString(), ": base ondisconnect")
                + " ".concat(Utils_1.Utils.strBool(event.error), "/").concat(event.code || '?', "/").concat(event.reason || '?'));
            };
            this.onconnectiontimeout = function () { return LOGD("".concat(_this.toString(), ": base onconnectiontimeout")); };
            this.ondata = function (event) {
              return LOGD("".concat(_this.toString(), ": base ondata ").concat(event.substr(0, 20), "..."));
            };
            var parsedUrl = new URL(url);
            var scheme = parsedUrl.protocol.toUpperCase().slice(0, -1);
            if (scheme !== 'WSS' && scheme !== 'WS') {
              LOGE("invalid WebSocket URI scheme: ".concat(parsedUrl.protocol));
              throw new TypeError("Invalid argument: ".concat(url));
            }
            this.sip_uri = "sip:".concat(parsedUrl.host, ";transport=ws");
            this.via_transport = scheme;
          }
          Socket.sConfig = {
            connectionTimeout: 2,
            keepAlive: {
              interval: 3,
              timeout: 30
            }
          };
          Socket.CRLF = '\r\n';
          Socket.CRLF2 = '\r\n\r\n';
          Socket.sInstanceCount = 0;
          Socket.setConnectionTimeout = function (d) {
            Socket.sConfig.connectionTimeout = Number(d);
            return true;
          };
          Socket.setKeepAliveInterval = function (d) {
            Socket.sConfig.keepAlive.interval = Number(d);
            return true;
          };
          Socket.setKeepAliveTimeout = function (d) {
            Socket.sConfig.keepAlive.timeout = Number(d);
            return true;
          };
          Socket.code2String = function (code) {
            switch (code) {
              case 1000: return 'Normal Closure';
              case 1001: return 'Going Away';
              case 1002: return 'Protocol Error';
              case 1003: return 'Unsupported Data';
              case 1004: return '(For future)';
              case 1005: return 'No Status Received';
              case 1006: return 'Abnormal Closure';
              case 1007: return 'Invalid frame payload data';
              case 1008: return 'Policy Violation';
              case 1009: return 'Message too big';
              case 1010: return 'Missing Extension';
              case 1011: return 'Internal Error';
              case 1012: return 'Service Restart';
              case 1013: return 'Try Again Later';
              case 1014: return 'Bad Gateway';
              case 1015: return 'TLS Handshake';
              default:
                if (code >= 0 && code <= 999) {
                  return 'unknown';
                }
                else if (code <= 1999) {
                  return 'Reserved for future use by the WebSocket standard.';
                }
                else if (code <= 2999) {
                  return 'Reserved for use by WebSocket extensions.';
                }
                else if (code <= 3999) {
                  return 'Available for use by libraries and frameworks.';
                }
                else if (code <= 4999) {
                  return 'Available for use by applications.';
                }
            }
            return 'unknown';
          };
          return Socket;
        }());
        exports.Socket = Socket;


        /***/
      }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

        "use strict";

        Object.defineProperty(exports, "__esModule", ({ value: true }));
        exports.UA = void 0;
        var tslib_1 = __webpack_require__(1);
        var C = tslib_1.__importStar(__webpack_require__(3));
        var Call_1 = __webpack_require__(56);
        var Debug_1 = __webpack_require__(2);
        var events_1 = __webpack_require__(13);
        var Socket_1 = __webpack_require__(70);
        var LOGD = Debug_1.Debugger.extend('UA');
        /**
         * @public
         *
         * Class creating a SWSIPVOIP User Agent.
         */
        var UA = /** @class */ (function (_super) {
          tslib_1.__extends(UA, _super);
          /**
           * @param options - the UA options
           */
          function UA(options) {
            var _this = _super.call(this) || this;
            // private mSocket: JsSIP.WebSocketInterface;
            _this.mCalls = new Map();
            _this.mIsConnectionTimeout = false;
            /**
             * @param options - the call options to generate a new Call. Note this call is bound to this UA.
             * @returns the newly created call. The call may be started using the {@link (Call:class).start} function.
             */
            _this.newCall = function (options) {
              var call = new Call_1.Call(_this, options);
              _this.mCalls.set(call.getLocalId(), call);
              call.on(Call_1.Call.Event.STOPPED, function (e) {
                var _a;
                var ev = e;
                _this.mCalls.delete(ev.call.getLocalId());
                if (_this.isEmpty()) {
                  (_a = _this.mSocket) === null || _a === void 0 ? void 0 : _a.disconnect();
                }
              });
              return call;
            };
            /** @internal */
            _this.getTransport = function () { return _this.mSocket; };
            /** @internal */
            _this.getOptions = function () { return _this.mOptions; };
            /** @internal */
            _this.isEmpty = function () { return _this.mCalls.size === 0; };
            /** @internal */
            _this.disconnect = function () {
              _this.mSocket.disconnect();
            };
            /** @internal */
            _this.isConnected = function () { return _this.mSocket.isConnected(); };
            _this.toString = function () { return "UA #".concat(_this.mInstanceId, " ").concat(_this.mSocket.toString()); };
            /** @internal */
            _this.addConnectionEventListeners = function (onConnected, onConnectionTimeout) {
              if (_this.mIsConnectionTimeout) {
                onConnectionTimeout();
                return;
              }
              _this.addListener(UA.Event.CONNECTED, onConnected);
              _this.addListener(UA.Event.CONNECTION_TIMEOUT, onConnectionTimeout);
            };
            /** @internal */
            _this.removeConnectionEventListeners = function (onConnected, onConnectionTimeout) {
              _this.removeListener(UA.Event.CONNECTED, onConnected);
              _this.removeListener(UA.Event.CONNECTION_TIMEOUT, onConnectionTimeout);
            };
            _this.mInstanceId = UA.sInstanceCount++;
            _this.mOptions = options;
            _this.mSocket = new Socket_1.Socket('wss:' + C.VOIP_APP + '@' + options.host + ':' + options.port);
            // this.mTransport =
            // new JsSIP.WebSocketInterface('wss:' + C.VOIP_APP + '@' + options.host + ':' + options.port);
            _this.mSocket.onconnect = function () {
              LOGD('Transport connects to ' + _this.mSocket.url);
              _this.emit(UA.Event.CONNECTED);
            };
            _this.mSocket.onconnectiontimeout = function () {
              LOGD('Transport connection timeout to ' + _this.mSocket.url);
              _this.mIsConnectionTimeout = true;
              _this.emit(UA.Event.CONNECTION_TIMEOUT);
            };
            _this.mSocket.ondisconnect = function (e) {
              if (e.error) {
                LOGD("Transport disconnected on error: ".concat(e.reason || '?', " (").concat(e.code || '?', ")"));
                _this.emit(UA.Event.DISCONNECTED);
              }
              else {
                LOGD('Transport disconnected gracefully');
                _this.emit(UA.Event.DISCONNECTED_ERROR);
              }
            };
            _this.mSocket.connect();
            return _this;
          }
          UA.sInstanceCount = 0;
          return UA;
        }(events_1.EventEmitter));
        exports.UA = UA;
        /**
         * @public
         */
        (function (UA) {
          /**
           * @internal
           */
          var Event;
          (function (Event) {
            Event["CONNECTED"] = "CONNECTED";
            Event["CONNECTION_TIMEOUT"] = "CONNECTION_TIMEOUT";
            Event["DISCONNECTED"] = "DISCONNECTED";
            Event["DISCONNECTED_ERROR"] = "DISCONNECTED_ERROR";
          })(Event = UA.Event || (UA.Event = {}));
        })(UA = exports.UA || (exports.UA = {}));
        exports.UA = UA;


        /***/
      })
/******/]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
        /******/
      }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
        /******/
      };
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
    }
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
        /******/
      };
      /******/
    })();
/******/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for (var key in definition) {
/******/ 				if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
            /******/
          }
          /******/
        }
        /******/
      };
      /******/
    })();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
      /******/
    })();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
          /******/
        }
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
        /******/
      };
      /******/
    })();
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be in strict mode.
    (() => {
      "use strict";
      var exports = __webpack_exports__;

      Object.defineProperty(exports, "__esModule", ({ value: true }));
      exports.version = exports.name = exports.Utils = exports.UA = exports.Socket = exports.Participant = exports.MediaHandler = exports.FloorControl = exports.Configuration = exports.Call = exports.JsSIP = exports.disableLog = exports.enableLog = void 0;
      var tslib_1 = __webpack_require__(1);
      var Debug = tslib_1.__importStar(__webpack_require__(2));
      /** @public */
      exports.enableLog = Debug.enable;
      /** @public */
      exports.disableLog = Debug.disable;
      var JsSIP = tslib_1.__importStar(__webpack_require__(4));
      exports.JsSIP = JsSIP;
      var Constants_1 = __webpack_require__(3);
      Object.defineProperty(exports, "name", ({ enumerable: true, get: function () { return Constants_1.name; } }));
      Object.defineProperty(exports, "version", ({ enumerable: true, get: function () { return Constants_1.version; } }));
      var Call_1 = __webpack_require__(56);
      Object.defineProperty(exports, "Call", ({ enumerable: true, get: function () { return Call_1.Call; } }));
      var Configuration_1 = __webpack_require__(69);
      Object.defineProperty(exports, "Configuration", ({ enumerable: true, get: function () { return Configuration_1.Configuration; } }));
      var FloorControl_1 = __webpack_require__(57);
      Object.defineProperty(exports, "FloorControl", ({ enumerable: true, get: function () { return FloorControl_1.FloorControl; } }));
      var MediaHandler_1 = __webpack_require__(60);
      Object.defineProperty(exports, "MediaHandler", ({ enumerable: true, get: function () { return MediaHandler_1.MediaHandler; } }));
      var Participant_1 = __webpack_require__(58);
      Object.defineProperty(exports, "Participant", ({ enumerable: true, get: function () { return Participant_1.Participant; } }));
      var Socket_1 = __webpack_require__(70);
      Object.defineProperty(exports, "Socket", ({ enumerable: true, get: function () { return Socket_1.Socket; } }));
      var UA_1 = __webpack_require__(71);
      Object.defineProperty(exports, "UA", ({ enumerable: true, get: function () { return UA_1.UA; } }));
      var Utils_1 = __webpack_require__(59);
      Object.defineProperty(exports, "Utils", ({ enumerable: true, get: function () { return Utils_1.Utils; } }));

    })();

/******/ 	return __webpack_exports__;
    /******/
  })()
    ;
});